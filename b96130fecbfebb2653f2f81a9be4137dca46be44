{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5ea448be_96c43a87",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1113991
      },
      "writtenOn": "2022-02-08T16:57:47Z",
      "side": 1,
      "message": "PTAL",
      "revId": "b96130fecbfebb2653f2f81a9be4137dca46be44",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6fec7e4f_ce1c38b1",
        "filename": "src/chromiumos/tast/local/bundles/cros/graphics/platform_overlays.go",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2022-02-08T20:15:40Z",
      "side": 1,
      "message": "nit: readability\n\nMove success case outside the loop. Instead of put inside the for-loop, I\u0027d move outside, and I\u0027d replace the `return` with a `break`.\n\nand `len(invocationError) \u003e 0` means error.\n\n\nnot-nit:\nIIUC, as long as one of the valid formats succeeds, then the test passes. Is that correct?\nIs there a way to determine which are the primary formats that must pass?\nPerhaps by parsing some info from the kernel, or perhaps by adding a parameter to `plane_test` that lists the supported primary formats?\n\nIdeally you should only tests what must pass.\nAnd only report error on tests that failed to pass.\n\nBut if the test is Ok as it is, then I\u0027d add comment explaining why you are testing all those formats, and why the tests succeeds if only one of them passes.",
      "range": {
        "startLine": 126,
        "startChar": 0,
        "endLine": 129,
        "endChar": 9
      },
      "revId": "b96130fecbfebb2653f2f81a9be4137dca46be44",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff74e1a6_00da43fc",
        "filename": "src/chromiumos/tast/local/bundles/cros/graphics/platform_overlays.go",
        "patchSetId": 3
      },
      "lineNbr": 129,
      "author": {
        "id": 1113991
      },
      "writtenOn": "2022-02-14T21:30:22Z",
      "side": 1,
      "message": "Added comments and minimally tweaked the code because I think it\u0027s \nclearer to return as soon as any of the formats is supported, than \nto store a variable and then inspect it.\n\nRe. the not-nit, Chrome is pretty flexible when it comes to primary\nplane formats because we cannot know in advance if a given DRM\nconfiguration (i.e. format, size, other planes, internal or external\ndisplay, connector to it etc) would work -- the best way is to query\nthe DRM API directly (this is done via a page flip test). Moreover\neven if e.g. modetest lists a certain format as supported, it might\nstill break due to bugs or whatnot (I\u0027m thinking MTK). For those\nreasons Chrome is basically non-prescriptive and does what it can :/",
      "parentUuid": "6fec7e4f_ce1c38b1",
      "range": {
        "startLine": 126,
        "startChar": 0,
        "endLine": 129,
        "endChar": 9
      },
      "revId": "b96130fecbfebb2653f2f81a9be4137dca46be44",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}