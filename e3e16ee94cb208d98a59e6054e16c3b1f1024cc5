{
  "comments": [
    {
      "key": {
        "uuid": "e0068f90_72884ed0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1387481
      },
      "writtenOn": "2020-07-16T08:31:49Z",
      "side": 1,
      "message": "Hi all, here is my idea of implementing EventWatcher which provides Wait() so we can prevent polling in tests like LinkMonitorFailure and CSA, and the API of EventLogger is not changed at all.\n\nHere are some concerns:\n1. Do we really need to reimplement EventLogger with EventWatcher? By reusing the unexported functions (parseEvent and detectEventType), the code would only grow a little bit than the current version, and the advantage is the lessened usages of go routines and channels.\n2. In the current implementation, EventWatcher drops all the received events right after Stop() is called. Do you think this behavior is acceptable? If not, we would need another slice to store the Events in EventWatcher, which is kind of wasting if we implement EventLogger with it.\n\nPlease let me know what you think, thanks.",
      "revId": "e3e16ee94cb208d98a59e6054e16c3b1f1024cc5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d014427d_14f95e97",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1371981
      },
      "writtenOn": "2020-07-16T09:20:12Z",
      "side": 1,
      "message": "Generally LGTM. Some ideas for discussion.",
      "revId": "e3e16ee94cb208d98a59e6054e16c3b1f1024cc5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "970d12c5_0cedee83",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1371981
      },
      "writtenOn": "2020-07-20T00:55:53Z",
      "side": 1,
      "message": "Sorry, I overlooked this comment.\n\nFor 1, if the private functions are enough, it might be OK, but I think it still need to handle the command execution/abortion? So, it\u0027s a trade-off between performance and duplicated code, I guess. IMO, the performance difference might not be that much here and it\u0027s for testing so I slightly prefer avoiding duplicated code here.\n\nFor 2, I guess the caller usually won\u0027t operate more on the object after Stop()? So dropping the events might not be that bad? Also, I\u0027m not totally sure where you want a slice to store the Events: a slice buffer for sending to the channel (which cannot have infinite buffer)? or storing the remaining Events in another slice?",
      "parentUuid": "e0068f90_72884ed0",
      "revId": "e3e16ee94cb208d98a59e6054e16c3b1f1024cc5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dc3359e3_724d4365",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1387481
      },
      "writtenOn": "2020-07-20T02:55:44Z",
      "side": 1,
      "message": "\u003e a slice buffer for sending to the channel (which cannot have infinite buffer)?\n\nYeah, I meant this. Once the author calls the Stop(), the channel would be closed and the events that come BEFORE calling Stop() would also be dropped -- if they were not yet sent into the channel.\n\nNow I think this should not be a problem because if one would like to log the events between an accurate interval, then EventLogger should be suitable.",
      "parentUuid": "970d12c5_0cedee83",
      "revId": "e3e16ee94cb208d98a59e6054e16c3b1f1024cc5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d9456038_6aabd542",
        "filename": "src/chromiumos/tast/remote/network/iw/event_watcher.go",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 1371981
      },
      "writtenOn": "2020-07-16T09:20:12Z",
      "side": 1,
      "message": "We might have some buffer for this if we want the parsing routine less probable to get blocked by the channel.",
      "range": {
        "startLine": 56,
        "startChar": 15,
        "endLine": 56,
        "endChar": 26
      },
      "revId": "e3e16ee94cb208d98a59e6054e16c3b1f1024cc5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c23aa29_4b50313c",
        "filename": "src/chromiumos/tast/remote/network/iw/event_watcher.go",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 1387481
      },
      "writtenOn": "2020-07-17T04:22:56Z",
      "side": 1,
      "message": "Done. As I mentioned in my first comment, do you think we still need a slice to store all the events if we set a buffer here?",
      "parentUuid": "d9456038_6aabd542",
      "range": {
        "startLine": 56,
        "startChar": 15,
        "endLine": 56,
        "endChar": 26
      },
      "revId": "e3e16ee94cb208d98a59e6054e16c3b1f1024cc5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f26dcd5f_584686cc",
        "filename": "src/chromiumos/tast/remote/network/iw/event_watcher.go",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1371981
      },
      "writtenOn": "2020-07-16T09:20:12Z",
      "side": 1,
      "message": "Probably we can have a comparable error so that the behavior of Wait and WaitByType will be similar in this case.",
      "range": {
        "startLine": 95,
        "startChar": 16,
        "endLine": 95,
        "endChar": 52
      },
      "revId": "e3e16ee94cb208d98a59e6054e16c3b1f1024cc5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "29934d7c_058bae8c",
        "filename": "src/chromiumos/tast/remote/network/iw/event_watcher.go",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1387481
      },
      "writtenOn": "2020-07-17T04:22:56Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f26dcd5f_584686cc",
      "range": {
        "startLine": 95,
        "startChar": 16,
        "endLine": 95,
        "endChar": 52
      },
      "revId": "e3e16ee94cb208d98a59e6054e16c3b1f1024cc5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6d46d171_f85c337e",
        "filename": "src/chromiumos/tast/remote/network/iw/event_watcher.go",
        "patchSetId": 1
      },
      "lineNbr": 133,
      "author": {
        "id": 1371981
      },
      "writtenOn": "2020-07-16T09:20:12Z",
      "side": 1,
      "message": "Maybe the struct can hold an inner context from WithCancel and cancel() in Stop. Then the two cases can be merged.\n\nAnother alternative is to depend on the behavior that Reader will be closed after Abort. (as the old EventLogger)\n\nNot sure which one will be cleaner/safer. (IIRC, tast ssh.Cmd use a similar abort channel as here so just some ideas for discussion.).",
      "range": {
        "startLine": 129,
        "startChar": 10,
        "endLine": 133,
        "endChar": 9
      },
      "revId": "e3e16ee94cb208d98a59e6054e16c3b1f1024cc5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37c9a134_a625b189",
        "filename": "src/chromiumos/tast/remote/network/iw/event_watcher.go",
        "patchSetId": 1
      },
      "lineNbr": 133,
      "author": {
        "id": 1387481
      },
      "writtenOn": "2020-07-17T04:22:56Z",
      "side": 1,
      "message": "WithCancel LGTM, since we don\u0027t really care about the aborted reason here.",
      "parentUuid": "6d46d171_f85c337e",
      "range": {
        "startLine": 129,
        "startChar": 10,
        "endLine": 133,
        "endChar": 9
      },
      "revId": "e3e16ee94cb208d98a59e6054e16c3b1f1024cc5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}