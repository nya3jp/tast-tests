{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e380c4ea_02baaa67",
        "filename": "src/chromiumos/tast/local/bundles/cros/filemanager/zip_mount.go",
        "patchSetId": 2
      },
      "lineNbr": 141,
      "author": {
        "id": 1250573
      },
      "writtenOn": "2022-03-29T12:00:45Z",
      "side": 1,
      "message": "constructing a regex like this seems more fragile.\n\nWhat about we change the logic slightly:\n\n1. Wait for the password dialog.\n2. Grab the current currently displayed file name \n\nOption #1: Return the file name found in the dialog and the caller site can make the assertion if the returned name is valid.\n\nOption #2: This function gets the file name and check if it\u0027s present in the zipFiles array.",
      "range": {
        "startLine": 141,
        "startChar": 1,
        "endLine": 141,
        "endChar": 11
      },
      "revId": "2a9b23583ca389c7ea09dab3faf5c4500af024f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09e6b799_d9436c26",
        "filename": "src/chromiumos/tast/local/bundles/cros/filemanager/zip_mount.go",
        "patchSetId": 2
      },
      "lineNbr": 141,
      "author": {
        "id": 1362995
      },
      "writtenOn": "2022-03-30T04:29:30Z",
      "side": 1,
      "message": "Why is the regex more fragile though?\n\nI did this to wait for the expected password dialog in one step, instead of doing it in 2 steps, first getting the passwor dialog, and then checking whether the name is right or not.\nCan there be some race conditions related the fact that we check the password dialog in 2 separate steps? If the name is wrong, do we query the password dialog again?",
      "parentUuid": "e380c4ea_02baaa67",
      "range": {
        "startLine": 141,
        "startChar": 1,
        "endLine": 141,
        "endChar": 11
      },
      "revId": "2a9b23583ca389c7ea09dab3faf5c4500af024f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f771e4d7_bcd5c6c7",
        "filename": "src/chromiumos/tast/local/bundles/cros/filemanager/zip_mount.go",
        "patchSetId": 2
      },
      "lineNbr": 141,
      "author": {
        "id": 1250573
      },
      "writtenOn": "2022-03-30T23:02:54Z",
      "side": 1,
      "message": "Regex are easier to get wrong, specially when dynamically building it.\n\nAlso, depending on the regex it might yield false positives, when using \u0027.*\u0027 for example. \n\nIf you intend to match \u0027file.zip\u0027 it might also match \u0027invalid-file.zip\u0027.\n\nIf you really want to keep this current strategy, I suggest to use:\n  fmt.Sprintf(\"(%s)\", strings.Join(zipFiles[:], \"|\"))",
      "parentUuid": "09e6b799_d9436c26",
      "range": {
        "startLine": 141,
        "startChar": 1,
        "endLine": 141,
        "endChar": 11
      },
      "revId": "2a9b23583ca389c7ea09dab3faf5c4500af024f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfaef1b5_fec3c46f",
        "filename": "src/chromiumos/tast/local/bundles/cros/filemanager/zip_mount.go",
        "patchSetId": 2
      },
      "lineNbr": 311,
      "author": {
        "id": 1250573
      },
      "writtenOn": "2022-03-29T12:00:45Z",
      "side": 1,
      "message": "For the same file?\n\nI think we should change the test to verify that this is still the same file.\n\nI think we would need to re-jiggle this test a little more:\n\nPseudo code:\n  // Starts with all files.\n  lockedZipFiles :\u003d zipFiles\n  //\n  for {\n    // 1. Unlock one file waitUntilPasswordDialogExists() should tell which file.\n    //   1.1. typing the invalid passwd\n    //   1.2. then the valid passwd.\n    //\n    // 2. Remove the file from lockedZipFiles array.\n    if len(lockedZipFiles) \u003d\u003d 0 {\n      // We have checked all the zipFiles.\n      break;\n    }\n   }\n   \nWDYT?",
      "range": {
        "startLine": 311,
        "startChar": 44,
        "endLine": 311,
        "endChar": 50
      },
      "revId": "2a9b23583ca389c7ea09dab3faf5c4500af024f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f1094d7_964bf895",
        "filename": "src/chromiumos/tast/local/bundles/cros/filemanager/zip_mount.go",
        "patchSetId": 2
      },
      "lineNbr": 311,
      "author": {
        "id": 1362995
      },
      "writtenOn": "2022-03-30T04:29:30Z",
      "side": 1,
      "message": "That\u0027s what I tried to do first, but I was thinking with this simpler approach we don\u0027t really lose coverage ðŸ˜Š\n\nHere\u0027s the accessibility tree with work with for the password dialog:\nhttps://paste.googleplex.com/4996104916566016\n\nThe archive name is just plain text within the password dialog. What I tried to do was to query all the text within the password dialog and extract whichiver first string finished with \".zip\", and return it. But this already seemed fragile compared to the regex approach.\n\nThe idea was then to have an array to keep track of the \"remaining zip files names\" for which we expect a password dialog.\nBut then working with arrays is pretty hard in go... we have to manually implement the \"contains\" function, the \"remove element\" etc...",
      "parentUuid": "dfaef1b5_fec3c46f",
      "range": {
        "startLine": 311,
        "startChar": 44,
        "endLine": 311,
        "endChar": 50
      },
      "revId": "2a9b23583ca389c7ea09dab3faf5c4500af024f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5010547d_cd8f4841",
        "filename": "src/chromiumos/tast/local/bundles/cros/filemanager/zip_mount.go",
        "patchSetId": 2
      },
      "lineNbr": 311,
      "author": {
        "id": 1250573
      },
      "writtenOn": "2022-03-30T23:02:54Z",
      "side": 1,
      "message": "\u003e That\u0027s what I tried to do first, but I was thinking with this simpler approach we don\u0027t really lose coverage ðŸ˜Š\n\nOh, I think I got a bit tricked by the comment below on line #332 saying \"2nd encrypted ZIP archive\".  The code here has 3 times repetition for a large number of lines, so a loop seems a good idea to me.\n\n\u003e ... first string finished with \".zip\", and return it. But this already seemed fragile compared to the regex approach.\n\nRight, what you\u0027re saying is that there is no good way to identify the file name in the dialog other than searching for the string we expect, is that?\n\n\u003e The idea was then to have an array to keep track of the \"remaining zip files names\" for which we expect a password dialog.\n\u003e But then working with arrays is pretty hard in go... we have to manually implement the \"contains\" function, the \"remove element\" etc...\n\nYes, I looked it up the other day and found a bit weird that golang doesn\u0027t give a simple way to do that. One recommendation I found was to use map where the key is the file name and the value is a boolean which could work without much effort here.",
      "parentUuid": "3f1094d7_964bf895",
      "range": {
        "startLine": 311,
        "startChar": 44,
        "endLine": 311,
        "endChar": 50
      },
      "revId": "2a9b23583ca389c7ea09dab3faf5c4500af024f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7b1fc04_5e3e72f9",
        "filename": "src/chromiumos/tast/local/bundles/cros/filemanager/zip_mount.go",
        "patchSetId": 2
      },
      "lineNbr": 332,
      "author": {
        "id": 1250573
      },
      "writtenOn": "2022-03-30T23:02:54Z",
      "side": 1,
      "message": "nit: Is this the 2nd file or the 3rd?\n\nMaybe that\u0027s what\u0027s confusing me.",
      "range": {
        "startLine": 332,
        "startChar": 53,
        "endLine": 332,
        "endChar": 59
      },
      "revId": "2a9b23583ca389c7ea09dab3faf5c4500af024f1",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}