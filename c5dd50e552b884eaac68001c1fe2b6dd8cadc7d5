{
  "comments": [
    {
      "key": {
        "uuid": "9e896049_99e6270d",
        "filename": "src/chromiumos/tast/common/perf/timeline.go",
        "patchSetId": 8
      },
      "lineNbr": 180,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-25T09:52:45Z",
      "side": 1,
      "message": "I\u0027m afraid this computation is wrong.\n\nLet\u0027s say the interval is 10s, snapshot() always takes 3s, and the clock starts from 0s.\n\nThe first iteration:\n\n clock \u003d 0, previousTime \u003d 0\n sleepTime :\u003d 10 - (0 - 0) \u003d 10\n previousTime \u003d 0 + 10 \u003d 10\n \u003d\u003e sleeps for 10s and takes a snapshot for 3s\n\nThe second iteration:\n\n clock \u003d 13, previousTime \u003d 10\n sleepTime :\u003d 10 - (13 - 10) \u003d 7\n previousTime \u003d 13 + 10 \u003d 23\n \u003d\u003e sleeps for 7s and takes a snapshot for 3s\n\nThe third iteration:\n\n clock \u003d 23, previousTime \u003d 23\n sleepTime :\u003d 10 - (23 - 23) \u003d 10\n previousTime \u003d 23 + 10 \u003d 33\n \u003d\u003e sleeps for 10s (wrong!)\n\n\n\nKeeping track of the *next* time to take a snapshot might make the logic simpler, e.g.\n\n nextTime :\u003d t.clock.Now().Add(t.interval)\n for {\n   sleepTime :\u003d nextTime.Sub(t.clock.Now()) // how long do we sleep?\n   if sleepTime \u003c 0 { err... }\n   nextTime \u003d nextTime.Add(t.interval) // we want to take a snapshot in a regular interval\n   ...\n }",
      "range": {
        "startLine": 179,
        "startChar": 0,
        "endLine": 180,
        "endChar": 47
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3808ad52_3d9962b2",
        "filename": "src/chromiumos/tast/common/perf/timeline.go",
        "patchSetId": 8
      },
      "lineNbr": 180,
      "author": {
        "id": 1375928
      },
      "writtenOn": "2020-05-26T03:39:17Z",
      "side": 1,
      "message": "Good catch",
      "parentUuid": "9e896049_99e6270d",
      "range": {
        "startLine": 179,
        "startChar": 0,
        "endLine": 180,
        "endChar": 47
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5203c9b5_5f32495b",
        "filename": "src/chromiumos/tast/common/perf/timeline.go",
        "patchSetId": 8
      },
      "lineNbr": 182,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-25T09:52:45Z",
      "side": 1,
      "message": "nit: %v formats time.Duration in a clean way, e.g. 5s.",
      "range": {
        "startLine": 182,
        "startChar": 65,
        "endLine": 182,
        "endChar": 80
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58d41b8f_e415075d",
        "filename": "src/chromiumos/tast/common/perf/timeline.go",
        "patchSetId": 8
      },
      "lineNbr": 182,
      "author": {
        "id": 1375928
      },
      "writtenOn": "2020-05-26T03:39:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5203c9b5_5f32495b",
      "range": {
        "startLine": 182,
        "startChar": 65,
        "endLine": 182,
        "endChar": 80
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a65a3aec_b7c02300",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 75,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-25T09:52:45Z",
      "side": 1,
      "message": "For deterministic tests, it is rare that a test expectation is A or B. So I recommend making this method to handle only the case where a snapshot is taken, and report an error when it\u0027s not the case.\n\n func (d *testTimelineDatasource) WaitForSnapshot() {\n   // Wait for Snapshot to be called.\n   // If it is not called for 5 seconds, panic.\n }",
      "range": {
        "startLine": 75,
        "startChar": 44,
        "endLine": 75,
        "endChar": 62
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d071abf6_324ef6ab",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 75,
      "author": {
        "id": 1375928
      },
      "writtenOn": "2020-05-26T03:39:17Z",
      "side": 1,
      "message": "Done. Created a second function `WaitForSnapshottingDone`. Some tests wait for the snapshotting goroutine to return by itself.",
      "parentUuid": "a65a3aec_b7c02300",
      "range": {
        "startLine": 75,
        "startChar": 44,
        "endLine": 75,
        "endChar": 62
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc3f059b_57c7ceac",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 96,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-25T09:52:45Z",
      "side": 1,
      "message": "Let\u0027s initialize clock with a fixed time, e.g. time.Unix(0, 0), to keep the test deterministic.",
      "range": {
        "startLine": 96,
        "startChar": 26,
        "endLine": 96,
        "endChar": 35
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cfd55b03_ac6ae3ba",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 96,
      "author": {
        "id": 1375928
      },
      "writtenOn": "2020-05-26T03:39:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fc3f059b_57c7ceac",
      "range": {
        "startLine": 96,
        "startChar": 26,
        "endLine": 96,
        "endChar": 35
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "93c8f1e0_5ec3f945",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 132,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-25T09:52:45Z",
      "side": 1,
      "message": "Using a weighted semaphore is an interesting idea, but this edge case seems to suggest that it\u0027s not a best fit. In particular, with a weighted semaphore, we end up managing the \"current\" clock in two fields, c.clock and c.sem. And here they go out of sync.\n\nI rather recommend the approach I mentioned earlier, that is, to manage the current clock in c.clock only and use sync.Mutex and channels to wait for the value change.",
      "range": {
        "startLine": 128,
        "startChar": 0,
        "endLine": 132,
        "endChar": 28
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6001bac0_1100f5cd",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 132,
      "author": {
        "id": 1375928
      },
      "writtenOn": "2020-05-26T03:39:17Z",
      "side": 1,
      "message": "I managed to remove this edge case. It is sufficient to create a new semaphore at the beginning of each Sleep(). Is this better?\n\nI am trying to avoid the sync.Mutex solution because it would further increase the complexity this CL. semaphore.Weighted does essentially the same thing (also implemented with channels and a mutex), but its complexity is hidden behind a high-level interface.",
      "parentUuid": "93c8f1e0_5ec3f945",
      "range": {
        "startLine": 128,
        "startChar": 0,
        "endLine": 132,
        "endChar": 28
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d217b37e_300dd641",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 132,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-29T09:22:17Z",
      "side": 1,
      "message": "It\u0027s slightly better, but still we manage the clock in two fields.\n\nAlso another reason I recommend using mutex explicitly in fakeClock is to design it goroutine-safe (~\u003d thread-safe). The current implementation of Timeline would not call fakeClock\u0027s methods concurrently so fakeClock would work even if it\u0027s not goroutine-safe. But unit tests using fakeClock will be run for future changes to Timeline, and if they fail to meet the concurrency requirements, things would fail in mysterious way due to data races. For a trivial example, currently snapshots are taken sequentially, but if we decide to do it in parallel, tests will fail in a weird way. Building a reliable tool for faking the clock would be very helpful in such situation.\n\nI think my general comment is that I recommend designing fakeClock as a reusable component that does not make any assumption about how it is used. Unit tests using fakeClock will evolve later. If fakeClock has some implicit assumptions, engineers who will modify this component will have hard time updating unit tests.",
      "parentUuid": "6001bac0_1100f5cd",
      "range": {
        "startLine": 128,
        "startChar": 0,
        "endLine": 132,
        "endChar": 28
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ae1ab0ad_5132e30d",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-25T09:52:45Z",
      "side": 1,
      "message": "For this change, it is important to check that the goroutine slept for an expected amount of time. Can we check it by changing this method to return the duration passed to Sleep, i.e.\n\n func (c *fakeClock) WaitForSleep() time.Duration",
      "range": {
        "startLine": 141,
        "startChar": 0,
        "endLine": 141,
        "endChar": 47
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4308d7bf_1ca06d28",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1375928
      },
      "writtenOn": "2020-05-26T03:39:17Z",
      "side": 1,
      "message": "I am not sure what to return here and what to do with the return value. We advance the clock in the tests, so the tests determine the sleep time. I could check for the requested sleep duration...\n\nOne nice thing (even though not needed right now) is that this function (and the other WaitFor* functions) works properly even if called from multiple goroutines. If this function returns the time duration, it would have to be passed through a channel, making this property harder to ensure.",
      "parentUuid": "ae1ab0ad_5132e30d",
      "range": {
        "startLine": 141,
        "startChar": 0,
        "endLine": 141,
        "endChar": 47
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "676001aa_22c15355",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 141,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-29T09:22:17Z",
      "side": 1,
      "message": "As long as we can test the new behavior (i.e. to reduce sleep duration by the time taken to snapshot) it is fine.\n\nI\u0027m not sure if it is useful to allow calling Wait* concurrently though. In any case Sleep cannot be called concurrently due to usage of weighted semaphore, so there is likely 1:1 mapping between the testee goroutine and tester goroutine.",
      "parentUuid": "4308d7bf_1ca06d28",
      "range": {
        "startLine": 141,
        "startChar": 0,
        "endLine": 141,
        "endChar": 47
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a15afe7_fe4e9855",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 145,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-25T09:52:45Z",
      "side": 1,
      "message": "Similarly to WaitForSnapshot, let us make this method to return only when Sleep is called.",
      "range": {
        "startLine": 144,
        "startChar": 0,
        "endLine": 145,
        "endChar": 26
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a663aba0_b32f33e8",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 8
      },
      "lineNbr": 145,
      "author": {
        "id": 1375928
      },
      "writtenOn": "2020-05-26T03:39:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9a15afe7_fe4e9855",
      "range": {
        "startLine": 144,
        "startChar": 0,
        "endLine": 145,
        "endChar": 26
      },
      "revId": "c5dd50e552b884eaac68001c1fe2b6dd8cadc7d5",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}