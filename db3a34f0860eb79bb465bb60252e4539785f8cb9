{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5f4d3599_64ac64b3",
        "filename": "src/chromiumos/tast/remote/wificell/router.go",
        "patchSetId": 2
      },
      "lineNbr": 182,
      "author": {
        "id": 1487074
      },
      "writtenOn": "2021-05-11T07:39:25Z",
      "side": 1,
      "message": "I kind of prefer having a New function for each \"struct\" here. The NewRouter will be much cleaner this way:\n\n  func NewRouter(ctx, dCtx context.Context, host *ssh.Conn, name string, rtype RouterType) (SuperRouter, error) {\n    switch rtype {\n    case legacy:\n      return newLegacyRouter(ctx, dCtx, host, name)\n    case openWrt:\n      return newOpenWrtRouter(ctx, dCtx, host, name)\n    default:\n      reutrn nil, errors.New(...)\n    }\n  }\n\nAlso, this allows all codes of a struct to be placed together. e.g. legacyRouterStruct\u0027s methods, definition, and constructor can be all in legacy_router.go",
      "revId": "db3a34f0860eb79bb465bb60252e4539785f8cb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "00b8164c_f7ef4a38",
        "filename": "src/chromiumos/tast/remote/wificell/router.go",
        "patchSetId": 2
      },
      "lineNbr": 182,
      "author": {
        "id": 1432127
      },
      "writtenOn": "2021-05-12T09:11:10Z",
      "side": 1,
      "message": "I like this approach. Done",
      "parentUuid": "5f4d3599_64ac64b3",
      "revId": "db3a34f0860eb79bb465bb60252e4539785f8cb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ce5ada7_bedb08ed",
        "filename": "src/chromiumos/tast/remote/wificell/test_fixture.go",
        "patchSetId": 2
      },
      "lineNbr": 387,
      "author": {
        "id": 1487074
      },
      "writtenOn": "2021-05-11T07:39:25Z",
      "side": 1,
      "message": "I think this type assertion will never fail as supportLogs is one indirect member of SuperRouter. This make me feel confused about how SuperRouter would be used.\n\nMy initial thought is that this interface would be implemented by a wrapper like:\n\n  type routerWrap {\n    base baseRouter\n  }\n\n  func (r *routerWrap) A() error {\n    if a, ok :\u003d r.base.(supportA) {\n      return a.A()\n    }\n    return errors.New(\"router doesn\u0027t support A\")\n  }\n\nThen, the support check can be kept in a structure and will not spread in tests/TestFixture. However, that guess doesn\u0027t match the code here...\n\n(btw, the design above still comes with a downside that it is unclear to the caller whether a call might possibly fail with \"not support\")\n\nIf you only need an interface to contain all routers, probably baseRouter is more suitable? and then, caller can/should check if a function is supported with type assertion.",
      "revId": "db3a34f0860eb79bb465bb60252e4539785f8cb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfdb1b1a_7fdcdb35",
        "filename": "src/chromiumos/tast/remote/wificell/test_fixture.go",
        "patchSetId": 2
      },
      "lineNbr": 387,
      "author": {
        "id": 1432127
      },
      "writtenOn": "2021-05-12T09:11:10Z",
      "side": 1,
      "message": "Hi Yenlin, I realized modeled after the golang optional method design pattern incorrectly. I am supposed to use a loosely defined interface (BaseRouter) and check to see if the object happens to implement other behavior similar to what you suggested.\n\nI have since rectified the pattern by using a base class and checking whether the object that uses the baseclass actually implements other behavior.\n\ne.g \n```\n// Router is of BaseRouter implementation\nr, ok :\u003d router.(supportHostapd)\nif !ok {\n    return errors.Error(\"router doesn\u0027t support hostapd\")\n}\nr.StartHostapd(...)\n...\n```\n\nThis way i force asserts of the supported interface.\n\nIn this particular case with the new scheme, I will need the assert because someone can invoke tf.CollectLogs with a router that doesn\u0027t support log collection.\n\nIn order to prevent checking behavior on every test that uses tf.Router, I added getters GetLegacyRouter() so that the test itself doesn\u0027t need to check as the assert has already been made.\n\nLet me know what you think of this strategy.",
      "parentUuid": "7ce5ada7_bedb08ed",
      "revId": "db3a34f0860eb79bb465bb60252e4539785f8cb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2313812d_a4565714",
        "filename": "src/chromiumos/tast/remote/wificell/test_fixture.go",
        "patchSetId": 2
      },
      "lineNbr": 387,
      "author": {
        "id": 1487074
      },
      "writtenOn": "2021-05-12T11:37:44Z",
      "side": 1,
      "message": "Ah, OK, so SuperRouter is not needed. I think the concept sounds good to me. This is what I had in mind when I first saw multiple supportXXX interfaces, but I was later confused by the SuperRouter. :p\n\nI think the current code have a lot of assumption on the \"legacy\" type, so I guess we might have a lot of type assertion. +another comment in GetLegacyRouter, I think it might be kind of messy for now. Maybe we can reduce that gradually by refactoring some of the methods/interfaces, when we have more knowledge about AX router and openWrt.\n\n(Mark resolved)",
      "parentUuid": "dfdb1b1a_7fdcdb35",
      "revId": "db3a34f0860eb79bb465bb60252e4539785f8cb9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}