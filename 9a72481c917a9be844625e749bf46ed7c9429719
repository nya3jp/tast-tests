{
  "comments": [
    {
      "key": {
        "uuid": "b9d2e629_2cdc3c70",
        "filename": "src/chromiumos/tast/local/ui/filesapp/filesapp.go",
        "patchSetId": 11
      },
      "lineNbr": 45,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-08-12T15:26:19Z",
      "side": 1,
      "message": "nit: could you use \"resolve\" for consistency?\n\ntast.promisify can make this a bit simpler.\n\n\"tast.promisify(chrome.autotestPrivate.launchApp)(%q)\"",
      "range": {
        "startLine": 45,
        "startChar": 42,
        "endLine": 45,
        "endChar": 53
      },
      "revId": "9a72481c917a9be844625e749bf46ed7c9429719",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "247fdb93_99052436",
        "filename": "src/chromiumos/tast/local/ui/filesapp/filesapp.go",
        "patchSetId": 11
      },
      "lineNbr": 45,
      "author": {
        "id": 1358595
      },
      "writtenOn": "2019-08-12T18:19:44Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b9d2e629_2cdc3c70",
      "range": {
        "startLine": 45,
        "startChar": 42,
        "endLine": 45,
        "endChar": 53
      },
      "revId": "9a72481c917a9be844625e749bf46ed7c9429719",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b5351d6a_0b261f8b",
        "filename": "src/chromiumos/tast/local/ui/filesapp/filesapp.go",
        "patchSetId": 11
      },
      "lineNbr": 56,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-08-12T15:26:19Z",
      "side": 1,
      "message": "nit/optional: Go prefers shorter name in general. How about \"OpenDownloads\"?",
      "range": {
        "startLine": 56,
        "startChar": 3,
        "endLine": 56,
        "endChar": 22
      },
      "revId": "9a72481c917a9be844625e749bf46ed7c9429719",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a91362ac_f72d4759",
        "filename": "src/chromiumos/tast/local/ui/filesapp/filesapp.go",
        "patchSetId": 11
      },
      "lineNbr": 56,
      "author": {
        "id": 1358595
      },
      "writtenOn": "2019-08-12T18:19:44Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b5351d6a_0b261f8b",
      "range": {
        "startLine": 56,
        "startChar": 3,
        "endLine": 56,
        "endChar": 22
      },
      "revId": "9a72481c917a9be844625e749bf46ed7c9429719",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8e3546aa_440bf290",
        "filename": "src/chromiumos/tast/local/ui/filesapp/filesapp.go",
        "patchSetId": 11
      },
      "lineNbr": 103,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-08-12T15:26:19Z",
      "side": 1,
      "message": "Declaring the variable in the context looks confusing.\nSpecifically, this method is called multiple times, in second or later call the variable won\u0027t be declared but just reused.\n\nCould you just inline the JavaScript code? E.g.\n\ntast.promisify(chrome.automation.getDesktop)().then((root) \u003d\u003e root.find({attributes: {role: %q, name: %q}}))\n\nfor WaitForElement. Same for others.",
      "range": {
        "startLine": 103,
        "startChar": 15,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "9a72481c917a9be844625e749bf46ed7c9429719",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "af78d7ac_ed0af677",
        "filename": "src/chromiumos/tast/local/ui/filesapp/filesapp.go",
        "patchSetId": 11
      },
      "lineNbr": 103,
      "author": {
        "id": 1358595
      },
      "writtenOn": "2019-08-12T18:19:44Z",
      "side": 1,
      "message": "Your solution would work for ClickElement, but would not work for WaitForElement. It would only work for WaitForElement if Conn.go is modified to support waiting repeatedly on a promise until its result is true. If the elemens that is being waited for does not exist yet, a null will be returned. We want to keep polling until either the timeout is hit, or the value is not null.\n\nWould repeatedly re-executing a promise be the preferred method?\n\nAlso, I can change this to \"var root \u003d null;...\" to ensure it is recreating root each time.",
      "parentUuid": "8e3546aa_440bf290",
      "range": {
        "startLine": 103,
        "startChar": 15,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "9a72481c917a9be844625e749bf46ed7c9429719",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51112b70_991b9386",
        "filename": "src/chromiumos/tast/local/ui/filesapp/filesapp.go",
        "patchSetId": 11
      },
      "lineNbr": 103,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-08-13T16:44:06Z",
      "side": 1,
      "message": "Oh I see. Does event listener work for your case to wait for the change?\n\nE.g. something like;\nEvalPromise(...,\n`async () \u003d\u003e {\n  let root \u003d await tast.promisify(chrome.automation.getDesktop)();\n  let node \u003d root.find({attributes: ...});\n  if (!!node) {\n    return;\n  }\n  var callback \u003d (treeChanged) \u003d\u003e {\n    var node \u003d treeChanged.target;\n    if (node.root \u003d\u003d root \u0026\u0026 node.role \u003d\u003d role \u0026\u0026 node.name \u003d\u003d name) {\n      chrome.automation.removeTreeChangeObserver(callback);\n      resolve();\n      return;\n    }\n  }\n  chrome.automation.addTreeChangeObserver(..., callback);\n}()`\n\nWDYT?\nI\u0027m still concerning to leak the variable from a method.",
      "parentUuid": "af78d7ac_ed0af677",
      "range": {
        "startLine": 103,
        "startChar": 15,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "9a72481c917a9be844625e749bf46ed7c9429719",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f05a01a7_93ab0c9d",
        "filename": "src/chromiumos/tast/local/ui/filesapp/filesapp.go",
        "patchSetId": 11
      },
      "lineNbr": 103,
      "author": {
        "id": 1358595
      },
      "writtenOn": "2019-08-13T19:44:14Z",
      "side": 1,
      "message": "That type of solution almost works, but it introduces a race condition. After searching for the node and before adding the tree change observer the node may change.\n\nI upload what I think is an acceptable solution. It doesn\u0027t leak root and it is basically the same functionality of waiting that conn.waitforexpr has.",
      "parentUuid": "51112b70_991b9386",
      "range": {
        "startLine": 103,
        "startChar": 15,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "9a72481c917a9be844625e749bf46ed7c9429719",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ca4ebc9_81de6ac6",
        "filename": "src/chromiumos/tast/local/ui/filesapp/filesapp.go",
        "patchSetId": 11
      },
      "lineNbr": 103,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-08-14T09:03:25Z",
      "side": 1,
      "message": "\u003e That type of solution almost works, but it introduces a race condition. After searching for the node and before adding the tree change observer the node may change.\n\nCould you share a reference about the timing? I couldn\u0027t find a detailed document.\nIIUC, JavaScript world runs as on a single-thread. So, I was thinking, if a node is being added between root.find() and chrome.automation.addTreeChangeObserver(), the registered callback will be called in the next cycle...?",
      "parentUuid": "f05a01a7_93ab0c9d",
      "range": {
        "startLine": 103,
        "startChar": 15,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "9a72481c917a9be844625e749bf46ed7c9429719",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "392fc933_29557751",
        "filename": "src/chromiumos/tast/local/ui/filesapp/filesapp.go",
        "patchSetId": 11
      },
      "lineNbr": 103,
      "author": {
        "id": 1358595
      },
      "writtenOn": "2019-08-14T17:15:29Z",
      "side": 1,
      "message": "I initially implemented the it with the code below. It is quite similar to what you wrote above. This code sometimes passes and sometimes fails. That is why I assumed a timing issue and race condition. Maybe I am missing something, but that is what it seems like to me.\n\nfindQuery :\u003d fmt.Sprintf(\n`(async () \u003d\u003e {\n    let root \u003d await tast.promisify(chrome.automation.getDesktop)();\n    let node \u003d root.find({attributes: {role: %[1]q, name: %[2]q}});\n    if (!!node) {\n        return;\n    }\n    await new Promise((resolve) \u003d\u003e {\n        let callback \u003d (treeChanged) \u003d\u003e {\n            let node \u003d treeChanged.target;\n            if (node.role \u003d\u003d %[1]q \u0026\u0026 node.name \u003d\u003d %[2]q) {\n                chrome.automation.removeTreeChangeObserver(callback);\n                resolve();\n            }\n        };\n        chrome.automation.addTreeChangeObserver(\"allTreeChanges\", callback);\n    });\n})()`, role, name)",
      "parentUuid": "3ca4ebc9_81de6ac6",
      "range": {
        "startLine": 103,
        "startChar": 15,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "9a72481c917a9be844625e749bf46ed7c9429719",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}