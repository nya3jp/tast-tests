{
  "comments": [
    {
      "key": {
        "uuid": "686599de_f37dbbb1",
        "filename": "src/chromiumos/tast/local/network/dhcp_packet.go",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 1238096
      },
      "writtenOn": "2019-10-17T00:37:50Z",
      "side": 1,
      "message": "In general, people really tries to minimize the use of interface{} as much as possible. But I don\u0027t see any immediate solution except changing all values to be []byte slices directly taken from the payload.\n\nGarrick might have some better idea.",
      "range": {
        "startLine": 18,
        "startChar": 6,
        "endLine": 18,
        "endChar": 17
      },
      "revId": "4c4603d0748a4f37700220a39dc2c6c0cd5195c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c76e915a_ce133e7e",
        "filename": "src/chromiumos/tast/local/network/dhcp_packet.go",
        "patchSetId": 1
      },
      "lineNbr": 18,
      "author": {
        "id": 1243287
      },
      "writtenOn": "2019-11-06T02:43:28Z",
      "side": 1,
      "message": "This is the best I could come up with. Will leave it this way unless anyone has better suggestions.",
      "parentUuid": "686599de_f37dbbb1",
      "range": {
        "startLine": 18,
        "startChar": 6,
        "endLine": 18,
        "endChar": 17
      },
      "revId": "4c4603d0748a4f37700220a39dc2c6c0cd5195c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2422d216_951dfba7",
        "filename": "src/chromiumos/tast/local/network/dhcp_packet.go",
        "patchSetId": 1
      },
      "lineNbr": 891,
      "author": {
        "id": 1238096
      },
      "writtenOn": "2019-10-17T00:37:50Z",
      "side": 1,
      "message": "Preferably this would return a []byte rather than a string.",
      "range": {
        "startLine": 890,
        "startChar": 0,
        "endLine": 891,
        "endChar": 55
      },
      "revId": "4c4603d0748a4f37700220a39dc2c6c0cd5195c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "33728674_1a7b06da",
        "filename": "src/chromiumos/tast/local/network/dhcp_packet.go",
        "patchSetId": 1
      },
      "lineNbr": 891,
      "author": {
        "id": 1243287
      },
      "writtenOn": "2019-11-06T02:43:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2422d216_951dfba7",
      "range": {
        "startLine": 890,
        "startChar": 0,
        "endLine": 891,
        "endChar": 55
      },
      "revId": "4c4603d0748a4f37700220a39dc2c6c0cd5195c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "989992d6_244c3cec",
        "filename": "src/chromiumos/tast/local/network/dhcp_packet.go",
        "patchSetId": 1
      },
      "lineNbr": 910,
      "author": {
        "id": 1238096
      },
      "writtenOn": "2019-10-17T00:37:50Z",
      "side": 1,
      "message": "Something more idiomatic in Go would be:\n\nfor ... {\n  var err error\n  data, err \u003d field.Pack(fieldValue)\n  if err !\u003d nil {\n    ...\n  }\n}\n\nwhere Pack uses append() on the slice and also adds the padding needed for alignment.\n\n\nBe careful about this Go trap: if you do \n\nvar data []string\nfor ... {\n  if data, err :\u003d field.Pack(fieldValue); err !\u003d nil {\n    return \"\", err\n  }\n}\n\nthen the data in the if expression is a different value than the outer data because of \":\u003d\" operator and no assignment actually happens outside the if.",
      "range": {
        "startLine": 902,
        "startChar": 0,
        "endLine": 910,
        "endChar": 32
      },
      "revId": "4c4603d0748a4f37700220a39dc2c6c0cd5195c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6959e779_b9572fe6",
        "filename": "src/chromiumos/tast/local/network/dhcp_packet.go",
        "patchSetId": 1
      },
      "lineNbr": 910,
      "author": {
        "id": 1243287
      },
      "writtenOn": "2019-11-06T02:43:28Z",
      "side": 1,
      "message": "Hmm, I\u0027m not so sure I agree with this. IMO, Pack() and Unpack() should be symmetrical, and it should be up to the caller to package and place the byte string however and wherever they want to. If you want, I can add some sort of helper/utility function to abstract it away from this function so that its a little more readable.",
      "parentUuid": "989992d6_244c3cec",
      "range": {
        "startLine": 902,
        "startChar": 0,
        "endLine": 910,
        "endChar": 32
      },
      "revId": "4c4603d0748a4f37700220a39dc2c6c0cd5195c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18ac3143_aed319f7",
        "filename": "src/chromiumos/tast/local/network/dhcp_packet.go",
        "patchSetId": 1
      },
      "lineNbr": 910,
      "author": {
        "id": 1238096
      },
      "writtenOn": "2019-11-15T01:50:21Z",
      "side": 1,
      "message": "Yeah keeping Pack() and Unpack() symmetrical is a good point.\n\nIn that case as discussed during our gvc sync, I suggest the following interface for Pack()/Unpack():\n\n\ntype interface Packable {\n  // Serializes the content of this object and append it to the input buffer.\n  // Also adds necessary padding and adds option header for dhcp option\n  Append([]byte bufer) []byte\n}\n\n// Retrieves the next field from the input buffer, and returns the Field value and buffer \n// aligned to the start of the next field/option.\nfunc ParseField([]byte buffer) (*Field, []byte) \n\nAlso, I suggest here not looping over DHCP_ALL_FIELDS, but over d.fields directly, so that you can write:\n\nfor _, fieldValues :\u003d range d.fields {\n  data \u003d fieldValue.pack(data)\n}\nfor _, optionValue :\u003d range d.options {\n  data \u003d optionValue.pack(data)\n}\n\nwhich should be possible as long as field values and option values implement Packable.\n\nNote that if the values know how to add padding, you don\u0027t need to maintain \u0027offset\u0027\n\n\nThe unpack loop would ned require a bit more investigation but I believe that the core of the option parsing loop should be able to fit ParseField(). For fixed fields, they should be retrieved in order and put directly into d.fields.",
      "parentUuid": "6959e779_b9572fe6",
      "range": {
        "startLine": 902,
        "startChar": 0,
        "endLine": 910,
        "endChar": 32
      },
      "revId": "4c4603d0748a4f37700220a39dc2c6c0cd5195c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9c3bdca_eed64803",
        "filename": "src/chromiumos/tast/local/network/dhcp_packet.go",
        "patchSetId": 1
      },
      "lineNbr": 910,
      "author": {
        "id": 1238096
      },
      "writtenOn": "2019-11-15T01:53:35Z",
      "side": 1,
      "message": "One remark for packing fields though. Order is critical, so d.fields would need to be changed into a vector. I think if you write pack that way you should be able to remove the FieldInterface anyway.\n\nHonestly the easiest looks to just put all the fields as normal struct field in DhcpPacket and not keep fields into a map. This only makes sense for options.",
      "parentUuid": "18ac3143_aed319f7",
      "range": {
        "startLine": 902,
        "startChar": 0,
        "endLine": 910,
        "endChar": 32
      },
      "revId": "4c4603d0748a4f37700220a39dc2c6c0cd5195c9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}