{
  "comments": [
    {
      "key": {
        "uuid": "740c6df0_798e45c4",
        "filename": "src/chromiumos/tast/local/bundles/cros/network/configure_service_for_profile.go",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-05-31T06:41:50Z",
      "side": 1,
      "message": "Could you handle error properly?",
      "revId": "e00c546825532a0477388dc20bf2a494a6ef6da6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50b7536f_42f9ba50",
        "filename": "src/chromiumos/tast/local/bundles/cros/network/configure_service_for_profile.go",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-05-31T06:41:50Z",
      "side": 1,
      "message": "Could you use syscall.Flock, instead (specifically at L43)?\nhttps://golang.org/pkg/syscall/#Flock",
      "range": {
        "startLine": 40,
        "startChar": 7,
        "endLine": 40,
        "endChar": 17
      },
      "revId": "e00c546825532a0477388dc20bf2a494a6ef6da6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e117be81_b8212eb6",
        "filename": "src/chromiumos/tast/local/bundles/cros/network/configure_service_for_profile.go",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-05-31T06:41:50Z",
      "side": 1,
      "message": "This code structure looks to have a several issues;\n- |f| is not closed.\n- ctx timeout is not awere during flock waiting.\n- Looks to have timing issue as follows;\nIn case of timeout (i.e., some another service holds a lock), flock(fd, LOCK_UN) is called during flock(fd, LOCK_SH), then the other service unlocks and this holds the lock.\nIn this situation, because Tast does not fork/exec per test case, the lock is held until the all the running test cases are completed.\n\nConsidering them, I\u0027d recommend to do whole the locking in a goroutine, and exchange the messages between main thread and the goroutine. E.g.;\n\nlockchan :\u003d make(chan error)  // channel to notify lock completion (or error) from the goroutine to the main thread.\ndone :\u003d make(chan struct{})  // channel to notify test completion from the main thread to goroutine.\n\ndefer close(done)  // Close the done channel at the end of the function so reading |done| in the goroutine handles it well.\ngo func() {\n  f, err :\u003d os.Create(lockPath)\n  if err !\u003d nil {\n    lockchan \u003c- err\n    return\n  }\n  defer f.Close()\n  if err \u003d syscall.Flock(f.Fd(), syscall.LOCK_SH); err !\u003d nil {\n    // Failed to take the flock.\n    lockchan \u003c- err\n    return\n  }\n  defer syscall.Flock(f.FD(), syscall.LOCK_UN)  // Ignore error. Or maybe logging?\n  \u003c- done  // Wait for the completion of the test scenario. Signaled when close(done) (in the defer above) is called (i.e., at the end of main thread).\n}()\n\nlctx :\u003d context.WithTimeout(ctx, 20 * time.Second)\nselect {\n  case err :\u003d \u003c- lockchan:\n    if err !\u003d nil {\n      s.Fatalf(...)\n    }\n  case \u003c- lctx.Done():\n    s.Fatalf(\"Timed out ... lock %s: %v\", lockPath, lctx.Err())\n}\n\nIn this approach, the FD will \"eventually\" be closed with releasing the lock.\nNote that, in case of time out, goroutine will be paused at LOCKSH for a while, and will take the lock when the other service releases the lock.\nHowever, the lock will be soon released at the end of the goroutine.",
      "revId": "e00c546825532a0477388dc20bf2a494a6ef6da6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc12df33_4a43eb33",
        "filename": "src/chromiumos/tast/local/bundles/cros/network/configure_service_for_profile.go",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1132414
      },
      "writtenOn": "2019-05-31T16:25:20Z",
      "side": 1,
      "message": "syscall package says:\n\n\"Deprecated: this package is locked down. Callers should use the corresponding package in the golang.org/x/sys repository instead.\"",
      "parentUuid": "50b7536f_42f9ba50",
      "range": {
        "startLine": 40,
        "startChar": 7,
        "endLine": 40,
        "endChar": 17
      },
      "revId": "e00c546825532a0477388dc20bf2a494a6ef6da6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c99e6af2_a86b00bc",
        "filename": "src/chromiumos/tast/local/bundles/cros/network/configure_service_for_profile.go",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1000042
      },
      "writtenOn": "2019-05-31T18:51:55Z",
      "side": 1,
      "message": "i\u0027m not sure how much it matters in practice, but yeah, i think that unix is getting updated and syscall isn\u0027t. iirc this is reflected by e.g. network-related constants that are defined in each",
      "parentUuid": "fc12df33_4a43eb33",
      "range": {
        "startLine": 40,
        "startChar": 7,
        "endLine": 40,
        "endChar": 17
      },
      "revId": "e00c546825532a0477388dc20bf2a494a6ef6da6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a4618ea_6e8f20f2",
        "filename": "src/chromiumos/tast/local/bundles/cros/network/configure_service_for_profile.go",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1132414
      },
      "writtenOn": "2019-06-01T00:56:57Z",
      "side": 1,
      "message": "Thanks for all the advice here. With some small variations (need to \u0027lockchan \u003c- nil\u0027 on successful lock, for one), I have this working. But I\u0027m finding it a bit fragile for trying to factor out into a library function, which I\u0027d like to do, since I expect there will be other tests that want this.\n\nThis made me rethink...how important is it to put a timeout on the Flock() operation? Does Tast enforce some other reasonable timeout that would catch us if for some odd reason this lock is held \"too long\" by some other process? Note that I don\u0027t have any real expected case for seeing this held very long (perhaps if we add bugs to \u0027check_ethernet.hook\u0027 such that it takes a long time on trying to \"recover\"), so this attempt at adding a timeout was just an abundance of precaution. I\u0027d also note that there\u0027s no such timeout for the flock usage in Autotest.\n\nEither way, I guess I\u0027ll upload what I have for now, but I may reconsider this next week.",
      "parentUuid": "e117be81_b8212eb6",
      "revId": "e00c546825532a0477388dc20bf2a494a6ef6da6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d20127b_759071be",
        "filename": "src/chromiumos/tast/local/bundles/cros/network/configure_service_for_profile.go",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-06-03T08:30:45Z",
      "side": 1,
      "message": "Thank you for the info. Filed a clean up issue: crbug.com/969615.",
      "parentUuid": "c99e6af2_a86b00bc",
      "range": {
        "startLine": 40,
        "startChar": 7,
        "endLine": 40,
        "endChar": 17
      },
      "revId": "e00c546825532a0477388dc20bf2a494a6ef6da6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ca402717_9a1bd394",
        "filename": "src/chromiumos/tast/local/bundles/cros/network/configure_service_for_profile.go",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-06-03T08:30:45Z",
      "side": 1,
      "message": "\u003e (need to \u0027lockchan \u003c- nil\u0027 on successful lock, for one)\n\noops, good catch :-)\n\nCould you elaborate what \"fragile\" do you mean here?\n\nAs for extracting as a function, it seems like one of the common patterns in golang, e.g.;\n\ntype EthernetLock struct {\n  done chan\u003c- struct{}\n}\n\nfunc Lock(ctx context.Context) (*EthernetLock, error) {\n\tlockchan :\u003d make(chan error) // To notify lock completion to main thread.\n\tdone :\u003d make(chan struct{})  // To notify main thread completion to the goroutine.\n        succeeded :\u003d false\n\tdefer func() {\n            if !succeeded {\n                close(done)            // Notify thread at end of test.\n            }\n        }()\n\n\tgo func() {\n\t\t... as you wrote ...\n\t}()\n\n\tlctx, cancel :\u003d context.WithTimeout(ctx, 20*time.Second)\n\tdefer cancel()\n\tselect {\n\tcase err :\u003d \u003c-lockchan:\n\t\tif err !\u003d nil {\n\t\t\treturn nil, errors.wrapf(err, \"...some details...\")\n\t\t}\n\tcase \u003c-lctx.Done():\n\t\treturn nil, errors.wrapf(lctx.Err(), \"...some details...\")\n\t}\n\n\tsucceeded \u003d true\n\treturn \u0026EthernetLock{ done }, nil\n}\n\nfunc (e *EthernetLock) Unlock() {\n\tclose(e.done)\n}\n\n\nin caller (test scenario);\n\n...\nlock, err :\u003d Lock(ctx)\nif err !\u003d nil {\n   ...\n}\ndefer lock.Unlock()\n\nWDYT?\n\n\n\n\u003e  Does Tast enforce some other reasonable timeout that would catch us if for some odd reason this lock is held \"too long\" by some other process? \n\nin general, \"interrupting\" the operation is very difficult in programming.\nIn Tast, we rely on context for timeout.\n\n\u003e Note that I don\u0027t have any real expected case for seeing this held very long (perhaps if we add bugs to \u0027check_ethernet.hook\u0027 such that it takes a long time on trying to \"recover\"),\n\nThat\u0027s actually what I\u0027m worrying about.\nIn case of the situation, it would affect to other tests without timeout, that\u0027d be avoided.\n\n\u003e I\u0027d also note that there\u0027s no such timeout for the flock usage in Autotest.\n\nIn autotest, we know that it sometimes behaves mysteriously, which Tast would not like to have.\n\nI hope the above extraction approach satisfies you,\nand thank you for your cooperation to keep the test running in a good state as much as possible in advance.",
      "parentUuid": "0a4618ea_6e8f20f2",
      "revId": "e00c546825532a0477388dc20bf2a494a6ef6da6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5314fb01_efb0eca7",
        "filename": "src/chromiumos/tast/local/bundles/cros/network/configure_service_for_profile.go",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1132414
      },
      "writtenOn": "2019-06-03T18:49:19Z",
      "side": 1,
      "message": "\u003e Could you elaborate what \"fragile\" do you mean here?\n\nI think I was stuck on this part of your explanation:\n\n\"Note that, in case of time out, goroutine will be paused at LOCKSH for a while, and will take the lock when the other service releases the lock.\nHowever, the lock will be soon released at the end of the goroutine.\"\n\nI think I got it in my head that our own attempts to LOCK_UN were supposed to be freeing the goroutine up to continue, and that sounded inherently racy. But that\u0027s not true (I think I was partially misunderstanding the semantics of flock(), as well as): the only way we end up unblocking ourselves is by closing the file descriptor, which *can* be done safely.\n\nI think I also was getting a little stuck on when to \u0027defer\u0027 stuff vs. direct error handling. Your example helped a bit.\n\n\u003e As for extracting as a function, it seems like one of the common patterns in golang, e.g.;\n\u003e \n\u003e type EthernetLock struct {\n\u003e   done chan\u003c- struct{}\n\u003e }\n...\n\u003e lock, err :\u003d Lock(ctx)\n\u003e if err !\u003d nil {\n\u003e    ...\n\u003e }\n\u003e defer lock.Unlock()\n\u003e \n\u003e WDYT?\n\nThanks for writing that out! I think I had something similar in mind (I actually don\u0027t think we really need to return the \u0027struct\u0027 at all -- can\u0027t I just return a Closure directly?). With my above (mis)understandings cleared up, I think this is doable.\n\n\u003e In autotest, we know that it sometimes behaves mysteriously, which Tast would not like to have.\n\nI can agree there ;)\n\n\u003e I hope the above extraction approach satisfies you,\n\u003e and thank you for your cooperation to keep the test running in a good state as much as possible in advance.\n\nYep, thanks for the help. I\u0027ll respin with the timeout intact.",
      "parentUuid": "ca402717_9a1bd394",
      "revId": "e00c546825532a0477388dc20bf2a494a6ef6da6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ae366e5_49247f08",
        "filename": "src/chromiumos/tast/local/bundles/cros/network/configure_service_for_profile.go",
        "patchSetId": 3
      },
      "lineNbr": 40,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-06-04T01:10:18Z",
      "side": 1,
      "message": "\u003e I think I also was getting a little stuck on when to \u0027defer\u0027 stuff vs. direct error handling. Your example helped a bit.\n\nGlad to hear that mine helped you :-).\n\n\n\u003e (I actually don\u0027t think we really need to return the \u0027struct\u0027 at all -- can\u0027t I just return a Closure directly?)\n\nI\u0027m fine with closure. (Note: I\u0027d use struct specifically if it could be extended in future, but I\u0027m not very sure in this case).",
      "parentUuid": "5314fb01_efb0eca7",
      "revId": "e00c546825532a0477388dc20bf2a494a6ef6da6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}