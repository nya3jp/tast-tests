package main

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"
)

const (
	// Type names of generated constants.
	etType   = "EventType"
	ecType   = "EventCode"
	propType = "DeviceProperty"

	header = `// Copyright 2018 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package input

// Code generated by gen/gen_constants.go. DO NOT EDIT.
//
// Do not change the above line; see https://golang.org/pkg/cmd/go/internal/generate/
//
// This file contains constants from {{.InputPath}}
// in the Linux kernel at revision {{.Revision}}.
// Run "go generate" to regenerate it.

// {{.ETType}} corresponds to the "type" field in the input_event C struct.
// Per the kernel documentation, "event types are groupings of codes under a logical input construct."
// Stated more plainly, event types represent broad categories like "keyboard events".
type {{.ETType}} uint16

// {{.ECType}} corresponds to the "code" field in the input_event C struct.
// Per the kernel documentation, "event codes define the precise type of event."
// There are codes corresponding to different keys on a keyboard or different mouse buttons, for example.
type {{.ECType}} uint16

// {{.PropType}} describes additional information about an input device beyond
// the event types that it supports.
type {{.PropType}} uint16

const (
`
	footer = ")\n"
)

// groupInfo describes a group of constants.
type groupInfo struct {
	prefix   string // constant prefix, e.g. "EV" for "EV_SYN" or "INPUT_PROP" for "INPUT_PROP_DIRECT"
	typeName string // constant type name, e.g. "EventType"
	desc     string // human-readable group description used in comment
}

// These are documented at https://www.kernel.org/doc/Documentation/input/event-codes.txt.
var groups []*groupInfo = []*groupInfo{
	&groupInfo{"EV", etType, "Event types"},
	&groupInfo{"SYN", ecType, "Synchronization events"},
	&groupInfo{"KEY", ecType, "Keyboard events"},
	&groupInfo{"BTN", ecType, "Momentary switch events"},
	&groupInfo{"REL", ecType, "Relative change events"},
	&groupInfo{"ABS", ecType, "Absolute change events"},
	&groupInfo{"SW", ecType, "Stateful binary switch events"},
	&groupInfo{"MSC", ecType, "Miscellaneous input and output events"},
	&groupInfo{"LED", ecType, "LED events"},
	&groupInfo{"SND", ecType, "Commands to simple sound output devices"},
	&groupInfo{"REP", ecType, "Autorepeat events"},
	&groupInfo{"INPUT_PROP", propType, "Device properties"},
}

// getGroupForName returns group info for the supplied constant.
func getGroupForName(name string) *groupInfo {
	for _, g := range groups {
		if strings.HasPrefix(name, g.prefix) {
			return g
		}
	}
	return nil
}

// getRepoInfo returns path's location relative to its git repository and the HEAD revision for the repository.
func getRepoInfo(path string) (relPath, rev string, err error) {
	if path, err = filepath.Abs(path); err != nil {
		return "", "", err
	}
	path = filepath.Clean(path)

	// This prints the base path of the repo on the first line and HEAD's revision on the second.
	cmd := exec.Command("git", "rev-parse", "--show-toplevel", "HEAD")
	cmd.Dir = filepath.Dir(path)
	out, err := cmd.Output()
	if err != nil {
		return "", "", err
	}

	lines := strings.Split(strings.TrimSpace(string(out)), "\n")
	if len(lines) != 2 {
		return "", "", fmt.Errorf("%q printed %q; wanted 2 lines", strings.Join(cmd.Args, " "), string(out))
	}
	rev = lines[1]
	if relPath, err = filepath.Rel(lines[0], path); err != nil {
		return "", "", err
	}
	return relPath, rev, nil
}

// constant describes an individual constant.
type constant struct {
	name string // name from the header, e.g. "EV_SYN"
	val  int64  // parsed value from the header
}

// constantGroups is a map from a group name (e.g. "EV" or "KEY") to the corresponding constants.
type constantGroups map[string][]constant

// readConstants reads path, a kernel input-event-codes.h file, and returns a subset of relevant constants from it.
func readConstants(path string) (constantGroups, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	consts := make(constantGroups)
	re := regexp.MustCompile(`^#define\s+([A-Z][_A-Z0-9]+)\s+(0x[0-9a-fA-F]+|\d+)`)
	sc := bufio.NewScanner(f)
	for sc.Scan() {
		matches := re.FindStringSubmatch(sc.Text())
		if matches == nil {
			continue
		}
		name, sval := matches[1], matches[2]
		grp := getGroupForName(name)
		if grp == nil {
			return nil, fmt.Errorf("unable to classify %q", name)
		} else if name == grp.prefix+"_MAX" {
			continue
		}

		base := 10
		if len(sval) > 2 && sval[:2] == "0x" {
			base = 16
			sval = sval[2:] // strconv.ParseInt doesn't want "0x" prefix
		}
		var val int64
		if val, err = strconv.ParseInt(sval, base, 64); err != nil {
			return nil, fmt.Errorf("unable to parse value %q for %q: %v", sval, name, err)
		}
		consts[grp.prefix] = append(consts[grp.prefix], constant{name, val})
	}

	// Sort each group by ascending value.
	for _, cs := range consts {
		sort.Slice(cs, func(i, j int) bool { return cs[i].val < cs[j].val })
	}

	return consts, sc.Err()
}

// writeConstants writes consts to path as a Go source file.
// repoPath contains the source file's path relative to its repository and repoRev
// contains the current revision of the repository; both are included in a comment.
func writeConstants(consts constantGroups, repoPath, repoRev, path string) error {
	f, err := ioutil.TempFile(filepath.Dir(path), "."+filepath.Base(path)+".")
	if err != nil {
		return err
	}
	// Manually close below instead of using defer since we need to rename the temp file.

	tmpl := template.Must(template.New("header").Parse(header))
	data := struct {
		InputPath, Revision, ETType, ECType, PropType string
	}{repoPath, repoRev, etType, ecType, propType}
	if err := tmpl.Execute(f, data); err != nil {
		f.Close()
		return err
	}

	// Checking that each write succeeds is tedious.
	// This wrapper saves the first error and does no-ops afterwards.
	var werr error
	write := func(s string) {
		if werr == nil {
			_, werr = io.WriteString(f, s)
		}
	}
	for i, grp := range groups {
		write(fmt.Sprintf("\t// %s\n", grp.desc))
		for _, c := range consts[grp.prefix] {
			write(fmt.Sprintf("\t%s %s = %#x\n", c.name, grp.typeName, c.val))
		}
		if i < len(groups)-1 {
			write("\n")
		}
	}

	// TODO(derat): Also write a map from single characters to the corresponding keys, e.g. 'a' -> KEY_A.

	write(footer)

	err = f.Close()
	if werr != nil {
		return werr
	}
	if err != nil {
		return err
	}
	return os.Rename(f.Name(), path)
}

func main() {
	if len(os.Args) != 3 || os.Args[1] == "" || os.Args[1][0] == '-' || os.Args[2] == "" || os.Args[2][0] == '-' {
		fmt.Fprintf(os.Stderr, "Usage: %s <input-event-codes.h> <out.go>\n", os.Args[0])
		os.Exit(1)
	}
	repoPath, repoRev, err := getRepoInfo(os.Args[1])
	if err != nil {
		log.Fatalf("Failed to get repo info for %v: %v", os.Args[1], err)
	}
	consts, err := readConstants(os.Args[1])
	if err != nil {
		log.Fatalf("Failed to read %v: %v", os.Args[1], err)
	}
	if err := writeConstants(consts, repoPath, repoRev, os.Args[2]); err != nil {
		log.Fatalf("Failed to write %v: %v", os.Args[2], err)
	}
}
