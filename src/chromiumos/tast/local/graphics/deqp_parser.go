// Copyright 2018 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package graphics

import (
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"strings"
)

// deqpParser holds state to parse log files generated by DEQP tests. This type
// should not be used directly. Instead, use the exported ParseDEQPOutput
// function.
type deqpParser struct {
	// The path of the file to parse.
	path string

	// To accumulate statistics. Each key is an outcome and the value is the
	// number of tests with that outcome.
	stats map[string]uint

	// To accumulate the list of tests that failed.
	failed []string

	// Holds the current line of input being read.
	line string

	// Whether we're currently looking at the last line of input.
	lastLine bool

	// State to detect when XML code is about to start.
	start bool

	// To accumulate XML code.
	rawXML strings.Builder

	// To hold the name of the current test case.
	test string

	// To hold the outcome of the current test case.
	outcome string

	// To detect when the XML is expected to be complete.
	complete bool

	// To detect a recoverable parsing error.
	bad bool
}

// Markers that we need to look for in the DEQP log files.
const (
	beginResult = "#beginTestCaseResult"
	endResult   = "#endTestCaseResult"
	termResult  = "#terminateTestCaseResult"
)

// Set of outcomes not considered to be a failure. This is a port of the
// TEST_RESULT_FILTER list in
// autotest/files/client/site_tests/graphics_dEQP/graphics_dEQP.py.
var nonFailOutcomes map[string]struct{} = map[string]struct{}{
	"pass":                 struct{}{},
	"notsupported":         struct{}{},
	"internalerror":        struct{}{},
	"qualitywarning":       struct{}{},
	"compatibilitywarning": struct{}{},
	"skipped":              struct{}{},
}

// newDEQPParser constructs a new deqpParser and prepares it for parsing.
func newDEQPParser(p string) *deqpParser {
	return &deqpParser{path: p, stats: make(map[string]uint)}
}

// handleBeginResult handles a line starting with #beginTestCaseResult.
func (d *deqpParser) handleBeginResult() error {
	// If we see another begin before an end/terminate then something is wrong.
	if d.start {
		return fmt.Errorf("unexpected %v", beginResult)
	}

	// Derive the test name from #beginTestCaseResult.
	if s := strings.TrimSpace(strings.TrimPrefix(d.line, beginResult)); len(s) > 0 {
		d.test = s
		d.start = true
		return nil
	}
	return fmt.Errorf("%v is not followed by test name", beginResult)
}

// handleBeginResult handles a line starting with #endTestCaseResult.
func (d *deqpParser) handleEndResult() error {
	// We shouldn't see an end without a begin.
	if !d.start {
		return fmt.Errorf("unexpected %v", endResult)
	}
	d.complete = true
	return nil
}

// handleBeginResult handles a line starting with #terminateTestCaseResult.
func (d *deqpParser) handleTermResult() error {
	// We shouldn't see a terminate without a begin.
	if !d.start {
		return fmt.Errorf("unexpected %v", termResult)
	}

	// If the test terminates early, the XML could be incomplete and should not
	// be parsed. Get the cause for early termination.
	if s := strings.TrimSpace(strings.TrimPrefix(d.line, termResult)); len(s) > 0 {
		d.outcome = s
		d.bad = true
		return nil
	}

	// #terminateTestCaseResult is not accompanied by a cause. If this is the
	// last line, let's assume that Tast killed the test due to a timeout and
	// make this error recoverable. Otherwise, report an irrecoverable error.
	if d.lastLine {
		d.outcome = "parsefailed"
		d.bad = true
		return nil
	}
	return fmt.Errorf("missing cause for %v", termResult)
}

// handleXML parses the XML present in d.rawXML and performs some sanity checks.
func (d *deqpParser) handleXML() error {
	// Structure to parse the XML into. Note that it's necessary to capitalize
	// the first letter of each field so that xml.Unmarshal works.
	r := struct {
		XMLName  xml.Name `xml:"TestCaseResult"`
		CasePath string   `xml:",attr"`
		Result   []struct {
			StatusCode string `xml:",attr"`
		}
	}{}

	// Parse and perform sanity checks.
	if err := xml.Unmarshal([]byte(d.rawXML.String()), &r); err != nil {
		return err
	}
	if len(r.CasePath) == 0 || r.CasePath != d.test {
		return fmt.Errorf("bad CasePath: %q", r.CasePath)
	}
	if len(r.Result) != 1 {
		return fmt.Errorf("%v <Result> elements found", len(r.Result))
	}
	d.outcome = strings.TrimSpace(r.Result[0].StatusCode)
	if len(d.outcome) == 0 {
		return fmt.Errorf("bad StatusCode: %q", d.outcome)
	}
	return nil
}

// handleRemainingInput is expected to be called after going through all the
// lines in the file. If by that time, d.start == true, this method produces a
// recoverable error for the test that never ended. This can happen, e.g., if
// Tast killed the test due to a timeout or a crash occurred.
func (d *deqpParser) handleRemainingInput() {
	if d.start {
		d.outcome = "parsefailed"
		d.collectOutcome()
	}
}

// collectOutcome adds the current test to the d.failed slice if it's detected
// to have failed. It also counts it in the d.stats map.
func (d *deqpParser) collectOutcome() {
	if DEQPOutcomeIsFailure(d.outcome) {
		d.failed = append(d.failed, d.test)
	}
	d.stats[strings.ToLower(d.outcome)]++
}

// prepareForNextTestCase resets the state necessary to move onto the next test
// case.
func (d *deqpParser) prepareForNextTestCase() {
	d.start = false
	d.rawXML.Reset()
	d.test = ""
	d.outcome = ""
	d.complete = false
	d.bad = false
}

// parse is the most important method for a deqpParser. It reads the file line
// by line to parse it and eventually produce a d.stats map which counts the
// number of tests for each outcome and a d.failed slice that contains the names
// of the tests detected to have failed.
//
// This is a (hopefully improved) port of the functionality of the parsing
// function defined in
// autotest/files/client/site_tests/graphics_dEQP/graphics_dEQP.py: the version
// here tends to be more conservative with parsing errors since they could
// indicate a problem with the DEQP output.
func (d *deqpParser) parse() error {
	b, err := ioutil.ReadFile(d.path)
	if err != nil {
		return err
	}

	lines := strings.Split(string(b), "\n")
	for i, l := range lines {
		d.line = l
		d.lastLine = (i == len(lines)-1)

		switch {
		case strings.HasPrefix(d.line, beginResult):
			if err := d.handleBeginResult(); err != nil {
				return fmt.Errorf("line %v: %v", i+1, err)
			}
		case strings.HasPrefix(d.line, endResult):
			if err := d.handleEndResult(); err != nil {
				return fmt.Errorf("line %v: %v", i+1, err)
			}
		case strings.HasPrefix(d.line, termResult):
			if err := d.handleTermResult(); err != nil {
				return fmt.Errorf("line %v: %v", i+1, err)
			}
		case d.start:
			// We're currently collecting XML. Note that we don't need to add a
			// newline after each line: the XML parser is ok with that.
			d.rawXML.WriteString(d.line)
		}

		// Check if we're done with the test case.
		if d.complete || d.bad {
			if d.complete {
				if err := d.handleXML(); err != nil {
					return fmt.Errorf("test %v: %v", d.test, err)
				}
			}
			d.collectOutcome()
			d.prepareForNextTestCase()
		}
	}

	d.handleRemainingInput()
	return nil
}

// DEQPOutcomeIsFailure decides if an outcome found in the output of a DEQP test
// is considered a failure.
func DEQPOutcomeIsFailure(s string) bool {
	_, isNonFail := nonFailOutcomes[strings.ToLower(s)]
	return !isNonFail
}

// ParseDEQPOutput parses the given DEQP log file to extract the number of tests
// per outcome (returned in the stats map) and the names of the tests that
// failed. An error is returned if an irrecoverable error occurs, i.e., an error
// that can suggest problems with the DEQP output.
//
// The returned stats map might look something like
//	"pass": 3
//	"fail": 1
//
// This means that 3 tests passed and 1 failed. A recoverable error is reported
// in the stats map with the reserved outcome "parsefailed", and the
// corresponding test name is added to the failed slice.
//
// This parser expects the format explained in
// https://android.googlesource.com/platform/external/deqp/+/deqp-dev/doc/qpa_file_format.txt
// but only cares about the #beginTestCaseResult ... #endTestCaseResult or
// #beginTestCaseResult ... #terminateTestCaseResult sections.
//
// TODO(andrescj): we may also need to return the tests that didn't fail so that
// the caller can decide if there are missing tests. It seems that DEQP ignores
// other tests once one of them is killed by the watchdog. In this case, those
// ignored tests don't get added to the failed slice. Also, if a test is killed
// by Tast and the last line is something like "#beginTestCaseRes", we won't
// know which test failed.
func ParseDEQPOutput(p string) (stats map[string]uint, failed []string, err error) {
	d := newDEQPParser(p)
	if err := d.parse(); err != nil {
		return nil, nil, err
	}
	return d.stats, d.failed, nil
}
