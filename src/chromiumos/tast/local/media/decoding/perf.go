// Copyright 2019 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package decoding

import (
	"context"
	"encoding/json"
	"os"

	"chromiumos/tast/common/perf"
	"chromiumos/tast/errors"
	"chromiumos/tast/testing"
)

// This file contains helper functions that can be used to parse the log files
// generated by the video_decode_accelerator_perf_tests.

// parseUncappedPerfMetrics parses the JSON log file generated by the
// MeasureUncappedPerformance test.
func parseUncappedPerfMetrics(ctx context.Context, metricsPath string, p *perf.Values, metricPrefix string) error {
	f, err := os.Open(metricsPath)
	if err != nil {
		return err
	}
	defer f.Close()

	var metrics struct {
		FrameDeliveryTimeAverage      float64
		FrameDeliveryTimePercentile25 float64
		FrameDeliveryTimePercentile50 float64
		FrameDeliveryTimePercentile75 float64
		FrameDeliveryTimes            []float64
		FPS                           float64
	}

	if err := json.NewDecoder(f).Decode(&metrics); err != nil {
		return errors.Wrapf(err, "failed decoding %s", metricsPath)
	}

	p.Set(perf.Metric{
		Name:      metricPrefix + ".delivery_time.average",
		Unit:      "milliseconds",
		Direction: perf.SmallerIsBetter,
	}, metrics.FrameDeliveryTimeAverage)
	p.Set(perf.Metric{
		Name:      metricPrefix + ".delivery_time.first",
		Unit:      "milliseconds",
		Direction: perf.SmallerIsBetter,
	}, metrics.FrameDeliveryTimes[0])
	p.Set(perf.Metric{
		Name:      metricPrefix + ".delivery_time.percentile_0.25",
		Unit:      "milliseconds",
		Direction: perf.SmallerIsBetter,
	}, metrics.FrameDeliveryTimePercentile25)
	p.Set(perf.Metric{
		Name:      metricPrefix + ".delivery_time.percentile_0.50",
		Unit:      "milliseconds",
		Direction: perf.SmallerIsBetter,
	}, metrics.FrameDeliveryTimePercentile50)
	p.Set(perf.Metric{
		Name:      metricPrefix + ".delivery_time.percentile_0.75",
		Unit:      "milliseconds",
		Direction: perf.SmallerIsBetter,
	}, metrics.FrameDeliveryTimePercentile75)
	p.Set(perf.Metric{
		Name:      metricPrefix + ".frames_per_second",
		Unit:      "fps",
		Direction: perf.BiggerIsBetter,
	}, metrics.FPS)

	testing.ContextLogf(ctx, metricPrefix+".delivery_time.average: %f ms", metrics.FrameDeliveryTimeAverage)
	testing.ContextLogf(ctx, metricPrefix+".delivery_time.first: %f ms", metrics.FrameDeliveryTimes[0])
	testing.ContextLogf(ctx, metricPrefix+".delivery_time.percentile_0.25: %f ms", metrics.FrameDeliveryTimePercentile25)
	testing.ContextLogf(ctx, metricPrefix+".delivery_time.percentile_0.50: %f ms", metrics.FrameDeliveryTimePercentile50)
	testing.ContextLogf(ctx, metricPrefix+".delivery_time.percentile_0.75: %f ms", metrics.FrameDeliveryTimePercentile75)
	testing.ContextLogf(ctx, metricPrefix+".frames_per_second.average: %f fps", metrics.FPS)

	return nil
}

// parseCappedPerfMetrics parses the JSON log file generated by the
// MeasureCappedPerformance test.
func parseCappedPerfMetrics(ctx context.Context, metricsPath string, p *perf.Values, metricPrefix string) error {
	f, err := os.Open(metricsPath)
	if err != nil {
		return err
	}
	defer f.Close()

	var metrics struct {
		DroppedFramePercentage      float64
		FrameDecodeTimePercentile50 float64
	}

	if err := json.NewDecoder(f).Decode(&metrics); err != nil {
		return errors.Wrapf(err, "failed decoding %s", metricsPath)
	}

	p.Set(perf.Metric{
		Name:      metricPrefix + ".frame_drop_percentage",
		Unit:      "percent",
		Direction: perf.SmallerIsBetter,
	}, metrics.DroppedFramePercentage)
	p.Set(perf.Metric{
		Name:      metricPrefix + ".decode_time.percentile_0.50",
		Unit:      "milliseconds",
		Direction: perf.SmallerIsBetter,
	}, metrics.FrameDecodeTimePercentile50)

	return nil
}
