// Copyright 2019 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package main contains shared functions for code generation.
//
// This file is not executed directly, but rather symlinked alongside
// scripts that are executed via "go run" by "go generate".
package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"

	"github.com/pkg/errors"
)

const tmplStr = `// Copyright 2019 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package {{.PackageName}}

// Code generated by gen/gen_constants.go. DO NOT EDIT.
//
// Do not change the above line; see https://golang.org/pkg/cmd/go/internal/generate/
//
// This file contains constants from {{.InputPath}}
// in the {{.RepoName}} at revision {{.Revision}}.
// Run "go generate" to regenerate it.

{{/* Optional string that could be used to add any valid Go code, like the go:generate rule comment */}}
{{- .Optional}}

{{/* Defines the types */}}
{{- range .Types}}
// {{.Name}} {{.Desc}}
type {{.Name}} {{.NativeType}}
{{- end}}

{{/* Generates the constants for each group */}}
const (
{{- range .Groups}}
	// {{.Desc}}{{$type := .TypeName -}}
{{range .Constants}}
	{{.Name}} {{$type}} = {{.Val}}
{{- end}}
{{end}}
)
`

const (
	// packageNameKey
	packageNameKey = "packageName"
	// repoNameKey
	repoNameKey = "repoName"
	// optionalCodeKey
	optionalCodeKey = "optional"
	// repoPathKey
	repoPathKey = "repoPath"
	// repoRevKey
	repoRevKey = "repoRev"
)

// templVars represents variables, besides groupInfo, used the template.
// Includes, but not limited to package name, repository name, optional code.
type templArgs map[string]string

// groupInfo describes a group of constants.
type groupInfo struct {
	prefix   string // constant prefix, e.g. "EV", "KEYCODE", or "META"
	typeName string // constant type name, e.g. "KeyCode"
	desc     string // human-readable group description used in comment
}

type typeInfo struct {
	name       string
	nativeType string
	desc       string
}

// getGroupForName returns group info for the supplied constant.
func getGroupForName(name string) *groupInfo {
	for _, g := range groups {
		if strings.HasPrefix(name, g.prefix) {
			return g
		}
	}
	return nil
}

// constant describes an individual constant.
type constant struct {
	name string // name from the Java file e.g. "KEYCODE_NUMPAD_9"
	val  int64  // parsed value from the Java file
}

// constantGroups is a map from a group name (e.g. "KEYCODE" or "META") to the corresponding constants.
type constantGroups map[string][]constant

// getRepoInfo returns path's location relative to its git repository and the HEAD revision for the repository.
func getRepoInfo(path string) (relPath, rev string, err error) {
	if path, err = filepath.Abs(path); err != nil {
		return "", "", err
	}
	path = filepath.Clean(path)

	// This prints the base path of the repo on the first line and HEAD's revision on the second.
	cmd := exec.Command("git", "rev-parse", "--show-toplevel", "HEAD")
	cmd.Dir = filepath.Dir(path)
	out, err := cmd.Output()
	if err != nil {
		return "", "", err
	}

	lines := strings.Split(strings.TrimSpace(string(out)), "\n")
	if len(lines) != 2 {
		return "", "", errors.Errorf("%q printed %q; wanted 2 lines", strings.Join(cmd.Args, " "), string(out))
	}
	rev = lines[1]
	if relPath, err = filepath.Rel(lines[0], path); err != nil {
		return "", "", err
	}
	return relPath, rev, nil
}

// readConstants reads path, a KeyEvent.java file, and returns a subset of relevant constants from it.
func readConstants(path, reg string) (constantGroups, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	consts := make(constantGroups)

	re := regexp.MustCompile(reg)

	sc := bufio.NewScanner(f)
	for sc.Scan() {
		matches := re.FindStringSubmatch(sc.Text())
		if matches == nil {
			continue
		}
		name, sval := matches[1], matches[2]
		grp := getGroupForName(name)
		if grp == nil {
			return nil, errors.Errorf("unable to classify %q", name)
		} else if name == grp.prefix+"_MAX" {
			continue
		}

		base := 10
		if len(sval) > 2 && sval[:2] == "0x" {
			base = 16
			sval = sval[2:] // strconv.ParseInt doesn't want "0x" prefix
		}
		var val int64
		if val, err = strconv.ParseInt(sval, base, 64); err != nil {
			return nil, errors.Wrapf(err, "unable to parse value %q for %q", sval, name)
		}
		consts[grp.prefix] = append(consts[grp.prefix], constant{name, val})
	}

	// Sort each group by ascending value.
	for _, cs := range consts {
		sort.Slice(cs, func(i, j int) bool { return cs[i].val < cs[j].val })
	}

	return consts, sc.Err()
}

// writeConstants writes consts to path as a Go source file.
// repoPath contains the source file's path relative to its repository and repoRev
// contains the current revision of the repository; both are included in a comment.
func writeConstants(consts constantGroups, groups []*groupInfo, types []*typeInfo, args templArgs, path string) error {
	type constData struct {
		Name, Val string
	}
	type groupData struct {
		TypeName, Desc string
		Constants      []constData
	}

	type typeData struct {
		Name, Desc, NativeType string
	}

	data := struct {
		InputPath, Revision             string
		PackageName, RepoName, Optional string
		Groups                          []groupData
		Types                           []typeData
	}{
		args[repoPathKey],
		args[repoRevKey],
		args[packageNameKey],
		args[repoNameKey],
		args[optionalCodeKey],
		nil,
		nil,
	}

	for _, grp := range groups {
		gd := groupData{TypeName: grp.typeName, Desc: grp.desc}
		for _, c := range consts[grp.prefix] {
			gd.Constants = append(gd.Constants, constData{c.name, fmt.Sprintf("%#x", c.val)})
		}
		data.Groups = append(data.Groups, gd)
	}

	for _, typ := range types {
		td := typeData{Name: typ.name, Desc: typ.desc, NativeType: typ.nativeType}
		data.Types = append(data.Types, td)
	}

	f, err := ioutil.TempFile(filepath.Dir(path), "."+filepath.Base(path)+".")
	if err != nil {
		return err
	}
	defer func() {
		if err == nil {
			return
		}
		f.Close()
		os.Remove(f.Name())
	}()

	if err = template.Must(template.New("header").Parse(tmplStr)).Execute(f, data); err != nil {
		return err
	}

	if err = f.Close(); err != nil {
		return err
	}

	return os.Rename(f.Name(), path)
}

// // parseArgs represents the arguments needed to call parseConstants
// type parseArgs struct {
// 	inPath   string       // Path for the input file, the source
// 	outPath  string       // Path for the autogenerated constants
// 	regexp   string       // Regular expression that captures the name of the constants and its value
// 	pkgName  string       // Package name of the autogenerated files
// 	optional string       // Optional Go code. At the moment used to place the "go:generate" rule as a Go comment.
// 	groups   []*groupInfo // Group info
// }

func parseConstants(inPath, outPath, regexp string, groups []*groupInfo, types []*typeInfo, args templArgs) {
	repoPath, repoRev, err := getRepoInfo(inPath)
	if err != nil {
		log.Fatalf("Failed to get repo info for %v: %v", inPath, err)
	}
	consts, err := readConstants(inPath, regexp)
	if err != nil {
		log.Fatalf("Failed to read %v: %v", inPath, err)
	}

	args[repoPathKey] = repoPath
	args[repoRevKey] = repoRev

	if err := writeConstants(consts, groups, types, args, outPath); err != nil {
		log.Fatalf("Failed to write %v: %v", outPath, err)
	}
}
