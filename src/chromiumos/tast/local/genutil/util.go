// Copyright 2019 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package main contains shared functions for code generation.
//
// This file is not executed directly, but rather symlinked alongside
// scripts that are executed via "go run" by "go generate".
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/pkg/errors"
)

const tmplStr = `// Copyright 2019 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package {{.PackageName}}

// Code generated by gen/gen_constants.go. DO NOT EDIT.
//
// Do not change the above line; see https://golang.org/pkg/cmd/go/internal/generate/
//
// This file contains constants from {{.InputPath}}
// in the {{.RepoName}} at revision {{.Revision}}.
// Run "go generate" to regenerate it.

{{/* String that could be used to add any valid Go code, including comments, like the go:generate rule */}}
{{- .PreludeCode}}

{{/* Defines the types */}}
{{- range .Types}}
// {{.Name}} {{.Desc}}
type {{.Name}} {{.NativeType}}
{{- end}}

{{/* Generates the constants for each group */}}
const (
{{- range .Groups}}
	// {{.Desc}}{{$type := .TypeName -}}
{{range .Constants}}
	{{.Name}} {{$type}} = {{.Val}}
{{- end}}
{{end}}
)
`

const (
	// packageNameKey is the key used for the package name.
	packageNameKey = "packageName"
	// repoNameKey is the key used for the repo name.
	repoNameKey = "repoName"
	// repoPathKey is the key used for constant file relative to the repo root.
	repoPathKey = "repoPath"
	// repoRevKey is the key used for repo revision.
	repoRevKey = "repoRev"
	// preludeCodeKey is the key used for any kind of valid Go code, including comments,
	// that is placed at the beggining of the autogenerated file.
	preludeCodeKey = "prelude"
)

// tmplArgs represents the arguments, besides groupInfo and typeInfo, used in the template.
// Includes, but not limited to package name, repository name, prelude code.
type tmplArgs map[string]string

// groupInfo describes a group of constants.
type groupInfo struct {
	prefix   string // constant prefix, e.g. "EV"
	typeName string // constant type name, e.g. "KeyCode"
	desc     string // human-readable group description used in comment
}

// typeInfo describes a type.
type typeInfo struct {
	name       string // type name, e.g "KeyCodeType"
	nativeType string // the Go native type, e.g "uint64"
	desc       string // human-readable type description used in comment
}

// constant describes an individual constant.
type constant struct {
	name string // name from the Java file e.g. "KEYCODE_NUMPAD_9"
	val  int64  // parsed value from the Java file
}

// constantGroups is a map from a group name (e.g. "KEYCODE") to the corresponding constants.
type constantGroups map[string][]constant

// getRepoInfo returns path's location relative to its git repository and the HEAD revision for the repository.
func getRepoInfo(path string) (relPath, rev string, err error) {
	if path, err = filepath.Abs(path); err != nil {
		return "", "", err
	}
	path = filepath.Clean(path)

	// This prints the base path of the repo on the first line and HEAD's revision on the second.
	cmd := exec.Command("git", "rev-parse", "--show-toplevel", "HEAD")
	cmd.Dir = filepath.Dir(path)
	out, err := cmd.Output()
	if err != nil {
		return "", "", err
	}

	lines := strings.Split(strings.TrimSpace(string(out)), "\n")
	if len(lines) != 2 {
		return "", "", errors.Errorf("%q printed %q; wanted 2 lines", strings.Join(cmd.Args, " "), string(out))
	}
	rev = lines[1]
	if relPath, err = filepath.Rel(lines[0], path); err != nil {
		return "", "", err
	}
	return relPath, rev, nil
}

// writeConstants writes consts to path as a Go source file.
// groups contains the different group descriptions.
// types contains the different type descriptions.
// tmplArgs contains template arguments such as repo path, package name, repo revision, etc.
func writeConstants(consts constantGroups, groups []*groupInfo, types []*typeInfo, args tmplArgs, path string) error {
	type constData struct {
		Name, Val string
	}
	type groupData struct {
		TypeName, Desc string
		Constants      []constData
	}

	type typeData struct {
		Name, Desc, NativeType string
	}

	data := struct {
		InputPath, Revision                string
		PackageName, RepoName, PreludeCode string
		Groups                             []groupData
		Types                              []typeData
	}{
		args[repoPathKey],
		args[repoRevKey],
		args[packageNameKey],
		args[repoNameKey],
		args[preludeCodeKey],
		nil,
		nil,
	}

	for _, grp := range groups {
		gd := groupData{TypeName: grp.typeName, Desc: grp.desc}
		for _, c := range consts[grp.prefix] {
			gd.Constants = append(gd.Constants, constData{c.name, fmt.Sprintf("%#x", c.val)})
		}
		data.Groups = append(data.Groups, gd)
	}

	for _, typ := range types {
		td := typeData{Name: typ.name, Desc: typ.desc, NativeType: typ.nativeType}
		data.Types = append(data.Types, td)
	}

	f, err := ioutil.TempFile(filepath.Dir(path), "."+filepath.Base(path)+".")
	if err != nil {
		return err
	}
	defer func() {
		if err == nil {
			return
		}
		f.Close()
		os.Remove(f.Name())
	}()

	if err = template.Must(template.New("header").Parse(tmplStr)).Execute(f, data); err != nil {
		return err
	}

	if err = f.Close(); err != nil {
		return err
	}

	return os.Rename(f.Name(), path)
}
