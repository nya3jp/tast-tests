// Copyright 2022 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package perf

import (
	"context"
	"math"
	"strconv"
	"strings"
	"time"

	"chromiumos/tast/errors"
	"chromiumos/tast/local/arc"
)

type frame struct {
	draw   int
	vsync  int
	submit int
}

// SurfaceFlingerMetrics contains information needed to call SurfaceFlinger and
// data returned by SurfaceFlinger.
type SurfaceFlingerMetrics struct {
	frames        []frame
	lastTimestamp int
	surfaceName   string
	arc           *arc.ARC
	collecting    chan bool
	collectingErr chan error
}

// NewSurfaceFlingerMetrics returns a new instance of SurfaceFlinger.
func NewSurfaceFlingerMetrics(surfaceName string, a *arc.ARC) *SurfaceFlingerMetrics {
	f := &SurfaceFlingerMetrics{
		frames:        nil,
		lastTimestamp: -1,
		// TODO(b/228454928): change surfaceName to be obtained via regular expressions.
		surfaceName: surfaceName,
		arc:         a,
	}
	return f
}

// TODO(b/230396035): Change the interval to be obtained based on the device's screen refresh rate.
const screenRefreshInterval = 500 * time.Millisecond
const nanosecondsPerSecond = 1000000000.0

// Start starts the SurfaceFlinger dumpsys for reporting latencies.
func (f *SurfaceFlingerMetrics) Start(ctx context.Context) error {
	if f == nil {
		return nil
	}

	if f.collecting != nil {
		return errors.New("already started")
	}
	f.collecting = make(chan bool)
	f.collectingErr = make(chan error, 1)

	// Start running SurfaceFlinger.
	go func() {
		ticker := time.NewTicker(screenRefreshInterval)
		defer ticker.Stop()

		for {
			select {
			case <-f.collecting:
				close(f.collectingErr)
				return
			case <-ticker.C:
				err := f.getRecentFrames(ctx)
				if err != nil {
					f.collectingErr <- errors.Wrap(err, "failed to get recent frames")
					return
				}
			case <-ctx.Done():
				f.collectingErr <- ctx.Err()
				return
			}
		}
	}()

	return nil
}

// Stop stops the SurfaceFlinger dumpsys, calculates FPS and average latency, and returns them.
func (f *SurfaceFlingerMetrics) Stop(ctx context.Context) (float64, float64, error) {
	if f == nil {
		return -1, -1, nil
	}

	if f.collecting == nil {
		return -1, -1, errors.New("not started")
	}
	// Stop SurfaceFlinger routine.
	close(f.collecting)
	select {
	case err := <-f.collectingErr:
		if err != nil {
			return -1, -1, err
		}
	case <-ctx.Done():
		return -1, -1, ctx.Err()
	}
	fps, latency := f.calculateMetrics()
	return fps, latency, nil
}

// getRecentFrames saves all recent frames generated by SurfaceFlinger to the
// SurfaceFlingerMetrics struct.
func (f *SurfaceFlingerMetrics) getRecentFrames(ctx context.Context) error {
	// Call the SurfaceFlinger command to obtain frame data.
	out, err := f.arc.SurfaceFlingerLatencyCommand(ctx, f.surfaceName).Output()
	if err != nil {
		return errors.Wrap(err, "failed to execute SurfaceFlinger start command")
	}
	lines := strings.Split(string(out), "\n")
	// Store all recent frames into the SurfaceFlingerMetrics object.
	for _, line := range lines {
		entries := strings.Split(line, "\t")

		// If the line does not contain three entries or if the first entry is "0", skip.
		if len(entries) != 3 || entries[0] == "0" {
			continue
		}

		// Parse each line into ints.
		var draw, vsync, submit int
		var parseError error
		if draw, parseError = strconv.Atoi(entries[0]); err != nil {
			return errors.Wrap(parseError, "failed to parse draw timestamp")
		}
		if vsync, parseError = strconv.Atoi(entries[1]); err != nil {
			return errors.Wrap(parseError, "failed to parse vsync timestamp")
		}
		if submit, parseError = strconv.Atoi(entries[2]); err != nil {
			return errors.Wrap(parseError, "failed to parse submit timestamp")
		}

		// A max integer denotes that a frame is still pending.
		if draw == math.MaxInt || vsync == math.MaxInt || submit == math.MaxInt {
			return errors.New("one or more entries are pending frames")
		}

		// If the frame is recent, append.
		if draw > f.lastTimestamp {
			f.frames = append(f.frames, frame{draw, vsync, submit})
		}
	}
	if len(f.frames) > 0 {
		// Reassign the latest timestamp.
		f.lastTimestamp = f.frames[len(f.frames)-1].draw
	}
	return nil
}

// calculateMetrics uses the collected frame data to calculate FPS and average latency respectively.
func (f *SurfaceFlingerMetrics) calculateMetrics() (fps, latency float64) {
	// We need to normalize to seconds (divide by 1 billion).
	numFrames := len(f.frames)
	if numFrames > 1 {
		// Calculate FPS.
		dt := float64(f.frames[numFrames-1].vsync-f.frames[0].vsync) / nanosecondsPerSecond
		fps := float64(numFrames-1) / dt

		// Calculate average latency.
		var latencies = 0.0
		for _, f := range f.frames {
			latencies += float64(f.submit-f.draw) / nanosecondsPerSecond
		}
		avgLatency := latencies / float64(numFrames)

		return fps, avgLatency
	}
	return -1, -1
}
