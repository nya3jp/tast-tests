// Copyright 2022 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package perf

import (
	"context"
	"strconv"
	"strings"
	"time"

	"chromiumos/tast/errors"
	"chromiumos/tast/local/arc"
)

type frame struct {
	draw   int
	vsync  int
	submit int
}

// FrameLatencyStats contains information needed to call SurfaceFlinger and
// data returned by SurfaceFlinger.
type FrameLatencyStats struct {
	frames        []frame
	lastTimestamp int
	surfaceName   string
	Arc           *arc.ARC
	collecting    chan bool
	collectingErr chan error
}

// NewFrameLatencyStats returns a new instance of SurfaceFlinger.
func NewFrameLatencyStats(appPkgName, appActivityName string, a *arc.ARC) *FrameLatencyStats {
	f := &FrameLatencyStats{
		frames:        nil,
		lastTimestamp: -1,
		// TODO(b/228454928): change surfaceName to be obtained via regular expressions.
		surfaceName: "\"SurfaceView - " + appPkgName + "/" + appPkgName + appActivityName + "#0\"",
		Arc:         a,
	}
	return f
}

const screenRefreshInterval = 500 * time.Millisecond
const nanosecondsPerSecond = 1000000000.0

// StartSurfaceFlinger starts the SurfaceFlinger dumpsys for reporting latencies.
func (f *FrameLatencyStats) StartSurfaceFlinger(ctx context.Context) error {
	if f == nil {
		return nil
	}

	if f.collecting != nil {
		return errors.New("already started")
	}
	f.collecting = make(chan bool)
	f.collectingErr = make(chan error, 1)
	// Interval time, as hard coded in the manual testing FPS script.
	ticker := time.NewTicker(screenRefreshInterval)

	// Start running SurfaceFlinger.
	go func() {
		for {
			select {
			case <-f.collecting:
				close(f.collectingErr)
				return
			case <-ticker.C:
				err := f.getRecentFrames(ctx)
				if err != nil {
					f.collectingErr <- errors.Wrap(err, "failed to get recent frames")
					return
				}
			case <-ctx.Done():
				f.collectingErr <- ctx.Err()
				return
			}
		}
	}()

	return nil
}

// StopSurfaceFlinger stops the SurfaceFlinger dumpsys, calculates FPS and
// average latency, and returns them.
func (f *FrameLatencyStats) StopSurfaceFlinger(ctx context.Context) (float64, float64, error) {
	if f == nil {
		return -1, -1, nil
	}

	if f.collecting == nil {
		return -1, -1, errors.New("not started")
	}
	// Stop SurfaceFlinger routine.
	close(f.collecting)
	select {
	case err := <-f.collectingErr:
		if err != nil {
			return -1, -1, err
		}
	case <-ctx.Done():
		return -1, -1, ctx.Err()
	}
	fps, latency := f.calculateMetrics()
	return fps, latency, nil
}

// getRecentFrames saves all recent frames generated by SurfaceFlinger to the
// FrameLatencyStats struct.
func (f *FrameLatencyStats) getRecentFrames(ctx context.Context) error {
	// Call the SurfaceFlinger command to obtain frame data.
	out, err := f.Arc.SurfaceFlingerLatencyCommand(ctx, f.surfaceName).Output()
	if err != nil {
		return errors.Wrap(err, "failed to execute SurfaceFlinger start command")
	}
	lines := strings.Split(string(out), "\n")
	// Store all recent frames into the FrameLatencyStats object.
	for _, line := range lines {
		if len([]rune(line)) == 0 {
			continue
		}
		// Parse each line into ints.
		entries := strings.Split(line, "\t")
		var entriesInt = []int{}
		for _, i := range entries {
			j, err := strconv.Atoi(i)
			if err != nil {
				return errors.Wrap(err, "failed to parse SurfaceFlinger output")
			}
			entriesInt = append(entriesInt, j)
		}
		// If 0 is in the entries array, skip.
		if entriesInt[0] == 0 {
			continue
		}

		// If the line does not contain three entries, skip.
		if len(entriesInt) != 3 {
			continue
		}

		// If the frame is recent, append.
		if entriesInt[0] > f.lastTimestamp {
			f.frames = append(f.frames, frame{entriesInt[0], entriesInt[1], entriesInt[2]})
		}
	}
	if len(f.frames) > 0 {
		// Reassign the latest timestamp.
		f.lastTimestamp = f.frames[len(f.frames)-1].draw
	}
	return nil
}

// calculateMetrics uses the collected frame data to calculate FPS and average latency respectively.
func (f *FrameLatencyStats) calculateMetrics() (float64, float64) {
	// We need to normalize to seconds (divide by 1 billion).
	numFrames := len(f.frames)
	if numFrames > 1 {
		// Calculate FPS.
		dt := float64(f.frames[numFrames-1].vsync-f.frames[0].vsync) / nanosecondsPerSecond
		fps := float64(numFrames-1) / dt

		// Calculate average latency.
		var latencies = 0.0
		for _, f := range f.frames {
			latencies += float64(f.submit-f.draw) / nanosecondsPerSecond
		}
		avgLatency := latencies / float64(numFrames)

		return fps, avgLatency
	}
	return -1, -1
}
