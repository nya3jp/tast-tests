// Copyright 2019 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package firmware

import (
	"bytes"
	"context"
	"encoding/binary"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"strings"
	"time"

	"boringssl.googlesource.com/boringssl/util/fipstools/acvp/acvptool/acvp"
	"boringssl.googlesource.com/boringssl/util/fipstools/acvp/acvptool/subprocess"

	"chromiumos/tast/local/testexec"
	"chromiumos/tast/shutil"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func: ACVP,
		Attr:         []string{"informational", "disabled"},
		Contacts: []string{
			"gurleengrewal@chromium.org", // Test author
			"sukhomlinov@chromium.org",   // CR50 certification lead
		},
		Desc: "Takes a JSON generated by the ACVP server and runs the test cases in it",
		SoftwareDeps: []string{"chrome", "tpm"},
		Params: []testing.Param{{
			Name: "aes_ecb_full",
			Val: dataFile {
				file: "aes-ecb-full.json",
			},
			ExtraData: []string{
				"aes-ecb-full.json",
			},
		}, {
			Name: "aes_ecb_short",
			Val: dataFile {
				file: "aes-ecb-short.json",
			},
			ExtraData: []string{
				"aes-ecb-short.json",
			},
		}},
		Timeout: time.Hour * 10,
	})
}

const (
	wordLen            = 4
	cr50HeaderSize     = 12
	cr50RespHeaderSize = 12
)

// Holds location of test data for each test type.
type dataFile struct {
	file string
}

// Writes commands to DUT and reads the output.
// This interface is required by acvptool.
type cr50ReadWriteCloser struct {
	ctx     context.Context
	s       *testing.State
	outBuf  bytes.Buffer                              // ACVptool output goes here
	parsers map[string]func([]string) (string, error) // map of functions implementing parser for each algorithm
}

// Runs a trunks command on the DUT.
func (w *cr50ReadWriteCloser) Write(b []byte) (int, error) {
	cmdArg := w.getTrunksCmd(b)
	cmd := testexec.CommandContext(w.ctx, "trunks_send", "--raw", cmdArg)
	out, err := cmd.Output(testexec.DumpLogOnError)
	if err != nil {
		w.s.Fatalf("%q failed: %v", shutil.EscapeSlice(cmd.Args), err)
	}
	w.populateOutBuf(out)
	return 1, nil
}

// Close does nothing, but is required to implement the ReadWriteCloser interface.
func (w *cr50ReadWriteCloser) Close() error {
	return nil
}

// Read the output of the trunks command.
func (w *cr50ReadWriteCloser) Read(b []byte) (int, error) {
	return w.outBuf.Read(b)
}

// getTrunksCmd converts contents of inBuf into a trunks command.
func (w *cr50ReadWriteCloser) getTrunksCmd(b []byte) string {
	args := w.parseInBuf(b)

	// The first index in array contains algorithm arguments separated by '/'
	algArgs := strings.Split(args[0], "/")
	algArgs = append(algArgs, args[1:]...)
	res, err := w.parsers[algArgs[0]](algArgs[1:])
	if err != nil {
		w.s.Fatal("Cannot parse trunks input: ", err)
	}
	return res
}

// parseInBuf is a generic parser for ACVPTool input format.
// It returns an array of args passed.
func (w *cr50ReadWriteCloser) parseInBuf(b []byte) []string {
	if len(b) < 4 {
		w.s.Fatal("Input buffer too short")
	}
	numArgs := binary.LittleEndian.Uint32(b[0:4])
	var res []string
	startInd := numArgs*4 + 4
	if uint32(len(b)) < startInd {
		w.s.Fatal("Input buffer too short")
	}
	// first arg is already a string
	argLen := binary.LittleEndian.Uint32(b[4:8])
	endInd := startInd + argLen
	if uint32(len(b)) < endInd {
		w.s.Fatal("Input buffer too short")
	}
	res = append(res, string(b[startInd:endInd]))
	startInd = endInd
	for i := uint32(8); i < numArgs*4+4; i += 4 {
		endInd = startInd + binary.LittleEndian.Uint32(b[i:i+4])
		if uint32(len(b)) < endInd {
			w.s.Fatal("Input buffer too short")
		}
		res = append(res, hex.EncodeToString(b[startInd:endInd]))
		startInd = endInd
	}
	return res
}

// populateOutBuf takes a cr50 command response and
// converts to output consumable by ACVPtool.
func (w *cr50ReadWriteCloser) populateOutBuf(b []byte) {
	// Responses to TPM vendor commands have the following header structure:
	// 8001      TPM_ST_NO_SESSIONS
	// 00000000  Response size
	// 00000000  Response code
	// 0000      Vendor Command Code
	b, _ = hex.DecodeString(string(b))

	if len(b) < cr50RespHeaderSize {
		w.s.Fatal("Trunks response too small.")
	}

	respCode := binary.LittleEndian.Uint32(b[8:12])
	if respCode != 0 {
		w.s.Fatalf("Unexpected response code from Cr50: %d", respCode)
	}

	respSize := uint32(len(b) - cr50RespHeaderSize)
	w.outBuf.Write([]byte{01, 00, 00, 00}) // num responses
	respSizeBytes := make([]byte, 4)
	binary.LittleEndian.PutUint32(respSizeBytes, respSize)
	w.outBuf.Write(respSizeBytes)
	w.outBuf.Write(b[12:])
}

// getAESCommand constructs a trunks AES command
func getAESCommand(args []string) (string, error) {
	// Assumes args has correct size
	// Args as follows:
	// TO DO: b:141372763 - use a struct as the arg
	// 0. Alg name (AES) followed by alg args (encrypt/decrypt)
	// 1. Key
	// 2. PT/CT
	// 3. (optional: IV)
	encrypt := false

	if args[0] == "encrypt" {
		encrypt = true
	}
	//  Cipher modes being tested
	// CIPHER_MODES = {'ECB': '00', 'CTR': '01', 'CBC': '02',
	// 				'GCM': '03', 'OFB': '04', 'CFB': '05'}
	// 8001      TPM_ST_NO_SESSIONS
	// 00000000  Command/response size
	// 20000000  Cr50 Vendor Command (Constant, TPM Command Code)
	// 0000      Vendor Command Code (VENDOR_CC_ enum) 0000 for AES
	// Command body: test_mode|cipher_mode|
	// Command structure, shared out of band with the test driver running
	// on the host:

	//  field       |    size  |              note
	//  ================================================================
	//  mode        |    1     | 0 - decrypt, 1 - encrypt
	//  cipher_mode |    1     | as per aes_test_cipher_mode
	//  key_len     |    1     | key size in bytes (16, 24 or 32)
	//  key         | key len  | key to use
	//  iv_len      |    1     | either 0 or 16
	//  iv          | 0 or 16  | as defined by iv_len
	//  aad_len     |  <= 127  | additional authentication data length
	//  aad         |  aad_len | additional authentication data
	//  text_len    |    2     | size of the text to process, big endian
	//  text        | text_len | text to encrypt/decrypt

	var cmdBody, cmdHeader bytes.Buffer
	cmdHeader.WriteString("8001")
	if encrypt {
		cmdBody.WriteString("01")
	} else {
		cmdBody.WriteString("00")
	}
	// Assume ECB mode for now
	cmdBody.WriteString("00")
	cmdBody.WriteString(fmt.Sprintf("%02x", len(args[1])/2))
	cmdBody.WriteString(args[1])
	cmdBody.WriteString("0000")
	cmdBody.WriteString(fmt.Sprintf("%04x", len(args[2])/2))
	cmdBody.WriteString(args[2])
	cmdHeader.WriteString(fmt.Sprintf("%08x", cmdBody.Len()/2+cr50HeaderSize))
	cmdHeader.WriteString("200000000000")

	return cmdHeader.String() + cmdBody.String(), nil
}

// ACVP takes a JSON generated by the ACVP server and runs the test cases in it.
func ACVP(ctx context.Context, s *testing.State) {
	var vectors acvp.Vectors
	testFile := s.Param().(dataFile)
	vectorsBytes, err := ioutil.ReadFile(s.DataPath(testFile.file))
	if err != nil {
		s.Fatal("Failed reading internal data file: ", err)
	} else {
		s.Log("Read data file: ", testFile.file)
	}

	if err := json.Unmarshal([]byte(vectorsBytes), &vectors); err != nil {
		s.Fatal("Failed to parse vector set: ", err)
	}

	inout := cr50ReadWriteCloser{
		ctx: ctx,
		s:   s,
	}

	// Currently only support AES
	inout.parsers = map[string]func([]string) (string, error){
		"AES": getAESCommand,
	}
	cmd := testexec.CommandContext(ctx, "trunks_send", "--raw")

	// TO DO: b:141372763 cmd.Cmd should actually be something empty
	middle := subprocess.NewWithIO(cmd.Cmd, &inout, &inout)
	defer middle.Close()

	replyGroups, err := middle.Process(vectors.Algo, vectorsBytes)
	if err != nil {
		s.Errorf("Failed to process middle: %s", err)
	}
	s.Log(string(replyGroups))
}
