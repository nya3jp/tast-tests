// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package crostini

import (
	"context"
	"os"
	"path/filepath"
	"time"

	"chromiumos/tast/ctxutil"
	"chromiumos/tast/local/crostini"
	"chromiumos/tast/local/crostini/ui/terminalapp"
	"chromiumos/tast/local/cryptohome"
	"chromiumos/tast/local/vm"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         BackupRestore,
		LacrosStatus: testing.LacrosVariantUnneeded,
		Desc:         "Checks crostini backup and restore",
		Contacts:     []string{"joelhockey@chromium.org", "cros-containers-dev@google.com"},
		Attr:         []string{"group:mainline", "informational"},
		SoftwareDeps: []string{"chrome", "vm_host"},
		Params: []testing.Param{
			// Parameters generated by params_test.go. DO NOT EDIT.
			{
				Name:              "stable",
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniStable,
				Fixture:           "crostiniBuster",
				Timeout:           10 * time.Minute,
			}, {
				Name:              "unstable",
				ExtraAttr:         []string{"informational"},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniUnstable,
				Fixture:           "crostiniBuster",
				Timeout:           10 * time.Minute,
			},
		},
	})
}

func BackupRestore(ctx context.Context, s *testing.State) {
	pre := s.FixtValue().(crostini.FixtureData)
	cr := pre.Chrome
	tconn := pre.Tconn
	cont := s.FixtValue().(crostini.FixtureData).Cont

	// Use a shortened context for test operations to reserve time for cleanup.
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, 5*time.Second)
	defer cancel()

	ownerID, err := cryptohome.UserHash(ctx, cr.NormalizedUser())
	if err != nil {
		s.Fatal("Failed to get user hash: ", err)
	}

	const (
		testFileName    = "BackupRestore.txt"
		testFileContent = "BackupRestore"
		copyName        = "penguin-tast-crostini-BackupRestore"
	)

	// We delete most files before backup and restore to speed the process.
	// Create an lxc copy before we change anything, then restore at the end.
	lxc := func(ctx context.Context, args ...string) {
		err := cont.VM.LXCCommand(ctx, args...)
		if err != nil {
			s.Fatal("LXC: ", err)
		}
	}
	lxc(ctx, "copy", vm.DefaultContainerName, copyName)
	defer func(ctx context.Context) {
		lxc(ctx, "delete", "-f", vm.DefaultContainerName)
		lxc(ctx, "rename", copyName, vm.DefaultContainerName)
		// We must restart the VM and container.
		if err := cont.VM.Stop(ctx); err != nil {
			s.Fatal("Error stopping VM: ", err)
		}
		terminalApp, err := terminalapp.Launch(ctx, tconn)
		if err != nil {
			s.Fatal("Error restarting container: ", err)
		}
		if err := terminalApp.Exit(pre.KB)(ctx); err != nil {
			s.Fatal("Failed to exit Terminal window: ", err)
		}
	}(cleanupCtx)
	ctx, cancel = ctxutil.Shorten(ctx, 60*time.Second)
	defer cancel()

	if err := cont.WriteFile(ctx, testFileName, testFileContent); err != nil {
		s.Fatalf("Failed to write file %v in container: %v", testFileName, err)
	}
	if err := vm.ShrinkDefaultContainer(ctx, ownerID); err != nil {
		s.Fatal("Failed to shrink container for backup: ", err)
	}

	s.Log("Waiting for crostini to backup (typically ~ 2 mins)")
	if err := tconn.Call(ctx, nil, "tast.promisify(chrome.autotestPrivate.exportCrostini)", "backup.tar.gz"); err != nil {
		s.Fatal("Running autotestPrivate.exportCrostini failed: ", err)
	}
	defer os.Remove(filepath.Join("/home/user", ownerID, "Downloads/backup.tar.gz"))

	// Delete the test file in the container.
	if err := crostini.RemoveContainerFile(ctx, cont, testFileName); err != nil {
		s.Fatalf("Failed to delete file %v in container: %v", testFileName, err)
	}
	if err := crostini.VerifyFileNotInContainer(ctx, cont, testFileName); err != nil {
		s.Errorf("File %v unexpectedly exists", testFileName)
	}

	// Restore the container and verify that the file is back.
	s.Log("Waiting for crostini to restore (typically ~ 1 min)")
	if err := tconn.Call(ctx, nil, "tast.promisify(chrome.autotestPrivate.importCrostini)", "backup.tar.gz"); err != nil {
		s.Fatal("Running autotestPrivate.importCrostini failed: ", err)
	}

	if err := cont.CheckFileContent(ctx, testFileName, testFileContent); err != nil {
		s.Fatalf("Wrong file content for %v: %v", testFileContent, err)
	}
}
