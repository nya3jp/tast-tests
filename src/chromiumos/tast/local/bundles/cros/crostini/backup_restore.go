// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package crostini

import (
	"context"
	"os"
	"path/filepath"
	"time"

	"chromiumos/tast/ctxutil"
	"chromiumos/tast/local/crostini"
	"chromiumos/tast/local/crostini/ui/terminalapp"
	"chromiumos/tast/local/cryptohome"
	"chromiumos/tast/local/vm"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         BackupRestore,
		Desc:         "Checks crostini backup and restore",
		Contacts:     []string{"joelhockey@chromium.org", "cros-containers-dev@google.com"},
		Attr:         []string{"group:mainline", "informational"},
		Vars:         []string{"keepState"},
		VarDeps:      []string{"ui.gaiaPoolDefault"},
		SoftwareDeps: []string{"chrome", "vm_host"},
		Params: []testing.Param{
			// Parameters generated by params_test.go. DO NOT EDIT.
			{
				Name:              "stretch_stable",
				ExtraAttr:         []string{"informational"},
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("stretch", false), crostini.GetContainerRootfsArtifact("stretch", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniStable,
				Pre:               crostini.StartedByDlcStretch(),
				Timeout:           7 * time.Minute,
			}, {
				Name:              "stretch_unstable",
				ExtraAttr:         []string{"informational"},
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("stretch", false), crostini.GetContainerRootfsArtifact("stretch", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniUnstable,
				Pre:               crostini.StartedByDlcStretch(),
				Timeout:           7 * time.Minute,
			}, {
				Name:              "buster_stable",
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("buster", false), crostini.GetContainerRootfsArtifact("buster", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniStable,
				Pre:               crostini.StartedByDlcBuster(),
				Timeout:           7 * time.Minute,
			}, {
				Name:              "buster_unstable",
				ExtraAttr:         []string{"informational"},
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("buster", false), crostini.GetContainerRootfsArtifact("buster", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniUnstable,
				Pre:               crostini.StartedByDlcBuster(),
				Timeout:           7 * time.Minute,
			}, {
				Name:              "bullseye_stable",
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("bullseye", false), crostini.GetContainerRootfsArtifact("bullseye", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniStable,
				Pre:               crostini.StartedByDlcBullseye(),
				Timeout:           7 * time.Minute,
			}, {
				Name:              "bullseye_unstable",
				ExtraAttr:         []string{"informational"},
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("bullseye", false), crostini.GetContainerRootfsArtifact("bullseye", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniUnstable,
				Pre:               crostini.StartedByDlcBullseye(),
				Timeout:           7 * time.Minute,
			},
		},
	})
}

func BackupRestore(ctx context.Context, s *testing.State) {
	pre := s.PreValue().(crostini.PreData)
	cr := pre.Chrome
	tconn := pre.TestAPIConn
	cont := s.PreValue().(crostini.PreData).Container
	defer crostini.RunCrostiniPostTest(ctx, s.PreValue().(crostini.PreData))

	ownerID, err := cryptohome.UserHash(ctx, cr.NormalizedUser())
	if err != nil {
		s.Fatal("Failed to get user hash: ", err)
	}

	const (
		testFileName    = "BackupRestore.txt"
		testFileContent = "BackupRestore"
		copyName        = "penguin-tast-crostini-BackupRestore"
	)

	// We delete most files before backup and restore to speed the process.
	// Create an lxc copy before we change anything, then restore at the end.
	lxc := func(ctx context.Context, args ...string) {
		err := cont.VM.LXCCommand(ctx, args...)
		if err != nil {
			s.Fatal("LXC: ", err)
		}
	}
	lxc(ctx, "copy", vm.DefaultContainerName, copyName)
	defer func(ctx context.Context) {
		lxc(ctx, "delete", "-f", vm.DefaultContainerName)
		lxc(ctx, "rename", copyName, vm.DefaultContainerName)
		// We must restart the VM and container.
		if err := cont.VM.Stop(ctx); err != nil {
			s.Fatal("Error stopping VM: ", err)
		}
		terminalApp, err := terminalapp.Launch(ctx, tconn)
		if err != nil {
			s.Fatal("Error restarting container: ", err)
		}
		if err := terminalApp.Exit(pre.Keyboard)(ctx); err != nil {
			s.Fatal("Failed to exit Terminal window: ", err)
		}
	}(ctx)
	ctx, cancel := ctxutil.Shorten(ctx, 30*time.Second)
	defer cancel()

	if err := cont.WriteFile(ctx, testFileName, testFileContent); err != nil {
		s.Fatalf("Failed to write file %v in container: %v", testFileName, err)
	}
	if err := vm.ShrinkDefaultContainer(ctx, ownerID); err != nil {
		s.Fatal("Failed to shrink container for backup: ", err)
	}

	s.Log("Waiting for crostini to backup (typically ~ 2 mins)")
	if err := tconn.Call(ctx, nil, "tast.promisify(chrome.autotestPrivate.exportCrostini)", "backup.tar.gz"); err != nil {
		s.Fatal("Running autotestPrivate.exportCrostini failed: ", err)
	}
	defer os.Remove(filepath.Join("/home/user", ownerID, "Downloads/backup.tar.gz"))

	// Delete the test file in the container.
	if err := crostini.RemoveContainerFile(ctx, cont, testFileName); err != nil {
		s.Fatalf("Failed to delete file %v in container: %v", testFileName, err)
	}
	if err := crostini.VerifyFileNotInContainer(ctx, cont, testFileName); err != nil {
		s.Errorf("File %v unexpectedly exists", testFileName)
	}

	// Restore the container and verify that the file is back.
	s.Log("Waiting for crostini to restore (typically ~ 1 min)")
	if err := tconn.Call(ctx, nil, "tast.promisify(chrome.autotestPrivate.importCrostini)", "backup.tar.gz"); err != nil {
		s.Fatal("Running autotestPrivate.importCrostini failed: ", err)
	}

	if err := cont.CheckFileContent(ctx, testFileName, testFileContent); err != nil {
		s.Fatalf("Wrong file content for %v: %v", testFileContent, err)
	}
}
