// Copyright 2021 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package crostini

import (
	"context"
	"path/filepath"
	"time"

	"chromiumos/tast/common/policy"
	"chromiumos/tast/common/policy/fakedms"
	"chromiumos/tast/errors"
	"chromiumos/tast/local/chrome"
	"chromiumos/tast/local/chrome/uiauto"
	"chromiumos/tast/local/chrome/uiauto/faillog"
	"chromiumos/tast/local/crostini"
	"chromiumos/tast/local/input"
	"chromiumos/tast/local/policyutil"
	"chromiumos/tast/testing"
)

const (
	// pasteApplet is the data dependency needed to run a paste operation.
	pasteAppletDLP      = "paste_applet.py"
	pasteAppletTitleDLP = "gtk3_paste_demo"
)

// DLPPasteConfig holds the configuration for the paste half of the test.
type pasteDLPConfig struct {
	gdkBackend string
	cmdArgs    []string
}

// x11DLPPasteConfig is the configuration needed to test pasting into
// a x11 application.
var x11DLPPasteConfig = &pasteDLPConfig{
	gdkBackend: "x11",
	cmdArgs:    []string{"env", "GDK_BACKEND=x11", "python3", pasteAppletDLP},
}

// testDLPParameters contains all the data needed to run a single test iteration.
type testDLPParameters struct {
	Paste *pasteDLPConfig
}

func init() {

	testing.AddTest(&testing.Test{
		Func:         DataLeakPreventionClipboardCrostini,
		Desc:         "Test behavior of DataLeakPreventionRulesList policy with clipboard blocked restriction on Crostini",
		Contacts:     []string{"vishal38785@gmail.com", "cros-containers-dev@google.com"},
		Attr:         []string{"group:mainline", "informational"},
		Vars:         []string{"keepState"},
		VarDeps:      []string{"ui.gaiaPoolDefault"},
		Data:         []string{pasteAppletDLP},
		SoftwareDeps: []string{"chrome", "vm_host"},
		Params: []testing.Param{
			// Parameters generated by copy_paste_test.go. DO NOT EDIT.
			{
				Name:              "to_x11_stretch_stable",
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("stretch", false), crostini.GetContainerRootfsArtifact("stretch", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniStable,
				Pre:               crostini.StartedByDlcStretch(),
				Timeout:           7 * time.Minute,
				Val: testDLPParameters{
					Paste: x11DLPPasteConfig,
				},
			}, {
				Name:              "to_x11_stretch_unstable",
				ExtraAttr:         []string{"informational"},
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("stretch", false), crostini.GetContainerRootfsArtifact("stretch", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniUnstable,
				Pre:               crostini.StartedByDlcStretch(),
				Timeout:           7 * time.Minute,
				Val: testDLPParameters{
					Paste: x11DLPPasteConfig,
				},
			}, {
				Name:              "to_x11_buster_stable",
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("buster", false), crostini.GetContainerRootfsArtifact("buster", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniStable,
				Pre:               crostini.StartedByDlcBuster(),
				Timeout:           7 * time.Minute,
				Val: testDLPParameters{
					Paste: x11DLPPasteConfig,
				},
			}, {
				Name:              "to_x11_buster_unstable",
				ExtraAttr:         []string{"informational"},
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("buster", false), crostini.GetContainerRootfsArtifact("buster", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniUnstable,
				Pre:               crostini.StartedByDlcBuster(),
				Timeout:           7 * time.Minute,
				Val: testDLPParameters{
					Paste: x11DLPPasteConfig,
				},
			}, {
				Name:              "to_x11_bullseye_stable",
				ExtraAttr:         []string{"informational"},
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("bullseye", false), crostini.GetContainerRootfsArtifact("bullseye", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniStable,
				Pre:               crostini.StartedByDlcBullseye(),
				Timeout:           7 * time.Minute,
				Val: testDLPParameters{
					Paste: x11DLPPasteConfig,
				},
			}, {
				Name:              "to_x11_bullseye_unstable",
				ExtraAttr:         []string{"informational"},
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("bullseye", false), crostini.GetContainerRootfsArtifact("bullseye", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniUnstable,
				Pre:               crostini.StartedByDlcBullseye(),
				Timeout:           7 * time.Minute,
				Val: testDLPParameters{
					Paste: x11DLPPasteConfig,
				},
			},
		},
	})
}

func DataLeakPreventionClipboardCrostini(ctx context.Context, s *testing.State) {
	pre := s.PreValue().(crostini.PreData)
	param := s.Param().(testDLPParameters)
	tconn := pre.TestAPIConn
	cont := pre.Container
	cr := pre.Chrome
	defer crostini.RunCrostiniPostTest(ctx, s.PreValue().(crostini.PreData))

	policyDLP := []policy.Policy{&policy.DataLeakPreventionRulesList{
		Val: []*policy.DataLeakPreventionRulesListValue{
			{
				Name:        "Disable copy and paste of confidential content from site to ARC",
				Description: "User should not be able to copy and paste confidential content from site to ARC",
				Sources: &policy.DataLeakPreventionRulesListSources{
					Urls: []string{
						"example.com",
					},
				},
				Destinations: &policy.DataLeakPreventionRulesListDestinations{
					Urls: []string{
						"*",
					},
				},
				Restrictions: []*policy.DataLeakPreventionRulesListRestrictions{
					{
						Class: "CLIPBOARD",
						Level: "BLOCK",
					},
				},
			},
		},
	},
	}

	fdms, err := fakedms.New(ctx, s.OutDir())
	if err != nil {
		s.Fatal("Failed to start FakeDMS: ", err)
	}
	defer fdms.Stop(ctx)

	if err := policyutil.ResetChrome(ctx, fdms, cr); err != nil {
		s.Fatal("Failed to serve policies: ", err)
	}

	// Update the policy blob.
	pb := fakedms.NewPolicyBlob()
	pb.AddPolicies(policyDLP)

	// Update policy.
	if err := policyutil.ServeBlobAndRefresh(ctx, fdms, cr, pb); err != nil {
		s.Fatal("Failed to serve and refresh: ", err)
	}

	s.Log("Copying testing applets to container")
	if err := cont.PushFile(ctx, s.DataPath(pasteAppletDLP), pasteAppletDLP); err != nil {
		s.Fatal("Failed to push paste applet to container: ", err)
	}
	keyboard, err := input.VirtualKeyboard(ctx)
	if err != nil {
		s.Fatal("Failed to get keyboard: ", err)
	}
	defer keyboard.Close()

	screenRecorder, err := uiauto.NewScreenRecorder(ctx, tconn)
	if err != nil {
		s.Fatal("Failed to create ScreenRecorder: ", err)
	}
	if screenRecorder == nil {
		s.Fatal("Screen recorder was not found")
	}
	defer uiauto.ScreenRecorderStopSaveRelease(ctx, screenRecorder, filepath.Join(s.OutDir(), "dlpScreenShare.mp4"))
	screenRecorder.Start(ctx, tconn)

	for _, paramDLP := range []struct {
		name        string
		copyAllowed bool
		url         string
	}{
		{
			name:        "example",
			copyAllowed: false,
			url:         "https://www.example.com/",
		},
		{
			name:        "chromium",
			copyAllowed: true,
			url:         "https://www.chromium.org/",
		},
	} {
		s.Run(ctx, paramDLP.name, func(ctx context.Context, s *testing.State) {
			defer faillog.DumpUITreeWithScreenshotOnError(ctx, s.OutDir(), s.HasError, cr, "ui_tree_"+paramDLP.name)

			conn, err := cr.NewConn(ctx, paramDLP.url)
			if err != nil {
				s.Fatal("Failed to open a blocker: ", err)
			}
			defer conn.Close()

			if err := keyboard.Accel(ctx, "Ctrl+A"); err != nil {
				s.Fatal("Failed to press Ctrl+A to select all content: ", err)
			}

			if err := keyboard.Accel(ctx, "Ctrl+C"); err != nil {
				s.Fatal("Failed to press Ctrl+C to copy content: ", err)
			}

			copiedString, err := dlpText(ctx, tconn)
			if err != nil {
				s.Fatal("Failed to get clipboard content: ", err)
			}
			s.Log(copiedString)

			if err := keyboard.Accel(ctx, "Ctrl+T"); err != nil {
				s.Fatal("Failed to press Ctrl+T to open new tab: ", err)
			}

			if err := keyboard.Accel(ctx, "Ctrl+V"); err != nil {
				s.Fatal("Failed to press Ctrl+V to paste content: ", err)
			}

			output, err := crostini.RunWindowedApp(ctx, tconn, cont, pre.Keyboard, 30*time.Second, nil, false, pasteAppletTitleDLP, param.Paste.cmdArgs)
			if err != nil {
				s.Fatal("Failed to run paste application: ", err)
			}

			if copiedString == output && !paramDLP.copyAllowed {
				s.Fatalf("Crostini able to access content, got %v want None ", output)
			}

		})
	}
}

func dlpText(ctx context.Context, tconn *chrome.TestConn) (string, error) {
	var clipData string
	if err := tconn.Eval(ctx, `tast.promisify(chrome.autotestPrivate.getClipboardTextData)()`, &clipData); err != nil {
		return "", errors.Wrap(err, "failed to get clipboard content: ")
	}
	return clipData, nil
}
