// Copyright 2021 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package crostini

import (
	"context"
	"time"

	"chromiumos/tast/errors"
	"chromiumos/tast/local/chrome"
	"chromiumos/tast/local/chrome/uiauto"
	"chromiumos/tast/local/chrome/uiauto/nodewith"
	"chromiumos/tast/local/chrome/uiauto/restriction"
	"chromiumos/tast/local/chrome/uiauto/role"
	"chromiumos/tast/local/crostini"
	cui "chromiumos/tast/local/crostini/ui"
	"chromiumos/tast/local/crostini/ui/settings"
	"chromiumos/tast/testing"
)

/*
   We try to normalize the default username by:
   - Truncating to 32 characters
   - Converting to lowercase
   - Stripping periods

   After that, it can still be invalid if:
   - It is one of the reserved usernames (e.g. "root")
   - If it starts with something other then a letter or underscore
   - If it contains characters other then letters, digits, underscores, and hyphens.
*/

var validTestCases = map[string]string{
	// Short valid name
	"tester00": "tester00",

	// 32 characters long (maximum length without truncation)
	"_123456789012345678901234567890-": "_123456789012345678901234567890-",

	// Long names are truncated
	"somebodywithreaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaallyname": "somebodywithreaaaaaaaaaaaaaaaaaa",

	// Capital letters are converted to lowercase
	"ALL_UPPER_CASE": "all_upper_case",

	// Periods are stripped
	"test.user": "testuser",
}

var invalidTestCases = map[string]string{
	// Invalid reserved name
	"root": "root",

	// Invalid characters other then capital letters and periods
	// are preserved. We do not test extra @-signs here. While
	// the email address RFC technically allows it we can hope no
	// one will actually do it.
	"!\"#$%&'()*+,/ :;<=>?[\\]^`{|}~": "!\"#$%&'()*+,/ :;<=>?[\\]^`{|}~",
}

var domains = []string{
	"@gmail.com",
	"@managedchrome.com",
}

func init() {
	testing.AddTest(&testing.Test{
		Func:         CheckDefaultUsername,
		Desc:         "Test the default container username is computed correctly",
		Contacts:     []string{"sidereal@google.com", "cros-containers-dev@google.com"},
		Attr:         []string{"group:mainline", "informational"},
		SoftwareDeps: []string{"chrome", "vm_host"},
		Params: []testing.Param{
			// Parameters generated by check_default_username_test.go. DO NOT EDIT.
			{
				Name:              "stable",
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("buster", false), crostini.GetContainerRootfsArtifact("buster", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniStable,
				Timeout:           7 * time.Minute,
			}, {
				Name:              "unstable",
				ExtraAttr:         []string{"informational"},
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("buster", false), crostini.GetContainerRootfsArtifact("buster", false)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniUnstable,
				Timeout:           7 * time.Minute,
			},
		},
	})
}

func CheckDefaultUsername(ctx context.Context, s *testing.State) {
	for _, domain := range domains {
		for name, containerUsername := range validTestCases {
			email := name + domain

			s.Run(ctx, email, func(ctx context.Context, s *testing.State) {
				err := runTestCase(ctx, email, containerUsername, true)
				if err != nil {
					s.Fatal("Failed valid subtest: ", err)
				}
			})
		}

		for name, containerUsername := range invalidTestCases {
			email := name + domain

			s.Run(ctx, email, func(ctx context.Context, s *testing.State) {
				err := runTestCase(ctx, email, containerUsername, false)
				if err != nil {
					s.Fatal("Failed invalid subtest: ", err)
				}
			})
		}
	}
}

func runTestCase(ctx context.Context, email, containerUsername string, canInstall bool) error {
	cr, err := chrome.New(ctx,
		chrome.FakeLogin(chrome.Creds{User: email}))
	if err != nil {
		return errors.Wrap(err, "failed to start Chrome")
	}
	defer cr.Close(ctx)

	tconn, err := cr.TestAPIConn(ctx)
	if err != nil {
		return errors.Wrap(err, "failed to create test API connection")
	}

	if err := settings.OpenInstaller(ctx, tconn, cr); err != nil {
		return errors.Wrap(err, "failed to open Crostini installer")
	}

	ui := uiauto.New(tconn)

	userNameField := nodewith.Name("Username").Role(role.TextField).Ancestor(cui.InstallWindow)
	installButton := nodewith.Name("Install").Role(role.Button)

	// alertNode is the node for error message when the input user
	// name is invalid.  The node does not exist if the user name
	// is valid.
	alertNode := nodewith.Role(role.Alert).Ancestor(cui.InstallWindow)

	userNameCheck := ui.WaitUntilExists(nodewith.Name(containerUsername).Role(role.StaticText).Ancestor(userNameField))

	var alertCheck, installButtonCheck uiauto.Action
	if canInstall {
		alertCheck = ui.Gone(alertNode)
		installButtonCheck = ui.CheckRestriction(installButton, restriction.None)
	} else {
		alertCheck = ui.Exists(alertNode)
		installButtonCheck = ui.CheckRestriction(installButton, restriction.Disabled)
	}

	if err := uiauto.Combine("check user name",
		userNameCheck,
		alertCheck,
		installButtonCheck,
	)(ctx); err != nil {
		return errors.Wrap(err, "failed to check user")
	}

	return nil
}
