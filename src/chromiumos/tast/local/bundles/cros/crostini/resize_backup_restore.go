// Copyright 2021 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package crostini

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"chromiumos/tast/local/chrome/ash"
	"chromiumos/tast/local/chrome/uiauto"
	"chromiumos/tast/local/crostini"
	"chromiumos/tast/local/crostini/faillog"
	"chromiumos/tast/local/crostini/ui/settings"
	"chromiumos/tast/local/crostini/ui/terminalapp"
	"chromiumos/tast/local/cryptohome"
	"chromiumos/tast/local/vm"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         ResizeBackupRestore,
		LacrosStatus: testing.LacrosVariantUnneeded,
		Desc:         "Test resizing disk of Crostini from the Settings app between backup and restore",
		Contacts:     []string{"nverne@google.com", "clumptini@google.com"},
		Attr:         []string{"group:mainline", "informational"},
		SoftwareDeps: []string{"chrome", "vm_host"},
		Params: []testing.Param{
			// Parameters generated by params_test.go. DO NOT EDIT.
			{
				Name:              "stable",
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniStable,
				Fixture:           "crostiniBusterRestart",
				Timeout:           15 * time.Minute,
			}, {
				Name:              "unstable",
				ExtraAttr:         []string{"informational"},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniUnstable,
				Fixture:           "crostiniBusterRestart",
				Timeout:           15 * time.Minute,
			},
		},
	})
}

func ResizeBackupRestore(ctx context.Context, s *testing.State) {
	pre := s.FixtValue().(crostini.FixtureData)
	cr := pre.Chrome
	tconn := pre.Tconn
	keyboard := pre.KB
	cont := pre.Cont

	ownerID, err := cryptohome.UserHash(ctx, cr.NormalizedUser())
	if err != nil {
		s.Fatal("Failed to get user hash: ", err)
	}

	// Shrink the container to save time in the test.
	if err = vm.ShrinkDefaultContainer(ctx, ownerID); err != nil {
		s.Fatal("Failed to shrink container for backup: ", err)
	}

	userName := strings.Split(cr.NormalizedUser(), "@")[0]

	runInTerminal := func(cmd, outputFile string) error {
		var terminalApp *terminalapp.TerminalApp
		// Try to find Terminal app first.
		if terminalApp, err = terminalapp.Find(ctx, tconn); err != nil {
			// Failed to find the Terminal app. Try to open the Terminal app.
			terminalApp, err = terminalapp.Launch(ctx, tconn)
			if err != nil {
				s.Fatal("Failed to open Terminal app: ", err)
			}
		} else {
			if _, err = ash.BringWindowToForeground(ctx, tconn, fmt.Sprintf("Terminal - %s@penguin: ~", userName)); err != nil {
				s.Fatal("Failed to bring the Terminal app to the front: ", err)
			}
		}

		return uiauto.Combine("running '"+cmd+"'",
			terminalApp.RunCommand(keyboard, fmt.Sprintf("%s > %s 2>&1", cmd, outputFile)),
			terminalApp.WaitForPrompt())(ctx)
	}

	checksumFiles := func(outputFile string) error {
		const md5cmd = "for d in /home /etc /usr; do echo $d; sudo find $d -type f -a '!' -name '.*' -exec md5sum {} + | LC_ALL=c sort | md5sum; done"
		return runInTerminal(md5cmd, outputFile)
	}

	const (
		backupFileBaseName = "test-backup"
		backupFileName     = backupFileBaseName + ".tini"
		existingFile       = "./existing.txt"
		existingFileStr    = "This file should be captured in the checksum, deleted after backup, then restored."
		checksumPreFile    = "/tmp/checksum_pre.txt"
		checksumPostFile   = "/tmp/checksum_post.txt"
	)
	var checksumPreStr, checksumPostStr string

	if err = cont.WriteFile(ctx, existingFile, existingFileStr); err != nil {
		s.Fatalf("Failed to write file %s: %v", existingFile, err)
	}
	// Run checksumFiles, output is used to verify restore later.
	if err = checksumFiles(checksumPreFile); err != nil {
		s.Fatal("Failed to run command in Terminal window: ", err)
	}
	checksumPreStr, err = cont.ReadFile(ctx, checksumPreFile)
	if err != nil {
		s.Fatalf("Failed to read checksum output file %s: %v", checksumPreFile, err)
	}
	s.Log("Pre checksum\n" + checksumPreStr)
	// Back up container through settings.
	// Open the Linux settings.
	st, err := settings.OpenLinuxSettings(ctx, tconn, cr, "Backup & restore")
	if err != nil {
		s.Fatal("Failed to open Linux Settings Backup & restore: ", err)
	}

	defer func() { faillog.DumpUITreeAndScreenshot(ctx, tconn, "resize_backup_restore", err) }()

	if err = st.LeftClickUI(settings.BackupButton)(ctx); err != nil {
		s.Fatal("Failed to click Backup button: ", err)
	}
	// Set filename.
	if err = st.WaitForUI(settings.BackupFileWindow)(ctx); err != nil {
		s.Fatal("Failed to see Backup File dialog: ", err)
	}
	// Wait for backup complete.
	uiauto.Sleep(time.Second)(ctx) // Pause needed so keyboard events are received.

	if err = keyboard.TypeAction(backupFileBaseName)(ctx); err != nil {
		s.Fatalf("Failed to enter backup name %s: %v", backupFileBaseName, err)
	}
	if err = st.LeftClickUI(settings.BackupSave)(ctx); err != nil {
		s.Fatal("Failed to left click backup Save button: ", err)
	}

	myFilesPath, err := cryptohome.MyFilesPath(ctx, cr.NormalizedUser())
	if err != nil {
		s.Fatal("Failed to get users MyFiles path: ", err)
	}

	ui := uiauto.New(tconn)
	if err = ui.WithTimeout(5 * time.Minute).WaitUntilExists(settings.BackupNotification)(ctx); err != nil {
		s.Fatal("Backup complete notification not found: ", err)
	}

	backupFilePath := filepath.Join(myFilesPath, backupFileName)
	defer os.Remove(backupFilePath)

	// Log a listing of dir.
	logFiles := func(dir string) {
		const lslRFile = "/tmp/lslR.txt"
		if err = runInTerminal("sudo ls -lR "+dir, lslRFile); err != nil {
			s.Fatal("Failed to ls -lR in container: ", err)
		}
		var lslR string
		if lslR, err = cont.ReadFile(ctx, lslRFile); err != nil {
			s.Fatal("Failed to read lslR file: ", err)
		}
		s.Log(lslR)
	}

	logFiles("/home /tmp")

	// Delete existingFile. This means if our restore was a no-op we'll fail
	// later when we use this file to verify the backup integrity.
	if err = cont.RemoveAll(ctx, existingFile); err != nil {
		s.Fatalf("Failed to remove %s from container: %v", existingFile, err)
	}

	// Resize container disk.
	// Refocus (or open) Linux settings.
	st, err = settings.OpenLinuxSettings(ctx, tconn, cr)
	if err != nil {
		s.Fatal("Failed to open Linux Settings: ", err)
	}
	const targetDiskSizeBytes uint64 = 6 << 30
	if _, _, err = st.Resize(ctx, targetDiskSizeBytes); err != nil {
		s.Fatal("Failed to resize disk: ", err)
	}

	// Restore container.
	// Refocus (or open) Linux settings.
	st, err = settings.OpenLinuxSettings(ctx, tconn, cr, "Backup & restore")
	if err != nil {
		s.Fatal("Failed to open Linux Settings Backup & restore: ", err)
	}
	if err = st.LeftClickUI(settings.RestoreButton)(ctx); err != nil {
		s.Fatal("Failed to click Restore button: ", err)
	}
	if err = st.WaitForUI(settings.RestoreConfirmButton)(ctx); err != nil {
		s.Fatal("Failed to find Confirm Restore dialog and button: ", err)
	}
	if err = st.LeftClickUI(settings.RestoreConfirmButton)(ctx); err != nil {
		s.Fatal("Failed to click confirm restore action button: ", err)
	}

	// Click on .tini file
	if err = st.WaitForUI(settings.RestoreFileWindow)(ctx); err != nil {
		s.Fatal("Failed to find Restore file window: ", err)
	}
	if err = ui.LeftClick(settings.RestoreTiniFile)(ctx); err != nil {
		s.Fatal("Failed to find .tini in file list: ", err)
	}
	// Don't want to unfocus the .tini file here, so just use a raw LeftClick.
	if err = ui.LeftClick(settings.RestoreOpen)(ctx); err != nil {
		s.Fatal("Failed to click Open button in Restore file window: ", err)
	}
	if err = ui.WithTimeout(5 * time.Minute).WaitUntilExists(settings.RestoreNotification)(ctx); err != nil {
		s.Fatal("Restore complete notification not found: ", err)
	}

	// Write post checksum. This will incidentally restart Linux, which is needed
	// after restore.
	if err = checksumFiles(checksumPostFile); err != nil {
		s.Fatal("Failed to run command in Terminal window: ", err)
	}
	checksumPostStr, err = cont.ReadFile(ctx, checksumPostFile)
	if err != nil {
		s.Fatalf("Failed to read checksum output file %s: %v", checksumPostFile, err)
	}
	s.Log("Post checksum\n" + checksumPostStr)
	logFiles("/home /tmp")

	if err = cont.CheckFileContent(ctx, existingFile, existingFileStr); err != nil {
		s.Fatal("Failed to verify existingFile: ", err)
	}

	// Verify pre and post checksums are the same.
	if checksumPreStr != checksumPostStr {
		s.Fatalf("Failed to verify, got %s, want %s", checksumPostStr, checksumPreStr)
	}
}
