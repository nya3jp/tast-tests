// Copyright 2022 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package crostini

import (
	"context"
	"io/ioutil"
	"os"
	"regexp"
	"strings"
	"time"

	"chromiumos/tast/ctxutil"
	"chromiumos/tast/local/chrome/uiauto"
	"chromiumos/tast/local/chrome/uiauto/faillog"
	"chromiumos/tast/local/chrome/uiauto/filesapp"
	"chromiumos/tast/local/chrome/uiauto/nodewith"
	"chromiumos/tast/local/chrome/uiauto/role"
	"chromiumos/tast/local/crostini"
	"chromiumos/tast/local/crostini/ui/terminalapp"
	"chromiumos/tast/local/input"
	"chromiumos/tast/local/uidetection"
	"chromiumos/tast/testing"
)

const (
	crostiniMountPath                = "/mnt/chromeos/MyFiles/Downloads"
	tmpFilename                      = "testfile.txt"
	tmpFileCrosFilepath              = "/home/chronos/user/Downloads/" + tmpFilename
	tmpString                        = "This is a text string in a text file in the Downloads folder."
	geditContextMenuItem             = "Open with Text Editor"
	defaultTextEditorContextMenuItem = "Text (default)"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         AppGeditFilesharing,
		LacrosStatus: testing.LacrosVariantUnknown,
		Desc:         "Test gedit in Terminal window",
		Contacts:     []string{"jinrongwu@google.com", "zubinpratap@google.com", "cros-containers-dev@google.com"},
		Attr:         []string{"group:mainline", "informational"},
		Vars:         []string{"keepState", "ui.gaiaPoolDefault"},
		SoftwareDeps: []string{"chrome", "vm_host"},
		Params: []testing.Param{
			// Parameters generated by params_test.go. DO NOT EDIT.
			{
				ExtraData:         []string{crostini.GetContainerMetadataArtifact("buster", true), crostini.GetContainerRootfsArtifact("buster", true)},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniAppTest,
				Pre:               crostini.StartedByDlcBusterLargeContainer(),
				Timeout:           15 * time.Minute,
			},
		},
	})
}

func AppGeditFilesharing(ctx context.Context, s *testing.State) {
	tconn := s.PreValue().(crostini.PreData).TestAPIConn
	cr := s.PreValue().(crostini.PreData).Chrome
	keyboard := s.PreValue().(crostini.PreData).Keyboard
	cont := s.PreValue().(crostini.PreData).Container

	// Use a shortened context for test operations to reserve time for cleanup.
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, crostini.PostTimeout)
	defer cancel()
	defer crostini.RunCrostiniPostTest(ctx, s.PreValue().(crostini.PreData))
	defer func(ctx context.Context) {
		if err := os.Remove(tmpFileCrosFilepath); err != nil {
			s.Logf("Cleanup: failed to remove file %s on cleanup: %v", tmpFileCrosFilepath, err)
		}
	}(cleanupCtx)

	defer faillog.DumpUITreeOnError(cleanupCtx, s.OutDir(), s.HasError, tconn)

	// Create a temp text file in the /Downloads folder to use in this test.
	if err := ioutil.WriteFile(tmpFileCrosFilepath, []byte(tmpString), 0644); err != nil {
		s.Fatal("Failed to create text file in Downloads folder: ", err)
	}

	filesApp, err := filesapp.Launch(ctx, tconn)
	if err != nil {
		s.Fatal("Failed to open Files app: ", err)
	}
	defer filesApp.Close(cleanupCtx)

	err = filesApp.OpenDownloads()(ctx)
	if err != nil {
		s.Fatal("Failed to open Downloads folder in Files App: ", err)
	}

	// Open with Gedit.
	err = filesApp.ClickContextMenuItem(tmpFilename, filesapp.OpenWith, geditContextMenuItem)(ctx)
	if err != nil {
		s.Fatal("Failed to click on temp files context menu to open with gEdit: ", err)
	}

	// Launch terminal so we can run commands in the container.
	terminalApp, err := terminalapp.Launch(ctx, tconn)
	if err != nil {
		s.Fatal("Failed to open Crostini Terminal: ", err)
	}

	// Restart crostini in the end in case any error in the middle and gedit is not closed.
	// This also closes the Terminal window.
	restartIfError := true
	defer func() {
		if restartIfError {
			if err := terminalApp.RestartCrostini(keyboard, cont, cr.NormalizedUser())(cleanupCtx); err != nil {
				s.Log("Failed to restart crostini: ", err)
			}
		}
	}()

	// Check that file is mounted in the container.
	if err = crostini.VerifyFileInContainer(ctx, cont, crostiniMountPath+"/"+tmpFilename); err != nil {
		s.Fatal("Temp file missing from crostini container: ", err)
	}

	// Bring Gedit into focus and close it.
	geditWindow := nodewith.NameContaining(tmpFilename).Role(role.Window).First()
	ui := uiauto.New(tconn)

	closeGedit(ctx, keyboard, ui, geditWindow, s)

	// Check file remains mounted in container.
	if err = crostini.VerifyFileInContainer(ctx, cont, crostiniMountPath+"/"+tmpFilename); err != nil {
		s.Fatal("Temp file missing from crostini container after linux app is shut down and before VM rebooted: ", err)
	}

	ud := uidetection.NewDefault(tconn)
	filesAppIcon := nodewith.Name("Files").Role(role.Button).First()

	// Bring Files app to foreground, open the file with non-linux (default) text app, validate file contents.
	err = uiauto.Combine("Open text file with default non-linux app",
		ui.LeftClick(filesAppIcon),

		filesApp.ClickContextMenuItem(tmpFilename, filesapp.OpenWith, defaultTextEditorContextMenuItem),
		ud.WaitUntilExists(uidetection.TextBlock(strings.Split(tmpString, " "))),
	)(ctx)
	if err != nil {
		s.Fatal("Failed to right click in Downloads folder and open file with default Text app: ", err)
	}

	// Restart Crostini. This will start linux and the terminal and then close the terminal, but not Linux.
	if err := terminalApp.RestartCrostini(keyboard, cont, cr.NormalizedUser())(cleanupCtx); err != nil {
		s.Log("Failed to restart Crostini: ", err)
	}

	restartIfError = false

	// Check that file is no longer mounted in the container after Linux is restarted.
	if err = crostini.VerifyFileNotInContainer(ctx, cont, crostiniMountPath+"/"+tmpFilename); err != nil {
		s.Fatal("Temp file missing from crostini container: ", err)
	}

	// Close non-linux text app. Re-open file with Gedit and validate contents.
	err = uiauto.Combine("click menu item on the Shelf",
		ui.RightClick(nodewith.Name("Text").Role(role.Button).First()),
		ui.LeftClick(nodewith.NameRegex(regexp.MustCompile("Close")).Role(role.MenuItem)),

		filesApp.OpenDownloads(),
		filesApp.ClickContextMenuItem(tmpFilename, filesapp.OpenWith, geditContextMenuItem),
		ud.WaitUntilExists(uidetection.TextBlock(strings.Split(tmpString, " "))),
	)(ctx)
	if err != nil {
		s.Fatal("Failed to close the Text app and re-open Gedit to check contents: ", err)
	}

	closeGedit(ctx, keyboard, ui, geditWindow, s)
}

func closeGedit(ctx context.Context, keyboard *input.KeyboardEventWriter, ui *uiauto.Context, geditWindow *nodewith.Finder, s *testing.State) {
	err := uiauto.Combine("Close out of Gedit",
		// Focus on the Gedit window and input string.
		ui.LeftClick(geditWindow),
		// Close out of Gedit.
		keyboard.AccelAction("ctrl+W"),
		keyboard.AccelAction("ctrl+W"),
	)(ctx)

	if err != nil {
		s.Fatal("Failed to close out of Gedit: ", err)
	}
}
