// Copyright 2021 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package crostini

import (
	"context"
	"regexp"
	"time"

	"chromiumos/tast/errors"
	"chromiumos/tast/local/chrome"
	"chromiumos/tast/local/chrome/uiauto"
	"chromiumos/tast/local/chrome/uiauto/launcher"
	"chromiumos/tast/local/chrome/uiauto/nodewith"
	"chromiumos/tast/local/chrome/uiauto/role"
	"chromiumos/tast/local/crostini"
	"chromiumos/tast/local/crostini/ui/terminalapp"
	"chromiumos/tast/local/input"
	"chromiumos/tast/local/uidetection"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         RestartApp,
		LacrosStatus: testing.LacrosVariantUnneeded,
		Desc:         "Test restarting Crostini by launching a linux app",
		Contacts:     []string{"clumptini+oncall@google.com"},
		Attr:         []string{"group:mainline"},
		SoftwareDeps: []string{"chrome", "vm_host"},
		Params: []testing.Param{
			// Parameters generated by params_test.go. DO NOT EDIT.
			{
				Name:              "tablet_stable",
				ExtraAttr:         []string{"informational"},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniAppStable,
				Fixture:           "crostiniBullseyeLargeContainerTablet",
				Timeout:           15 * time.Minute,
			}, {
				Name:              "tablet_unstable",
				ExtraAttr:         []string{"informational"},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniAppUnstable,
				Fixture:           "crostiniBullseyeLargeContainerTablet",
				Timeout:           15 * time.Minute,
			}, {
				Name:              "clamshell_stable",
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniAppStable,
				Fixture:           "crostiniBullseyeLargeContainerClamshell",
				Timeout:           15 * time.Minute,
			}, {
				Name:              "clamshell_unstable",
				ExtraAttr:         []string{"informational"},
				ExtraSoftwareDeps: []string{"dlc"},
				ExtraHardwareDeps: crostini.CrostiniAppUnstable,
				Fixture:           "crostiniBullseyeLargeContainerClamshell",
				Timeout:           15 * time.Minute,
			},
		},
	})
}
func RestartApp(ctx context.Context, s *testing.State) {
	tconn := s.FixtValue().(crostini.FixtureData).Tconn
	keyboard := s.FixtValue().(crostini.FixtureData).KB
	cont := s.FixtValue().(crostini.FixtureData).Cont

	terminalApp, err := terminalapp.Launch(ctx, tconn)
	if err != nil {
		s.Fatal("Failed to launch terminal: ", err)
	}

	if err := terminalApp.ShutdownCrostini(cont)(ctx); err != nil {
		s.Fatal("Failed to shutdown crostini: ", err)
	}

	// Launch gedit.
	if err := launchGedit(ctx, keyboard, tconn); err != nil {
		s.Fatal("Failed to launch gedit after shutdown Crostini: ", err)
	}
}

func launchGedit(ctx context.Context, keyboard *input.KeyboardEventWriter, tconn *chrome.TestConn) error {
	if err := launcher.SearchAndLaunchWithQuery(tconn, keyboard, "t", "Text Editor")(ctx); err != nil {
		return errors.Wrap(err, "failed to launch gedit")
	}

	ui := uiauto.New(tconn)
	ud := uidetection.NewDefault(tconn)
	appWindow := nodewith.NameRegex(regexp.MustCompile(`.* - gedit`)).Role(role.Window).First()
	const crostiniRestartTimeout = 2 * time.Minute
	return uiauto.Combine("click and close Gedit",
		// Gedit window takes a lot of time to appear because it has to restart Crostini.
		ui.WithTimeout(crostiniRestartTimeout).WaitUntilExists(appWindow),
		// Indicator of Gedit being launched.
		ud.WaitUntilExists(uidetection.Word("Open").WithinA11yNode(appWindow)),
		// Focus on the Gedit window.
		ui.LeftClick(appWindow),

		// Press ctrl+W twice to exit window.
		keyboard.AccelAction("ctrl+W"),
		keyboard.AccelAction("ctrl+W"),

		// Check window close.
		ui.WaitUntilGone(appWindow))(ctx)
}
