// Copyright 2022 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package network

import (
	"context"
	"encoding/hex"
	"fmt"
	"math/rand"
	"net"
	"os/user"
	"strconv"
	"strings"
	"syscall"
	"time"

	pp "chromiumos/system_api/patchpanel_proto"
	"chromiumos/tast/common/shillconst"
	"chromiumos/tast/common/testexec"
	"chromiumos/tast/ctxutil"
	"chromiumos/tast/errors"
	patchpanel "chromiumos/tast/local/network/patchpanel_client"
	"chromiumos/tast/local/network/virtualnet"
	"chromiumos/tast/local/network/virtualnet/env"
	"chromiumos/tast/local/network/virtualnet/subnet"
	"chromiumos/tast/local/network/virtualnet/udpserver"
	"chromiumos/tast/local/shill"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         TrafficCounters,
		Desc:         "Verify patchpanel traffic counters",
		Contacts:     []string{"cros-networking@google.com"},
		Attr:         []string{"group:mainline", "informational"},
		LacrosStatus: testing.LacrosVariantUnneeded,
	})
}

type config struct {
	rt   *env.Env
	fam  string
	port int
	addr net.IP
}

type counters struct {
	tx, rx uint64
}

// TrafficCounters verifies the patchpanel TrafficCounter API and behavior
// for network traffic generated by certain user IDs. It does not currently
// verify traffic marked via additional mechanisms.
func TrafficCounters(ctx context.Context, s *testing.State) {
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, 5*time.Second)
	defer cancel()

	mgr, err := shill.NewManager(ctx)
	if err != nil {
		s.Fatal("Failed to create manager proxy: ", err)
	}
	if err := mgr.SetProperty(ctx, shillconst.ProfilePropertyCheckPortalList, "wifi,cellular"); err != nil {
		s.Fatal("Failed to disable portal detection on ethernet: ", err)
	}

	pool := subnet.NewPool()
	var (
		devices []string
		cfgs    []*config
	)
	cfg, err := setup(ctx, mgr, pool, "udp4")
	if err != nil {
		s.Fatal("Failed to setup router: ", err)
	}
	cfgs = append(cfgs, cfg)
	devices = append(devices, cfg.rt.VethOutName)
	defer cfg.cleanup(cleanupCtx)
	if cfg, err = setup(ctx, mgr, pool, "udp6"); err != nil {
		s.Fatal("Failed to setup router: ", err)
	}
	cfgs = append(cfgs, cfg)
	devices = append(devices, cfg.rt.VethOutName)
	defer cfg.cleanup(cleanupCtx)

	pc, err := patchpanel.New(ctx)
	if err != nil {
		s.Fatal("Failed to create patchpanel client: ", err)
	}

	// Grab the current counters for our interfaces.

	resp, err := pc.GetTrafficCounters(ctx, devices)
	if err != nil {
		s.Fatal("Failed to get traffic counters: ", err)
	}

	key := func(dev string, src pp.TrafficCounter_Source, fam pp.TrafficCounter_IpFamily) string {
		return fmt.Sprintf("%v:%v:%v", dev, src.String(), fam.String())
	}
	users := map[pp.TrafficCounter_Source]string{
		pp.TrafficCounter_SYSTEM: "kerberosd",
		pp.TrafficCounter_USER:   "debugd",
		pp.TrafficCounter_CHROME: "chronos",
	}

	b := make([]byte, 64)
	rand.Seed(time.Now().UnixNano())
	rand.Read(b) // OK to elide error since its documented to return nil
	msg := hex.EncodeToString(b)
	msgLen := len(msg)

	test := func() map[string]*counters {
		ctrs := make(map[string]*counters)
		for _, cfg := range cfgs {
			for src, u := range users {
				addr := cfg.addr.String()
				fam := pp.TrafficCounter_IPV4
				if cfg.fam == "udp6" {
					addr = fmt.Sprintf("[%v]", addr)
					fam = pp.TrafficCounter_IPV6
				}
				dst := fmt.Sprintf("%v:%v", addr, cfg.port)
				if err := txrx(ctx, msg, u, cfg.fam, dst, cfg.port+1000); err != nil {
					s.Errorf("Failed to run i/o test for %v:%v:%v: %v", u, cfg.fam, dst, err)
				}
				ctrs[key(cfg.rt.VethOutName, src, fam)] = &counters{}
			}
		}
		testing.Sleep(ctx, 5*time.Second)
		resp, err = pc.GetTrafficCounters(ctx, devices)
		if err != nil {
			s.Fatal("Failed to get traffic counters: ", err)
		}
		for _, tc := range resp.Counters {
			k := key(tc.GetDevice(), tc.GetSource(), tc.GetIpFamily())
			if _, ok := ctrs[k]; !ok {
				continue
			}
			ctrs[k] = &counters{tc.GetTxBytes(), tc.GetRxBytes()}
		}
		return ctrs
	}

	base := test()
	// Verify we have all expected counters.
	for _, cfg := range cfgs {
		fam := pp.TrafficCounter_IPV4
		if cfg.fam == "udp6" {
			fam = pp.TrafficCounter_IPV6
		}
		for src := range users {
			k := key(cfg.rt.VethOutName, src, fam)
			if _, ok := base[k]; !ok {
				s.Errorf("Expected counter missing: %s", k)
			}
		}
	}

	// Verify counters.
	comp := test()
	for k, b := range base {
		c, ok := comp[k]
		if !ok {
			testing.ContextLog(ctx, "Comparable counter missing: ", k)
			continue
		}
		if c.tx < (b.tx+uint64(msgLen)) || c.rx < (b.rx+uint64(msgLen)) {
			s.Errorf("Unexpected counter result for %v: tx[%v vs %v (base)] rx[%v vs %v (base)]  ", k, c.tx, b.tx, c.rx, b.rx)
		}
	}
}

func (c *config) cleanup(ctx context.Context) {
	if c.rt != nil {
		c.rt.Cleanup(ctx)
	}
}

func setup(ctx context.Context, mgr *shill.Manager, pool *subnet.Pool, fam string) (*config, error) {
	var opt virtualnet.EnvOptions
	if fam == "udp4" {
		opt.Priority = 2
		opt.NameSuffix = "4"
		opt.EnableDHCP = true
	} else {
		opt.Priority = 1
		opt.NameSuffix = "6"
		opt.RAServer = true
	}
	svc, rt, err := virtualnet.CreateRouterEnv(ctx, mgr, pool, opt)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to set up %s network env", fam)
	}
	defer func() {
		if rt != nil {
			rt.Cleanup(ctx)
		}
	}()
	if err := svc.WaitForProperty(ctx, shillconst.ServicePropertyState, shillconst.ServiceStateOnline, 10*time.Second); err != nil {
		return nil, errors.Wrapf(err, "failed to wait for %s service", fam)
	}

	port := 37000 + opt.Priority
	udp := udpserver.New(fam, port, 512, udpserver.Reflector())
	if err := rt.StartServer(ctx, fam, udp); err != nil {
		return nil, errors.Wrapf(err, "failed to start %s server", fam)
	}
	addrs, err := rt.WaitForVethInAddrs(ctx, fam == "udp4", fam == "udp6")
	if err != nil {
		return nil, errors.Wrapf(err, "failed to get %s router addrs: ", fam)
	}
	var addr net.IP
	if fam == "udp4" {
		addr = addrs.IPv4Addr
	} else {
		addr = addrs.IPv6Addrs[0]
	}
	cfg := &config{
		rt:   rt,
		fam:  fam,
		port: port,
		addr: addr,
	}
	rt = nil
	return cfg, nil
}

func txrx(ctx context.Context, msg, usr, fam, dst string, srcPort int) error {
	// This bit is necessary to correctly run the i/o as the desired user (su/sudo do not).
	u, err := user.Lookup(usr)
	if err != nil {
		return errors.Errorf("failed to resolve user %s", usr)
	}
	uid, err := strconv.Atoi(u.Uid)
	if err != nil {
		return errors.Wrap(err, "invalid uid")
	}
	gid, err := strconv.Atoi(u.Gid)
	if err != nil {
		return errors.Wrap(err, "invalid gid")
	}

	args := []string{
		"echo",
		msg,
		"|",
		"socat",
		"-",
		fmt.Sprintf("%v:%v,sp=%v,reuseaddr", fam, dst, srcPort),
	}
	cmd := testexec.CommandContext(ctx, "bash", "-c", strings.Join(args, " "))
	cmd.Cmd.SysProcAttr = &syscall.SysProcAttr{
		Credential: &syscall.Credential{
			Uid: uint32(uid),
			Gid: uint32(gid),
		},
	}
	return cmd.Run()
}
