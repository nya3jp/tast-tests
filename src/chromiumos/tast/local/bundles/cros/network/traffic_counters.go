// Copyright 2022 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package network

import (
	"context"
	"encoding/hex"
	"fmt"
	"math/rand"
	"net"
	"os/user"
	"strconv"
	"strings"
	"syscall"
	"time"

	pp "chromiumos/system_api/patchpanel_proto"
	"chromiumos/tast/common/shillconst"
	"chromiumos/tast/common/testexec"
	"chromiumos/tast/ctxutil"
	"chromiumos/tast/errors"
	patchpanel "chromiumos/tast/local/network/patchpanel_client"
	"chromiumos/tast/local/network/virtualnet"
	"chromiumos/tast/local/network/virtualnet/env"
	"chromiumos/tast/local/network/virtualnet/subnet"
	"chromiumos/tast/local/network/virtualnet/udpserver"
	"chromiumos/tast/local/shill"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         TrafficCounters,
		Desc:         "Verify patchpanel traffic counters",
		Contacts:     []string{"cros-networking@google.com"},
		Attr:         []string{"group:mainline", "informational"},
		LacrosStatus: testing.LacrosVariantUnneeded,
	})
}

type server struct {
	rt   *env.Env
	fam  udpserver.Family
	port int
	addr net.IP
}

func (s server) dst() string {
	addr := s.addr.String()
	if s.fam == udpserver.UDP6 {
		addr = fmt.Sprintf("[%v]", addr)
	}
	return fmt.Sprintf("%v:%v", addr, s.port)
}

type counters struct {
	tx, rx uint64
}

func ipFamily(f udpserver.Family) pp.TrafficCounter_IpFamily {
	if f == udpserver.UDP6 {
		return pp.TrafficCounter_IPV6
	}
	return pp.TrafficCounter_IPV4
}

// TrafficCounters verifies the patchpanel TrafficCounter API and behavior
// for network traffic generated by certain user IDs. It does not currently
// verify traffic marked via additional mechanisms.
// Verification is done "best effort" in the sense that this test will confirm
// that at-least as much traffic as sent and received is counter, but the actual
// amount may be higher.
// This test relies on virtualnet and checks both v4 and v6 networks. It expects
// the router on the v6 subnet to be reachable.
func TrafficCounters(ctx context.Context, s *testing.State) {
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, 5*time.Second)
	defer cancel()

	mgr, err := shill.NewManager(ctx)
	if err != nil {
		s.Fatal("Failed to create manager proxy: ", err)
	}
	pop, err := mgr.PushTestProfile(ctx)
	if err != nil {
		s.Fatal("Failed to create test profile for shill: ", err)
	}
	defer pop()
	if err := mgr.SetProperty(ctx, shillconst.ProfilePropertyCheckPortalList, "wifi,cellular"); err != nil {
		s.Fatal("Failed to disable portal detection on ethernet: ", err)
	}

	pool := subnet.NewPool()
	var (
		devices []string
		svrs    []*server
	)
	for _, fam := range []udpserver.Family{
		udpserver.UDP4,
		udpserver.UDP6,
	} {
		svr, err := setup(ctx, mgr, pool, fam)
		if err != nil {
			s.Fatal("Failed to setup router: ", err)
		}
		svrs = append(svrs, svr)
		devices = append(devices, svr.rt.VethOutName)
		defer svr.cleanup(cleanupCtx)
	}

	pc, err := patchpanel.New(ctx)
	if err != nil {
		s.Fatal("Failed to create patchpanel client: ", err)
	}

	// Grab the current counters for our interfaces.
	resp, err := pc.GetTrafficCounters(ctx, devices)
	if err != nil {
		s.Fatal("Failed to get traffic counters: ", err)
	}

	key := func(dev string, src pp.TrafficCounter_Source, fam pp.TrafficCounter_IpFamily) string {
		return fmt.Sprintf("%v:%v:%v", dev, src.String(), fam.String())
	}
	users := map[pp.TrafficCounter_Source]string{
		pp.TrafficCounter_SYSTEM: "kerberosd",
		pp.TrafficCounter_USER:   "debugd",
		pp.TrafficCounter_CHROME: "chronos",
	}

	b := make([]byte, 64)
	rand.Seed(time.Now().UnixNano())
	rand.Read(b) // OK to elide error since its documented to return nil
	msg := hex.EncodeToString(b)
	msgLen := len(msg)

	// Generates traffic for each source on each server and returns the counters obtained from patchpanel.
	test := func() map[string]*counters {
		ctrs := make(map[string]*counters)
		for _, svr := range svrs {
			for src, u := range users {
				if err := txrx(ctx, svr, msg, u); err != nil {
					s.Errorf("Failed to run i/o test for %v:%v:%v: %v", u, svr.fam.String(), svr.dst(), err)
				}
				ctrs[key(svr.rt.VethOutName, src, ipFamily(svr.fam))] = &counters{}
			}
		}
		// Ensure the counters are flushed. There is some marginal delay in when the updated values are ready;
		// and while 5 seconds is an arbitary duration, it should be the case that this much time is more than
		// enough. The alternative to sleeping here is polling and managing errors. This is much simpler to
		// maintain and understand.
		testing.Sleep(ctx, 5*time.Second)
		resp, err = pc.GetTrafficCounters(ctx, devices)
		if err != nil {
			s.Fatal("Failed to get traffic counters: ", err)
		}
		for _, tc := range resp.Counters {
			k := key(tc.GetDevice(), tc.GetSource(), tc.GetIpFamily())
			if _, ok := ctrs[k]; !ok {
				continue
			}
			ctrs[k] = &counters{tc.GetTxBytes(), tc.GetRxBytes()}
		}
		return ctrs
	}

	base := test()
	// Verify we have all expected counters.
	for _, svr := range svrs {
		for src := range users {
			k := key(svr.rt.VethOutName, src, ipFamily(svr.fam))
			if _, ok := base[k]; !ok {
				s.Errorf("Expected baseline counter missing: %s", k)
			}
		}
	}

	// Verify counters.
	comp := test()
	for k, b := range base {
		c, ok := comp[k]
		if !ok {
			s.Errorf("Expected comparable counter missing: %s", k)
			continue
		}
		if c.tx < (b.tx+uint64(msgLen)) || c.rx < (b.rx+uint64(msgLen)) {
			s.Errorf("Unexpected counter result for %v: tx[%v vs %v (base)] rx[%v vs %v (base)]  ", k, c.tx, b.tx, c.rx, b.rx)
		}
	}
}

func (s *server) cleanup(ctx context.Context) {
	if s.rt != nil {
		s.rt.Cleanup(ctx)
	}
}

func setup(ctx context.Context, mgr *shill.Manager, pool *subnet.Pool, fam udpserver.Family) (*server, error) {
	var opt virtualnet.EnvOptions
	if fam == udpserver.UDP6 {
		opt.Priority = 1
		opt.NameSuffix = "6"
		opt.RAServer = true
	} else {
		opt.Priority = 2
		opt.NameSuffix = "4"
		opt.EnableDHCP = true
	}
	svc, rt, err := virtualnet.CreateRouterEnv(ctx, mgr, pool, opt)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to set up %s network env", fam)
	}
	defer func() {
		if rt != nil {
			rt.Cleanup(ctx)
		}
	}()
	if err := svc.WaitForProperty(ctx, shillconst.ServicePropertyState, shillconst.ServiceStateOnline, 10*time.Second); err != nil {
		return nil, errors.Wrapf(err, "failed to wait for %s service", fam)
	}

	port := 37000 + opt.Priority
	udp := udpserver.New(fam, port, 512, udpserver.Reflector())
	if err := rt.StartServer(ctx, fam.String(), udp); err != nil {
		return nil, errors.Wrapf(err, "failed to start %s server", fam)
	}
	addrs, err := rt.WaitForVethInAddrs(ctx, fam == udpserver.UDP4, fam == udpserver.UDP6)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to get %s router addrs: ", fam)
	}
	var addr net.IP
	if fam == udpserver.UDP6 {
		addr = addrs.IPv6Addrs[0]
	} else {
		addr = addrs.IPv4Addr
	}
	svr := &server{
		rt:   rt,
		fam:  fam,
		port: port,
		addr: addr,
	}
	rt = nil
	return svr, nil
}

func txrx(ctx context.Context, svr *server, msg, usr string) error {
	// This bit is necessary to correctly run the i/o as the desired user (su/sudo do not).
	u, err := user.Lookup(usr)
	if err != nil {
		return errors.Errorf("failed to resolve user %s", usr)
	}
	uid, err := strconv.Atoi(u.Uid)
	if err != nil {
		return errors.Wrap(err, "invalid uid")
	}
	gid, err := strconv.Atoi(u.Gid)
	if err != nil {
		return errors.Wrap(err, "invalid gid")
	}

	args := []string{
		"echo",
		msg,
		"|",
		"socat",
		"-",
		fmt.Sprintf("%v:%v,sp=%v,reuseaddr", svr.fam.String(), svr.dst(), svr.port+1000), // +1000 is arbitrary, just need a local port for the recv
	}
	cmd := testexec.CommandContext(ctx, "bash", "-c", strings.Join(args, " "))
	cmd.Cmd.SysProcAttr = &syscall.SysProcAttr{
		Credential: &syscall.Credential{
			Uid: uint32(uid),
			Gid: uint32(gid),
		},
	}
	return cmd.Run()
}
