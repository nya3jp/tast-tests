// Copyright 2022 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package network

import (
	"context"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net"
	"net/http"
	"os/user"
	"strconv"
	"strings"
	"syscall"
	"time"

	pp "chromiumos/system_api/patchpanel_proto"
	"chromiumos/tast/common/shillconst"
	"chromiumos/tast/common/testexec"
	"chromiumos/tast/ctxutil"
	"chromiumos/tast/errors"
	"chromiumos/tast/local/bundles/cros/network/vpn"
	"chromiumos/tast/local/crostini"
	"chromiumos/tast/local/multivm"
	patchpanel "chromiumos/tast/local/network/patchpanel_client"
	"chromiumos/tast/local/network/virtualnet"
	"chromiumos/tast/local/network/virtualnet/env"
	"chromiumos/tast/local/network/virtualnet/httpserver"
	"chromiumos/tast/local/network/virtualnet/subnet"
	"chromiumos/tast/local/network/virtualnet/udpserver"
	"chromiumos/tast/local/shill"
	"chromiumos/tast/testing"
)

type tcParams struct {
	users bool
	vpn   bool
	cros  bool
}

func init() {
	testing.AddTest(&testing.Test{
		Func:         TrafficCounters,
		Desc:         "Verify patchpanel traffic counters",
		Contacts:     []string{"garrick@google.com", "cros-networking@google.com"},
		Attr:         []string{"group:mainline", "informational"},
		Timeout:      5 * time.Minute,
		LacrosStatus: testing.LacrosVariantUnneeded,
		Pre:          multivm.CrostiniStarted(),
		Params: []testing.Param{{
			Name: "users",
			Val:  tcParams{users: true},
		}, {
			Name:              "vpn",
			Val:               tcParams{vpn: true},
			ExtraSoftwareDeps: []string{"wireguard"},
		}, {
			Name:              "crostini",
			Val:               tcParams{cros: true},
			ExtraSoftwareDeps: []string{"chrome", "dlc", "vm_host"},
			ExtraHardwareDeps: crostini.CrostiniStable,
			ExtraData: []string{
				crostini.GetContainerMetadataArtifact("buster", false),
				crostini.GetContainerRootfsArtifact("buster", false),
			},
		}}})
}

type server struct {
	rt   *env.Env
	fam  udpserver.Family
	port int
	addr net.IP
}

func (s server) dst() string {
	addr := s.addr.String()
	if s.fam == udpserver.UDP6 {
		addr = fmt.Sprintf("[%v]", addr)
	}
	return fmt.Sprintf("%v:%v", addr, s.port)
}

func (s *server) cleanup(ctx context.Context) {
	if s.rt != nil {
		s.rt.Cleanup(ctx)
		s.rt = nil
	}
}

type counters struct {
	tx, rx uint64
}

func ipFamily(f udpserver.Family) pp.TrafficCounter_IpFamily {
	if f == udpserver.UDP6 {
		return pp.TrafficCounter_IPV6
	}
	return pp.TrafficCounter_IPV4
}

type userSources map[pp.TrafficCounter_Source]string

// TrafficCounters verifies the patchpanel TrafficCounter API and behavior
// for network traffic generated by certain user IDs, when connected to a
// host VPN, and from the Crostini gues VM.  It does not currently verify traffic
// flow originating from ARC.
// Verification is done "best effort" in the sense that this test will confirm
// that at-least as much traffic as sent and received is counter, but the actual
// amount may be higher.
// This test relies on virtualnet and checks both v4 and v6 networks. It expects
// the router on the v6 subnet to be reachable.
func TrafficCounters(ctx context.Context, s *testing.State) {
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, 10*time.Second)
	defer cancel()

	param := s.Param().(tcParams)

	mgr, err := shill.NewManager(ctx)
	if err != nil {
		s.Fatal("Failed to create manager proxy: ", err)
	}
	if err := mgr.SetProperty(ctx, shillconst.ProfilePropertyCheckPortalList, "wifi,cellular"); err != nil {
		s.Fatal("Failed to disable portal detection on ethernet: ", err)
	}
	defer func() {
		if err := mgr.SetProperty(ctx, shillconst.ProfilePropertyCheckPortalList, "ethernet,wifi,cellular"); err != nil {
			s.Fatal("Failed to restore portal detection on ethernet: ", err)
		}
	}()

	pc, err := patchpanel.New(ctx)
	if err != nil {
		s.Fatal("Failed to create patchpanel client: ", err)
	}

	var svrs []*server
	pool := subnet.NewPool()
	fams := []udpserver.Family{udpserver.UDP4}
	if param.users {
		fams = append(fams, udpserver.UDP6)
	}
	for _, fam := range fams {
		svr, err := setup(ctx, mgr, pool, fam)
		if err != nil {
			s.Fatal("Failed to setup router: ", err)
		}
		svrs = append(svrs, svr)
		defer svr.cleanup(cleanupCtx)
	}

	b := make([]byte, 64)
	rand.Seed(time.Now().UnixNano())
	rand.Read(b) // OK to elide error since its documented to return nil
	msg := hex.EncodeToString(b)
	msgLen := len(msg)

	key := func(dev string, src pp.TrafficCounter_Source, fam pp.TrafficCounter_IpFamily) string {
		return fmt.Sprintf("%v:%v:%v", dev, src.String(), fam.String())
	}

	// Retrieves counters from patchpanel, filtered to only those whose keys are
	// provided.
	getCounters := func(keys map[string]bool) map[string]*counters {
		ctrs := make(map[string]*counters)
		// Ensure the counters are flushed. There is some marginal delay in when the
		// updated values are ready; and while 5 seconds is an arbitrary duration,
		// it should be the case that this much time is more than enough.
		// The alternative to sleeping here is polling and managing errors.
		// This is much simpler to maintain and understand.
		testing.Sleep(ctx, 5*time.Second)
		resp, err := pc.GetTrafficCounters(ctx, []string{})
		if err != nil {
			s.Fatal("Failed to get traffic counters: ", err)
		}
		for _, tc := range resp.Counters {
			k := key(tc.GetDevice(), tc.GetSource(), tc.GetIpFamily())
			if _, ok := keys[k]; !ok {
				continue
			}
			ctrs[k] = &counters{tc.GetTxBytes(), tc.GetRxBytes()}
		}
		return ctrs
	}

	// Returns a slice of counter keys for the given sources x users.
	counterKeys := func(users userSources) map[string]bool {
		keys := make(map[string]bool)
		for _, svr := range svrs {
			for src := range users {
				keys[key(svr.rt.VethOutName, src, ipFamily(svr.fam))] = true
			}
		}
		return keys
	}

	// Generates traffic for each source on each server and returns map keyed by
	// the counters we expect to find based on the servers and sources provided.
	runIO := func(users userSources) {
		for _, svr := range svrs {
			for _, u := range users {
				if err := txrx(ctx, svr, msg, u); err != nil {
					s.Errorf("Failed to run i/o test for %v:%v:%v: %v", u, svr.fam.String(), svr.dst(), err)
				}
			}
		}
	}

	// Tests that traffic counters increase by at least an expected amount
	// across two consecutive runs. Only counters that map to |keys| are
	// considered. |f| is expected to generate traffic and return the
	// desired counters.
	test := func(keys map[string]bool, f func() map[string]*counters) {
		// Generate initial set of counters.
		base := f()
		// Verify we have all expected counters.
		for k := range keys {
			if _, ok := base[k]; !ok {
				s.Errorf("Expected baseline counter missing: %s", k)
			}
		}

		// Generate comparison set.
		comp := f()
		for k, b := range base {
			c, ok := comp[k]
			if !ok {
				s.Errorf("Expected comparable counter missing: %s", k)
				continue
			}
			if c.tx < (b.tx+uint64(msgLen)) || c.rx < (b.rx+uint64(msgLen)) {
				s.Errorf("Unexpected counter result for %v: tx[%v vs %v (base)] rx[%v vs %v (base)]  ", k, c.tx, b.tx, c.rx, b.rx)
			}
		}
	}

	// Test traffic counted by user ID.
	if param.users {
		users := userSources{
			pp.TrafficCounter_SYSTEM: "kerberosd",
			pp.TrafficCounter_USER:   "debugd",
			pp.TrafficCounter_CHROME: "chronos",
		}
		expected := counterKeys(users)
		test(
			expected,
			func() map[string]*counters {
				runIO(users)
				return getCounters(expected)
			})
	}

	// Test traffic counted for host VPN.
	if param.vpn {
		// Connect the VPN.
		svr := svrs[0]
		conn, err := connectVPN(ctx, svr)
		if err != nil {
			s.Fatal("Failed to connect vpn: ", err)
		}
		defer conn.Cleanup(cleanupCtx)

		users := userSources{
			pp.TrafficCounter_VPN: "chronos",
		}
		// Inject the counter we expect to see for chrome traffic attributed to the vpn user.
		expected := counterKeys(users)
		expected[key("vpn", pp.TrafficCounter_CHROME, ipFamily(svr.fam))] = true
		test(
			expected,
			func() map[string]*counters {
				runIO(users)
				return getCounters(expected)
			})
	}

	// Test traffic originating from Crostini.
	if param.cros {
		pre := s.PreValue().(*multivm.PreData)
		cros := multivm.CrostiniFromPre(pre)

		handler := func(resp http.ResponseWriter, req *http.Request) {
			testing.ContextLog(ctx, " HANLDING REQ")
			if _, err := ioutil.ReadAll(req.Body); err != nil {
				testing.ContextLog(ctx, "Failed to read HTTP request: ", err)
			}
			resp.Header().Set("content-type", "application/octet-stream")
			resp.Header().Set("content-length", strconv.Itoa(msgLen))
			if _, err := resp.Write([]byte(msg)); err != nil {
				testing.ContextLog(ctx, "Failed to write HTTP reply: ", err)
			}
		}
		users := userSources{
			pp.TrafficCounter_CROSVM: "crosvm",
		}
		expected := counterKeys(users)

		// Spin up an HTTP server to handle the curl request.
		for _, svr := range svrs {
			if err := svr.rt.StartServer(ctx, "http", httpserver.New("80", handler, nil)); err != nil {
				s.Fatal("Failed to start HTTP server: ", err)
			}
			test(expected,
				func() map[string]*counters {
					// Use curl to generate some traffic to/from the HTTP server.
					args := []string{
						"curl",
						"-X", "PUT",
						"http://example.com",
						"--connect-timeout", "5",
						"-d", fmt.Sprintf(`{"msg":%s}`, msg),
					}
					if err := cros.Command(ctx, args...).Run(testexec.DumpLogOnError); err != nil {
						s.Errorf("Failed to run HTTP i/o test for %v:%v: %v", svr.fam.String(), svr.dst(), err)
					}
					return getCounters(expected)
				})
			// Teardown the HTTP server.
			svr.cleanup(ctx)
		}
	}
}

func setup(ctx context.Context, mgr *shill.Manager, pool *subnet.Pool, fam udpserver.Family) (*server, error) {
	var opt virtualnet.EnvOptions
	if fam == udpserver.UDP6 {
		opt.Priority = 1
		opt.NameSuffix = "6"
		opt.RAServer = true
	} else {
		opt.Priority = 2
		opt.NameSuffix = "4"
		opt.EnableDHCP = true
		opt.EnableDNS = true
	}
	svc, rt, err := virtualnet.CreateRouterEnv(ctx, mgr, pool, opt)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to set up %s network env", fam)
	}
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, 5*time.Second)
	defer cancel()
	defer func() {
		if rt != nil {
			rt.Cleanup(cleanupCtx)
		}
	}()
	if err := svc.WaitForProperty(ctx, shillconst.ServicePropertyState, shillconst.ServiceStateOnline, 10*time.Second); err != nil {
		return nil, errors.Wrapf(err, "failed to wait for %s service", fam)
	}

	port := unusedOrRandomPort(ctx, fam)
	udp := udpserver.New(fam, port, 512, udpserver.Reflector())
	if err := rt.StartServer(ctx, fam.String(), udp); err != nil {
		return nil, errors.Wrapf(err, "failed to start %s server", fam)
	}
	addrs, err := rt.WaitForVethInAddrs(ctx, fam == udpserver.UDP4, fam == udpserver.UDP6)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to get %s router addrs: ", fam)
	}
	var addr net.IP
	if fam == udpserver.UDP6 {
		addr = addrs.IPv6Addrs[0]
	} else {
		addr = addrs.IPv4Addr
	}
	svr := &server{
		rt:   rt,
		fam:  fam,
		port: port,
		addr: addr,
	}
	rt = nil
	return svr, nil
}

func connectVPN(ctx context.Context, s *server) (*vpn.Connection, error) {
	config := vpn.Config{
		Type:                  vpn.TypeWireGuard,
		WGAutoGenKey:          true,
		UnderlayIPIsOverlayIP: true,
	}
	conn, err := vpn.NewConnectionWithEnvs(ctx, config, s.rt, nil)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create vpn connection")
	}
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, 5*time.Second)
	defer func() {
		if err == nil {
			return
		}
		if err := conn.Cleanup(cleanupCtx); err != nil {
			testing.ContextLog(cleanupCtx, "Failed to clean up vpn connection: ", err)
		}
		cancel()
	}()
	if err = conn.SetUp(ctx); err != nil {
		return nil, errors.Wrap(err, "failed to setup vpn connection")
	}
	if _, err := conn.Connect(ctx); err != nil {
		return nil, err
	}
	return conn, nil
}

func unusedOrRandomPort(ctx context.Context, fam udpserver.Family) int {
	rport := func(err error) int {
		testing.ContextLog(ctx, "Failed to query unused port - generating one randomly, good luck: ", err)
		return 10000 + rand.Intn(50000)
	}

	addr, err := net.ResolveUDPAddr(fam.String(), "localhost:0")
	if err != nil {
		return rport(err)
	}
	c, err := net.ListenUDP(fam.String(), addr)
	if err != nil {
		return rport(err)
	}
	defer c.Close()
	return c.LocalAddr().(*net.UDPAddr).Port
}

func txrx(ctx context.Context, svr *server, msg, usr string) error {
	// This bit is necessary to correctly run the i/o as the desired user (su/sudo do not).
	u, err := user.Lookup(usr)
	if err != nil {
		return errors.Errorf("failed to resolve user %s", usr)
	}
	uid, err := strconv.Atoi(u.Uid)
	if err != nil {
		return errors.Wrap(err, "invalid uid")
	}
	gid, err := strconv.Atoi(u.Gid)
	if err != nil {
		return errors.Wrap(err, "invalid gid")
	}

	args := []string{
		"echo",
		msg,
		"|",
		"socat",
		"-",
		fmt.Sprintf("%v:%v,sp=%v,reuseaddr", svr.fam.String(), svr.dst(), unusedOrRandomPort(ctx, svr.fam)),
	}
	cmd := testexec.CommandContext(ctx, "bash", "-c", strings.Join(args, " "))
	cmd.Cmd.SysProcAttr = &syscall.SysProcAttr{
		Credential: &syscall.Credential{
			Uid: uint32(uid),
			Gid: uint32(gid),
		},
	}
	return cmd.Run()
}
