// Copyright 2021 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package vpn

import (
	"context"
	"fmt"
	"time"

	"chromiumos/tast/common/crypto/certificate"
	"chromiumos/tast/common/pkcs11/netcertstore"
	"chromiumos/tast/common/shillconst"
	"chromiumos/tast/errors"
	"chromiumos/tast/local/hwsec"
	"chromiumos/tast/local/shill"
	"chromiumos/tast/testing"
)

// Config contains the parameters (for both client and server) to configure a
// VPN connection.
type Config struct {
	Type     string
	AuthType string

	// Parameters for a L2TP/IPsec VPN connection.
	IPsecUseXauth         bool
	IPsecXauthMissingUser bool
	IPsecXauthWrongUser   bool
	UnderlayIPIsOverlayIP bool
}

// VPN types.
const (
	TypeL2TPIPsec = "L2TP/IPsec"
)

// Authentication types.
const (
	AuthTypePSK  = "psk"
	AuthTypeCert = "cert"
)

// Connection represents a VPN connection can be used in the test.
type Connection struct {
	Server *Server

	config    Config
	manager   *shill.Manager
	certStore *netcertstore.Store
	service   *shill.Service

	// The following TPM-related fields will be set and used when the authType is
	// "cert".
	certID   string
	certSlot string
	certPin  string
}

// NewConnection creates a new connection object. Notes:
// - It is the responsibility of the caller to call Cleanup() when the VPN
//   connection is no longer needed.
// - During connection, we need to modify the profile of shill to configure the
//   VPN client. So the "resetShill" fixture is suggested to make sure that we
//   have a clean shill setup before and after the test.
// Example: the following code can be used to set up a basic L2TP/IPsec VPN
// connection:
//     vpn.NewConnection(ctx, vpn.Config{
//         Type: vpn.TypeL2TPIPsec, AuthType: vpn.AuthTypePSK,
//     })
// Also see vpn_connect.go for a typical usage for this struct.
func NewConnection(ctx context.Context, config Config) (*Connection, error) {
	manager, err := shill.NewManager(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "failed creating shill manager proxy")
	}

	return &Connection{
		config:  config,
		manager: manager,
	}, nil
}

// Start starts the VPN server, configures the VPN service (client) in shill,
// and lets shill connect to the VPN server. Returns whether the connection is
// established successfully.
func (c *Connection) Start(ctx context.Context) (bool, error) {
	// Makes sure that the physical Ethernet service is online before we start,
	// since the physical service change event may affect the VPN connection. We
	// use 60 seconds here for DHCP negotiation since some DUTs will end up
	// retrying DHCP discover/request, and this can often take 15-30 seconds
	// depending on the number of retries.
	props := map[string]interface{}{
		shillconst.ServicePropertyType:  shillconst.TypeEthernet,
		shillconst.ServicePropertyState: shillconst.ServiceStateOnline,
	}
	if _, err := c.manager.WaitForServiceProperties(ctx, props, 60*time.Second); err != nil {
		return false, errors.Wrap(err, "failed to wait for Ethernet online")
	}

	if err := c.prepareCertStore(ctx); err != nil {
		return false, err
	}

	if err := c.startServer(ctx); err != nil {
		return false, err
	}

	if err := c.configureService(ctx); err != nil {
		return false, err
	}

	connected, err := c.connectService(ctx)
	if err != nil {
		return false, err
	}

	// Currently, the connected state of a VPN service doesn't mean the VPN
	// service is ready for tunneling traffic: patchpanel needs to setup some
	// iptables rules (for routing and connection pinning) before that. If ping is
	// started before iptables rules are ready, the traffic generated by ping will
	// be "pinned" to the previous default interface. So adds a small timeout here
	// to mitigate this racing case.
	testing.Sleep(ctx, 500*time.Millisecond)
	testing.ContextLogf(ctx, "VPN connected, underlay_ip is %s, overlay_ip is %s", c.Server.UnderlayIP, c.Server.OverlayIP)
	return connected, nil
}

// Cleanup removes the service from shill, and releases other resources used for
// the connection.
func (c *Connection) Cleanup(ctx context.Context) error {
	var lastErr error

	// Removes service from the profile.
	if c.service != nil {
		if err := c.service.Remove(ctx); err != nil {
			testing.ContextLog(ctx, "Failed to remove service from profile: ", err)
			lastErr = err
		}
	}

	// Shuts down server.
	if c.Server != nil {
		if err := c.Server.Exit(ctx); err != nil {
			testing.ContextLog(ctx, "Failed to stop VPN server: ", err)
			lastErr = err
		}
	}

	// Cleans up netcertstore.
	if c.certStore != nil {
		if err := c.certStore.Cleanup(ctx); err != nil {
			testing.ContextLog(ctx, "Failed to clean up cert store: ", err)
			lastErr = err
		}
	}

	return lastErr
}

func (c *Connection) prepareCertStore(ctx context.Context) error {
	if c.config.AuthType != AuthTypeCert {
		return nil
	}

	var err error

	runner := hwsec.NewCmdRunner()
	if c.certStore, err = netcertstore.CreateStore(ctx, runner); err != nil {
		return errors.Wrap(err, "failed to create cert store")
	}

	c.certSlot = fmt.Sprintf("%d", c.certStore.Slot())
	c.certPin = c.certStore.Pin()
	clientCred := certificate.TestCert1().ClientCred
	c.certID, err = c.certStore.InstallCertKeyPair(ctx, clientCred.PrivateKey, clientCred.Cert)
	if err != nil {
		return errors.Wrap(err, "failed to insert cert key pair into cert store")
	}

	return nil
}

func (c *Connection) startServer(ctx context.Context) error {
	var err error
	if c.config.Type == TypeL2TPIPsec {
		c.Server, err = StartL2TPIPsecServer(ctx, c.config.AuthType, c.config.IPsecUseXauth, c.config.UnderlayIPIsOverlayIP)
	} else {
		return errors.Errorf("unexpected VPN type %s", c.config.Type)
	}
	return err
}

func (c *Connection) configureService(ctx context.Context) error {
	var properties map[string]interface{}
	var serverAddress string

	if c.config.UnderlayIPIsOverlayIP {
		serverAddress = c.Server.OverlayIP
	} else {
		serverAddress = c.Server.UnderlayIP
	}

	// Populates the properties at first.
	if (c.config.Type == TypeL2TPIPsec) && (c.config.AuthType == AuthTypePSK) {
		properties = map[string]interface{}{
			"L2TPIPsec.Password": chapSecret,
			"L2TPIPsec.PSK":      ipsecPresharedKey,
			"L2TPIPsec.User":     chapUser,
			"Name":               "test-vpn-l2tp-psk",
			"Provider.Host":      serverAddress,
			"Provider.Type":      "l2tpipsec",
			"Type":               "vpn",
		}
		if c.config.IPsecUseXauth && !c.config.IPsecXauthMissingUser {
			if c.config.IPsecXauthWrongUser {
				properties["L2TPIPsec.XauthUser"] = "wrong-user"
				properties["L2TPIPsec.XauthPassword"] = "wrong-password"
			} else {
				properties["L2TPIPsec.XauthUser"] = xauthUser
				properties["L2TPIPsec.XauthPassword"] = xauthPassword
			}
		}
	} else if (c.config.Type == TypeL2TPIPsec) && (c.config.AuthType == AuthTypeCert) {
		properties = map[string]interface{}{
			"L2TPIPsec.CACertPEM":      []string{certificate.TestCert1().CACred.Cert},
			"L2TPIPsec.ClientCertID":   c.certID,
			"L2TPIPsec.ClientCertSlot": c.certSlot,
			"L2TPIPsec.User":           chapUser,
			"L2TPIPsec.Password":       chapSecret,
			"L2TPIPsec.PIN":            c.certPin,
			"Name":                     "test-vpn-l2tp-cert",
			"Provider.Host":            serverAddress,
			"Provider.Type":            "l2tpipsec",
			"Type":                     "vpn",
		}
	} else {
		return errors.Errorf("unexpected server type: got %s-%s", c.config.Type, c.config.AuthType)
	}

	servicePath, err := c.manager.ConfigureService(ctx, properties)
	if err != nil {
		return errors.Wrapf(err, "unable to configure the service for the VPN properties %v", properties)
	}

	if c.service, err = shill.NewService(ctx, servicePath); err != nil {
		return errors.Wrap(err, "failed creating shill service proxy")
	}

	return nil
}

func (c *Connection) connectService(ctx context.Context) (bool, error) {
	// Waits for service to be connected.
	testing.ContextLog(ctx, "Connecting to service: ", c.service)

	// Spawns watcher before connect.
	pw, err := c.service.CreateWatcher(ctx)
	if err != nil {
		return false, errors.Wrap(err, "failed to create watcher")
	}
	defer pw.Close(ctx)

	if err = c.service.Connect(ctx); err != nil {
		return false, errors.Wrapf(err, "failed to connect the service %v", c.service)
	}

	// Waits until connection established or failed. Unfortunately, some of the
	// failures for L2TP/IPsec VPN are detected based on timeout, which is 30
	// seconds at maximum for all the current test cases (that value is used in
	// vpn_manager::IpsecManager).
	// TODO(b/188489413): Use different timeout values for success and failure
	// cases.
	timeoutCtx, cancel := context.WithTimeout(ctx, 35*time.Second)
	defer cancel()
	state, err := pw.ExpectIn(timeoutCtx, shillconst.ServicePropertyState, append(shillconst.ServiceConnectedStates, shillconst.ServiceStateFailure))
	if err != nil {
		return false, err
	}

	return state != shillconst.ServiceStateFailure, nil
}
