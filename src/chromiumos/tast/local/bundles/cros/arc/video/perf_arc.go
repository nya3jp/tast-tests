// Copyright 2019 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package video provides common code to run ARC binary tests for video encoding.
package video

import (
	"context"
	"fmt"
	"io/ioutil"
	"regexp"
	"strconv"
	"strings"

	"chromiumos/tast/common/perf"
	"chromiumos/tast/errors"
	"chromiumos/tast/testing"
)

// This file contains helper functions for parsing metric values from log files generated by video_encode_accelerator_unittest.

var regExpFPS = regexp.MustCompile(`(?m)^Measured encoder FPS: ([+\-]?[0-9.]+)$`)
var regExpEncodeLatency50 = regexp.MustCompile(`(?m)^Encode latency for the 50th percentile: (\d+) us$`)
var regExpEncodeLatency75 = regexp.MustCompile(`(?m)^Encode latency for the 75th percentile: (\d+) us$`)
var regExpEncodeLatency95 = regexp.MustCompile(`(?m)^Encode latency for the 95th percentile: (\d+) us$`)

// reportFPS reports FPS info from log file and sets as the perf metric.
func reportFPS(ctx context.Context, p *perf.Values, name, logPath string) error {
	b, err := ioutil.ReadFile(logPath)
	if err != nil {
		return errors.Wrapf(err, "failed to read file %s", logPath)
	}

	matches := regExpFPS.FindAllStringSubmatch(string(b), -1)
	if len(matches) != 1 {
		return errors.Errorf("found %d FPS matches in %q; want 1", len(matches), b)
	}

	fps, err := strconv.ParseFloat(matches[0][1], 64)
	if err != nil {
		return errors.Wrapf(err, "failed to parse FPS value %q", matches[0][1])
	}

	p.Set(perf.Metric{
		Name:      getMetricName(name, "fps"),
		Unit:      "fps",
		Direction: perf.BiggerIsBetter,
	}, fps)

	testing.ContextLogf(ctx, "> FPS: %.2f", fps)

	return nil
}

// reportEncodeLatency reports encode latency from log file and sets as the perf metrics.
func reportEncodeLatency(ctx context.Context, p *perf.Values, name, logPath string) error {
	b, err := ioutil.ReadFile(logPath)
	if err != nil {
		return errors.Wrapf(err, "failed to read file %s", logPath)
	}

	// Iterate over different latency measurements, extracting and reporting each.
	for _, st := range []struct {
		key string         // metric key
		re  *regexp.Regexp // matches latency stat
	}{
		{"encode_latency.50_percentile", regExpEncodeLatency50},
		{"encode_latency.75_percentile", regExpEncodeLatency75},
		{"encode_latency.95_percentile", regExpEncodeLatency95},
	} {
		match := st.re.FindStringSubmatch(string(b))
		if match == nil {
			return errors.Errorf("didn't find match for latency %q in %q", st.re, b)
		}
		val, err := strconv.Atoi(match[1])
		if err != nil {
			return errors.Wrapf(err, "failed converting %q latency %q", st.key, match[1])
		}
		p.Set(perf.Metric{
			Name:      getMetricName(name, st.key),
			Unit:      "us",
			Direction: perf.SmallerIsBetter,
		}, float64(val))

		testing.ContextLogf(ctx, "> "+getMetricName(name, st.key)+": %vus", val)
	}

	return nil
}

// reportCPUUsage reports CPU usage from log file and sets as the perf metric.
func reportCPUUsage(ctx context.Context, p *perf.Values, name, logPath string) error {
	b, err := ioutil.ReadFile(logPath)
	if err != nil {
		return errors.Wrapf(err, "failed to read file %s", logPath)
	}

	vstr := strings.TrimSuffix(string(b), "\n")
	v, err := strconv.ParseFloat(vstr, 64)
	if err != nil {
		return errors.Wrapf(err, "failed to parse %q to float", vstr)
	}

	p.Set(perf.Metric{
		Name:      getMetricName(name, "cpu_usage"),
		Unit:      "percent",
		Direction: perf.SmallerIsBetter,
	}, v)

	testing.ContextLogf(ctx, "> CPU usage: %.2f%%", v)

	return nil
}

// reportPowerConsumption reports power consumption from log file and sets as the perf metric.
func reportPowerConsumption(ctx context.Context, p *perf.Values, name, logPath string) error {
	b, err := ioutil.ReadFile(logPath)
	if err != nil {
		return errors.Wrapf(err, "failed to read file %s", logPath)
	}

	vstr := strings.TrimSuffix(string(b), "\n")
	v, err := strconv.ParseFloat(vstr, 64)
	if err != nil {
		return errors.Wrapf(err, "failed to parse %q to float", vstr)
	}

	p.Set(perf.Metric{
		Name:      getMetricName(name, "power_consumption"),
		Unit:      "watt",
		Direction: perf.SmallerIsBetter,
	}, v)

	testing.ContextLogf(ctx, "> Power consumption: %.2f", v)

	return nil
}

// getMetricName wraps the stream name and key into the metric name.
// For example, name should contain both stream and codec name such like "tulip2-1280x720_h264", key is the metric name such like "fps".
func getMetricName(name, key string) string {
	return fmt.Sprintf("%s.%s", name, key)
}
