// Copyright 2022 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package arc

import (
	"context"
	"fmt"
	"time"

	androidui "chromiumos/tast/common/android/ui"
	"chromiumos/tast/ctxutil"
	"chromiumos/tast/errors"
	"chromiumos/tast/local/arc"
	"chromiumos/tast/local/chrome"
	"chromiumos/tast/local/chrome/ash"
	"chromiumos/tast/local/chrome/uiauto"
	"chromiumos/tast/local/chrome/uiauto/mouse"
	"chromiumos/tast/local/chrome/uiauto/nodewith"
	"chromiumos/tast/local/chrome/uiauto/pointer"
	"chromiumos/tast/local/chrome/uiauto/quicksettings"
	"chromiumos/tast/local/chrome/uiauto/role"
	"chromiumos/tast/local/coords"
	"chromiumos/tast/testing"
)

const (
	arcNotificationTest2ApkFilename  = "ArcNotificationTest2.apk"
	arcNotificationTest2PackageName  = "org.chromium.arc.testapp.notification2"
	arcNotificationTest2ActivityName = ".MainActivity"
	arcNotificationTest2StartCommand = arcNotificationTest2PackageName + ".SHOW_NOTIFICATION"
	// Notification ID on Android is composed of many components.
	// So this is just the substring to match the notification generated by the test app.
	arcNotificationTest2NotificationID = "|" + arcNotificationTest2PackageName + "|"
)

type closeMethod string

const (
	swipeOut       closeMethod = "swipeOut"
	clickEvent                 = "clickEvent"
	clearAllButton             = "clearAllButton"
	closeButton                = "closeButton"
)

var (
	arcNotificationContentView = nodewith.ClassName("ArcNotificationContentView")
	arcNotificationSurface     = nodewith.ClassName("ArcNotificationSurface")
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         NotificationExperimental,
		LacrosStatus: testing.LacrosVariantUnneeded,
		Desc:         "Launches a testing APK to generate various kinds of notifications and verifies its state",
		Contacts: []string{
			"toshikikikuchi@chromium.org",
			"yhanada@chromium.org",
			"arc-framework+tast@google.com",
		},
		Attr:         []string{"group:mainline", "informational"},
		Data:         []string{arcNotificationTest2ApkFilename},
		Fixture:      "arcBootedWithNotificationRefresh",
		SoftwareDeps: []string{"chrome"},
		Timeout:      4 * time.Minute,
		Params: []testing.Param{{
			ExtraSoftwareDeps: []string{"android_p"},
		}, {
			Name:              "vm",
			ExtraSoftwareDeps: []string{"android_vm"},
		}},
	})
}

func closeNotification(ctx context.Context, tconn *chrome.TestConn, ui *uiauto.Context, mousePc, touchPc pointer.Context, close closeMethod) error {
	notificationBounds, err := ui.Location(ctx, nodewith.ClassName("ArcNotificationContentView"))
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	switch close {
	case swipeOut:
		if err := touchPc.Drag(
			notificationBounds.CenterPoint(),
			touchPc.DragTo(coords.NewPoint(0, notificationBounds.CenterPoint().Y), time.Second))(ctx); err != nil {
			return errors.Wrap(err, "failed to swipe out the notification")
		}
	case clickEvent:
		if err := mousePc.ClickAt(notificationBounds.CenterPoint())(ctx); err != nil {
			return errors.Wrap(err, "failed to click the notification")
		}
	case clearAllButton:
		if err := ui.LeftClick(nodewith.Role(role.StaticText).Name("Clear all"))(ctx); err != nil {
			return errors.Wrap(err, "failed to click 'Clear all' button")
		}
	case closeButton:
		if err := mouse.Move(tconn, notificationBounds.CenterPoint(), time.Second)(ctx); err != nil {
			return errors.Wrap(err, "failed to move mouse on the notification")
		}
		if err := ui.LeftClick(nodewith.Role(role.Button).Name("Notification close"))(ctx); err != nil {
			return errors.Wrap(err, "failed to click notification close button")
		}
	}

	return nil
}

func clickExpandButtonAndWaitForAnimation(ctx context.Context, ui *uiauto.Context, mousePc pointer.Context) error {
	initialBounds, err := ui.Location(ctx, arcNotificationContentView)
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	// TODO(b/224685870): Use UIAutomator to get the button position dynamically when it supports multi-display.
	if err := mousePc.ClickAt(coords.NewPoint(initialBounds.Right()-28, initialBounds.Top+44))(ctx); err != nil {
		return errors.Wrap(err, "failed to click the notification")
	}

	// Wait until animation finished.
	if err := ui.WaitForLocation(arcNotificationContentView)(ctx); err != nil {
		return errors.Wrap(err, "the notification did not stop animating")
	}

	return nil
}

func testExpandButton(ctx context.Context, ui *uiauto.Context, mousePc pointer.Context) error {
	initialBounds, err := ui.Location(ctx, arcNotificationContentView)
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	if err := clickExpandButtonAndWaitForAnimation(ctx, ui, mousePc); err != nil {
		return errors.Wrap(err, "failed to click the expand button to collapse")
	}

	collapsedBounds, err := ui.Location(ctx, arcNotificationContentView)
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	if collapsedBounds.Width != initialBounds.Width {
		return errors.Wrapf(err, "the collapsed width (%d) should be equals to the initial width (%d)", collapsedBounds.Width, initialBounds.Width)
	}
	if collapsedBounds.Height >= initialBounds.Height {
		return errors.Wrapf(err, "the collapsed height (%d) should be less than the initial height (%d)", collapsedBounds.Height, initialBounds.Height)
	}

	if err := clickExpandButtonAndWaitForAnimation(ctx, ui, mousePc); err != nil {
		return errors.Wrap(err, "failed to click the expand button to expand")
	}

	expandedBounds, err := ui.Location(ctx, arcNotificationContentView)
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	if !expandedBounds.Equals(*initialBounds) {
		return errors.Wrapf(err, "the expanded bounds (%v) should be equals to the initial bounds (%v)", expandedBounds, initialBounds)
	}

	return nil
}

func testExpandNotification(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *androidui.Device, ui *uiauto.Context, mousePc pointer.Context, style string) error {
	if err := quicksettings.Show(ctx, tconn); err != nil {
		return errors.Wrap(err, "failed to open Quick Settings")
	}
	defer quicksettings.Hide(ctx, tconn)

	if _, err := a.BroadcastIntent(ctx, arcNotificationTest2StartCommand, "-p", arcNotificationTest2PackageName, "--es", "style", style, "--ez", "autoCancel", "true", "--esn", "notify"); err != nil {
		return errors.Wrap(err, "failed to send a broadcast")
	}

	notification, err := ash.WaitForNotification(ctx, tconn, 5*time.Second, ash.WaitIDContains(arcNotificationTest2NotificationID))
	if err != nil {
		return errors.Wrap(err, "failed to wait until the notification appears")
	}

	// Wait until the ARC notification surface gets ready
	if err := ui.WaitUntilExists(arcNotificationSurface)(ctx); err != nil {
		return errors.Wrap(err, "failed to wait until the surface gets ready")
	}

	if err := testExpandButton(ctx, ui, mousePc); err != nil {
		return errors.Wrap(err, "failed to test expand button")
	}

	if err := ash.CloseNotifications(ctx, tconn); err != nil {
		return errors.Wrap(err, "failed to close the notification")
	}

	if err := ash.WaitUntilNotificationGone(ctx, tconn, 5*time.Second, ash.WaitIDContains(notification.ID)); err != nil {
		return errors.Wrap(err, "failed to wait until the notification disappears")
	}

	return nil
}

func testCloseNotification(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *androidui.Device, ui *uiauto.Context, mousePc, touchPc pointer.Context, style string, close closeMethod) error {
	if err := quicksettings.Show(ctx, tconn); err != nil {
		return errors.Wrap(err, "failed to open Quick Settings")
	}
	defer quicksettings.Hide(ctx, tconn)

	if _, err := a.BroadcastIntent(ctx, arcNotificationTest2StartCommand, "-p", arcNotificationTest2PackageName, "--es", "style", style, "--ez", "autoCancel", "true", "--esn", "notify"); err != nil {
		return errors.Wrap(err, "failed to send a broadcast")
	}

	notification, err := ash.WaitForNotification(ctx, tconn, 5*time.Second, ash.WaitIDContains(arcNotificationTest2NotificationID))
	if err != nil {
		return errors.Wrap(err, "failed to wait until the notification appears")
	}

	// Wait until the ARC notification surface gets ready
	if err := ui.WaitUntilExists(arcNotificationSurface)(ctx); err != nil {
		return errors.Wrap(err, "failed to wait until the surface gets ready")
	}

	if err := closeNotification(ctx, tconn, ui, mousePc, touchPc, close); err != nil {
		return errors.Wrap(err, "failed to close the notification")
	}

	if err := ash.WaitUntilNotificationGone(ctx, tconn, 5*time.Second, ash.WaitIDContains(notification.ID)); err != nil {
		return errors.Wrap(err, "failed to wait until the notification disappears")
	}

	return nil
}

func NotificationExperimental(ctx context.Context, s *testing.State) {
	// Reserve ten seconds for various cleanup.
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, time.Second*10)
	defer cancel()

	cr := s.FixtValue().(*arc.PreData).Chrome
	tconn, err := cr.TestAPIConn(ctx)
	if err != nil {
		s.Fatal("Failed to create Test API connection: ", err)
	}
	a := s.FixtValue().(*arc.PreData).ARC
	d := s.FixtValue().(*arc.PreData).UIDevice
	ui := uiauto.New(tconn).WithTimeout(5 * time.Second)

	mousePc := pointer.NewMouse(tconn)
	defer mousePc.Close()

	touchPc, err := pointer.NewTouch(ctx, tconn)
	if err != nil {
		s.Fatal("Failed to set up the touch context: ", err)
	}
	defer touchPc.Close()

	// Install the test app.
	if err := a.Install(ctx, s.DataPath(arcNotificationTest2ApkFilename)); err != nil {
		s.Fatal("Failed to install app: ", err)
	}
	defer a.Uninstall(cleanupCtx, arcNotificationTest2PackageName)

	// Launch the test app.
	act, err := arc.NewActivity(a, arcNotificationTest2PackageName, arcNotificationTest2ActivityName)
	if err != nil {
		s.Fatal("Failed to create a new activity: ", err)
	}
	defer act.Close()
	if err := act.Start(ctx, tconn); err != nil {
		s.Fatal("Failed to start the activity: ", err)
	}
	defer act.Stop(cleanupCtx, tconn)
	if err := ash.WaitForVisible(ctx, tconn, act.PackageName()); err != nil {
		s.Fatal("Failed to wait until the activity gets visible: ", err)
	}
	if err := d.WaitForIdle(ctx, 10*time.Second); err != nil {
		s.Fatal("Failed to wait for Android to be idle: ", err)
	}

	// Test notification closing.
	for _, style := range []string{"basic", "big_text", "big_picture", "inbox", "messaging"} {
		for _, close := range []closeMethod{swipeOut, clickEvent, clearAllButton, closeButton} {
			s.Run(ctx, fmt.Sprintf("Close notification (style=%s closeMethod=%s)", style, close), func(ctx context.Context, s *testing.State) {
				// Cleanup
				defer ash.CloseNotifications(ctx, tconn)

				if err := testCloseNotification(ctx, tconn, a, d, ui, mousePc, touchPc, style, close); err != nil {
					s.Fatal("Failed to test to close a notification: ", err)
				}
			})
		}
	}

	// Test notification expanding.
	for _, style := range []string{"big_text", "big_picture", "inbox"} {
		s.Run(ctx, fmt.Sprintf("Expand notification (style=%s)", style), func(ctx context.Context, s *testing.State) {
			// Cleanup
			defer ash.CloseNotifications(ctx, tconn)

			if err := testExpandNotification(ctx, tconn, a, d, ui, mousePc, style); err != nil {
				s.Fatal("Failed to test to expand a notification: ", err)
			}
		})
	}
}
