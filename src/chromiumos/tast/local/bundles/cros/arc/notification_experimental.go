// Copyright 2022 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package arc

import (
	"context"
	"fmt"
	"time"

	"chromiumos/tast/ctxutil"
	"chromiumos/tast/errors"
	"chromiumos/tast/local/arc"
	"chromiumos/tast/local/chrome"
	"chromiumos/tast/local/chrome/ash"
	"chromiumos/tast/local/chrome/uiauto"
	"chromiumos/tast/local/chrome/uiauto/mouse"
	"chromiumos/tast/local/chrome/uiauto/nodewith"
	"chromiumos/tast/local/chrome/uiauto/pointer"
	"chromiumos/tast/local/chrome/uiauto/quicksettings"
	"chromiumos/tast/local/chrome/uiauto/role"
	"chromiumos/tast/local/coords"
	"chromiumos/tast/testing"
)

const (
	arcNotificationTest2ApkFilename  = "ArcNotificationTest2.apk"
	arcNotificationTest2PackageName  = "org.chromium.arc.testapp.notification2"
	arcNotificationTest2ActivityName = ".MainActivity"
	arcNotificationTest2StartCommand = arcNotificationTest2PackageName + ".SHOW_NOTIFICATION"
	// Notification ID on Android is composed of many components.
	// So this is just the substring to match the notification generated by the test app.
	arcNotificationTest2NotificationID = "|" + arcNotificationTest2PackageName + "|"
)

type closeMethod string

const (
	closeMethodSwipeOut       closeMethod = "swipeOut"
	closeMethodClickEvent                 = "clickEvent"
	closeMethodClearAllButton             = "clearAllButton"
	closeMethodCloseButton                = "closeButton"
)

var (
	arcNotificationContentView = nodewith.HasClass("ArcNotificationContentView")
	arcNotificationSurface     = nodewith.HasClass("ArcNotificationSurface")
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         NotificationExperimental,
		LacrosStatus: testing.LacrosVariantUnneeded,
		Desc:         "Launches a testing APK to generate various kinds of notifications and verifies its state",
		Contacts: []string{
			"toshikikikuchi@chromium.org",
			"yhanada@chromium.org",
			"arc-framework+tast@google.com",
		},
		Attr:         []string{"group:mainline", "informational"},
		Data:         []string{arcNotificationTest2ApkFilename},
		Fixture:      "arcBootedWithNotificationRefresh",
		SoftwareDeps: []string{"chrome"},
		Timeout:      4 * time.Minute,
		Params: []testing.Param{{
			ExtraSoftwareDeps: []string{"android_p"},
		}, {
			Name:              "vm",
			ExtraSoftwareDeps: []string{"android_vm"},
		}},
	})
}

func closeNotification(ctx context.Context, tconn *chrome.TestConn, ui *uiauto.Context, mousePC, touchPC pointer.Context, close closeMethod) error {
	notificationBounds, err := ui.Location(ctx, arcNotificationContentView)
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	switch close {
	case closeMethodSwipeOut:
		if err := touchPC.Drag(
			notificationBounds.CenterPoint(),
			touchPC.DragTo(coords.NewPoint(0, notificationBounds.CenterPoint().Y), 500*time.Millisecond))(ctx); err != nil {
			return errors.Wrap(err, "failed to swipe out the notification")
		}
	case closeMethodClickEvent:
		if err := mousePC.ClickAt(notificationBounds.CenterPoint())(ctx); err != nil {
			return errors.Wrap(err, "failed to click the notification")
		}
	case closeMethodClearAllButton:
		if err := ui.LeftClick(nodewith.Role(role.StaticText).Name("Clear all"))(ctx); err != nil {
			return errors.Wrap(err, "failed to click 'Clear all' button")
		}
	case closeMethodCloseButton:
		if err := mouse.Move(tconn, notificationBounds.CenterPoint(), time.Second)(ctx); err != nil {
			return errors.Wrap(err, "failed to move mouse on the notification")
		}
		if err := ui.LeftClick(nodewith.Role(role.Button).Name("Notification close"))(ctx); err != nil {
			return errors.Wrap(err, "failed to click notification close button")
		}
	}

	return nil
}

func composeNotification(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, ui *uiauto.Context, style string) (*ash.Notification, error) {
	if _, err := a.BroadcastIntent(ctx, arcNotificationTest2StartCommand, "-p", arcNotificationTest2PackageName, "--es", "style", style, "--ez", "autoCancel", "true", "--esn", "notify"); err != nil {
		return nil, errors.Wrap(err, "failed to send a broadcast")
	}

	notification, err := ash.WaitForNotification(ctx, tconn, 5*time.Second, ash.WaitIDContains(arcNotificationTest2NotificationID))
	if err != nil {
		return nil, errors.Wrap(err, "failed to wait until the notification appears")
	}

	// Wait until the ARC notification surface gets ready
	if err := ui.WaitUntilExists(arcNotificationSurface)(ctx); err != nil {
		return nil, errors.Wrap(err, "failed to wait until the surface gets ready")
	}

	return notification, nil
}

func clickExpandButtonAndWaitForAnimation(ctx context.Context, ui *uiauto.Context, mousePC pointer.Context) error {
	bounds, err := ui.Location(ctx, arcNotificationContentView)
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	// TODO(b/224685870): Use UIAutomator to get the button position dynamically when it supports multi-display.
	expandButtonOffset := coords.NewPoint(-28, 44)
	if err := mousePC.ClickAt(bounds.TopRight().Add(expandButtonOffset))(ctx); err != nil {
		return errors.Wrap(err, "failed to click the notification")
	}

	// Wait until animation finished.
	if err := ui.WaitForLocation(arcNotificationContentView)(ctx); err != nil {
		return errors.Wrap(err, "the notification did not stop animating")
	}

	return nil
}

func testExpandButton(ctx context.Context, ui *uiauto.Context, mousePC pointer.Context) error {
	initialBounds, err := ui.Location(ctx, arcNotificationContentView)
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	if err := clickExpandButtonAndWaitForAnimation(ctx, ui, mousePC); err != nil {
		return errors.Wrap(err, "failed to click the expand button to collapse")
	}

	collapsedBounds, err := ui.Location(ctx, arcNotificationContentView)
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	if collapsedBounds.Width != initialBounds.Width {
		return errors.Wrapf(err, "the collapsed width (%d) should be equals to the initial width (%d)", collapsedBounds.Width, initialBounds.Width)
	}
	if collapsedBounds.Height >= initialBounds.Height {
		return errors.Wrapf(err, "the collapsed height (%d) should be less than the initial height (%d)", collapsedBounds.Height, initialBounds.Height)
	}

	if err := clickExpandButtonAndWaitForAnimation(ctx, ui, mousePC); err != nil {
		return errors.Wrap(err, "failed to click the expand button to expand")
	}

	expandedBounds, err := ui.Location(ctx, arcNotificationContentView)
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	if !expandedBounds.Equals(*initialBounds) {
		return errors.Wrapf(err, "the expanded bounds (%v) should be equals to the initial bounds (%v)", expandedBounds, initialBounds)
	}

	return nil
}

func testExpandNotification(ctx, cleanupCtx context.Context, tconn *chrome.TestConn, a *arc.ARC, ui *uiauto.Context, mousePC pointer.Context, style string) error {
	if err := quicksettings.Show(ctx, tconn); err != nil {
		return errors.Wrap(err, "failed to open Quick Settings")
	}
	defer quicksettings.Hide(cleanupCtx, tconn)

	if _, err := composeNotification(ctx, tconn, a, ui, style); err != nil {
		return errors.Wrap(err, "failed to compose a notification")
	}

	if err := testExpandButton(ctx, ui, mousePC); err != nil {
		return errors.Wrap(err, "failed to test expand button")
	}

	return nil
}

func testCloseNotification(ctx, cleanupCtx context.Context, tconn *chrome.TestConn, a *arc.ARC, ui *uiauto.Context, mousePC, touchPC pointer.Context, style string, close closeMethod) error {
	if err := quicksettings.Show(ctx, tconn); err != nil {
		return errors.Wrap(err, "failed to open Quick Settings")
	}
	defer quicksettings.Hide(cleanupCtx, tconn)

	notification, err := composeNotification(ctx, tconn, a, ui, style)
	if err != nil {
		return errors.Wrap(err, "failed to compose a notification")
	}

	if err := closeNotification(ctx, tconn, ui, mousePC, touchPC, close); err != nil {
		return errors.Wrap(err, "failed to close the notification")
	}

	if err := ash.WaitUntilNotificationGone(ctx, tconn, 5*time.Second, ash.WaitIDContains(notification.ID)); err != nil {
		return errors.Wrap(err, "failed to wait until the notification disappears")
	}

	return nil
}

func NotificationExperimental(ctx context.Context, s *testing.State) {
	// Reserve ten seconds for various cleanup.
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, time.Second*10)
	defer cancel()

	cr := s.FixtValue().(*arc.PreData).Chrome
	tconn, err := cr.TestAPIConn(ctx)
	if err != nil {
		s.Fatal("Failed to create Test API connection: ", err)
	}
	a := s.FixtValue().(*arc.PreData).ARC
	d := s.FixtValue().(*arc.PreData).UIDevice
	ui := uiauto.New(tconn).WithTimeout(5 * time.Second)

	mousePC := pointer.NewMouse(tconn)
	defer mousePC.Close()

	touchPC, err := pointer.NewTouch(ctx, tconn)
	if err != nil {
		s.Fatal("Failed to set up the touch context: ", err)
	}
	defer touchPC.Close()

	// Install the test app.
	if err := a.Install(ctx, s.DataPath(arcNotificationTest2ApkFilename)); err != nil {
		s.Fatal("Failed to install app: ", err)
	}
	defer a.Uninstall(cleanupCtx, arcNotificationTest2PackageName)

	// Launch the test app.
	act, err := arc.NewActivity(a, arcNotificationTest2PackageName, arcNotificationTest2ActivityName)
	if err != nil {
		s.Fatal("Failed to create a new activity: ", err)
	}
	defer act.Close()
	if err := act.Start(ctx, tconn); err != nil {
		s.Fatal("Failed to start the activity: ", err)
	}
	defer act.Stop(cleanupCtx, tconn)
	if err := ash.WaitForVisible(ctx, tconn, act.PackageName()); err != nil {
		s.Fatal("Failed to wait until the activity gets visible: ", err)
	}
	if err := d.WaitForIdle(ctx, 10*time.Second); err != nil {
		s.Fatal("Failed to wait for Android to be idle: ", err)
	}

	// Test notification closing.
	for _, style := range []string{"basic", "big_text", "big_picture", "inbox", "messaging"} {
		for _, close := range []closeMethod{closeMethodSwipeOut, closeMethodClickEvent, closeMethodClearAllButton, closeMethodCloseButton} {
			s.Run(ctx, fmt.Sprintf("Close notification (style=%s closeMethod=%s)", style, close), func(ctx context.Context, s *testing.State) {
				// Cleanup
				defer ash.CloseNotifications(cleanupCtx, tconn)

				if err := testCloseNotification(ctx, cleanupCtx, tconn, a, ui, mousePC, touchPC, style, close); err != nil {
					s.Fatal("Failed to test to close a notification: ", err)
				}
			})
		}
	}

	// Test notification expanding.
	for _, style := range []string{"big_text", "big_picture", "inbox"} {
		s.Run(ctx, fmt.Sprintf("Expand notification (style=%s)", style), func(ctx context.Context, s *testing.State) {
			// Cleanup
			defer ash.CloseNotifications(cleanupCtx, tconn)

			if err := testExpandNotification(ctx, cleanupCtx, tconn, a, ui, mousePC, style); err != nil {
				s.Fatal("Failed to test to expand a notification: ", err)
			}
		})
	}
}
