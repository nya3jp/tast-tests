// Copyright 2022 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package arc

import (
	"context"
	"time"

	androidui "chromiumos/tast/common/android/ui"
	"chromiumos/tast/ctxutil"
	"chromiumos/tast/errors"
	"chromiumos/tast/local/arc"
	"chromiumos/tast/local/chrome"
	"chromiumos/tast/local/chrome/ash"
	"chromiumos/tast/local/chrome/uiauto"
	"chromiumos/tast/local/chrome/uiauto/mouse"
	"chromiumos/tast/local/chrome/uiauto/nodewith"
	"chromiumos/tast/local/chrome/uiauto/pointer"
	"chromiumos/tast/local/chrome/uiauto/quicksettings"
	"chromiumos/tast/local/chrome/uiauto/role"
	"chromiumos/tast/local/coords"
	"chromiumos/tast/testing"
)

const (
	arcNotificationTest2ApkFilename  = "ArcNotificationTest2.apk"
	arcNotificationTest2PackageName  = "org.chromium.arc.testapp.notification2"
	arcNotificationTest2ActivityName = ".MainActivity"
	arcNotificationTest2StartCommand = arcNotificationTest2PackageName + ".SHOW_NOTIFICATION"
	// Notification ID on Android is composed of many components.
	// So this is just the substring to match the notification generated by the test app.
	arcNotificationTest2NotificationID = "|" + arcNotificationTest2PackageName + "|"
)

type closeMethod string

const (
	swipeOut       closeMethod = "swipeOut"
	clickEvent                 = "clickEvent"
	clearAllButton             = "clearAllButton"
	closeButton                = "closeButton"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         NotificationExperimental,
		LacrosStatus: testing.LacrosVariantUnneeded,
		Desc:         "Launches a testing APK to generate various kinds of notifications and verifies its state",
		Contacts: []string{
			"toshikikikuchi@chromium.org",
			"yhanada@chromium.org",
			"arc-framework+tast@google.com",
		},
		Attr:         []string{"group:mainline", "informational"},
		Data:         []string{arcNotificationTest2ApkFilename},
		Fixture:      "arcBootedWithNotificationRefresh",
		SoftwareDeps: []string{"chrome"},
		Timeout:      4 * time.Minute,
		Params: []testing.Param{{
			ExtraSoftwareDeps: []string{"android_p"},
		}, {
			Name:              "vm",
			ExtraSoftwareDeps: []string{"android_vm"},
		}},
	})
}

func closeNotification(ctx context.Context, tconn *chrome.TestConn, ui *uiauto.Context, mousePc, touchPc pointer.Context, close closeMethod) error {
	notificationBounds, err := ui.Location(ctx, nodewith.ClassName("ArcNotificationContentView"))
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	switch close {
	case swipeOut:
		if err := touchPc.Drag(
			notificationBounds.CenterPoint(),
			touchPc.DragTo(coords.NewPoint(0, notificationBounds.CenterPoint().Y), time.Second))(ctx); err != nil {
			return errors.Wrap(err, "failed to swipe out the notification")
		}
	case clickEvent:
		if err := mousePc.ClickAt(notificationBounds.CenterPoint())(ctx); err != nil {
			return errors.Wrap(err, "failed to click the notification")
		}
	case clearAllButton:
		if err := ui.LeftClick(nodewith.Role(role.StaticText).Name("Clear all"))(ctx); err != nil {
			return errors.Wrap(err, "failed to click 'Clear all' button")
		}
	case closeButton:
		if err := mouse.Move(tconn, notificationBounds.CenterPoint(), time.Second)(ctx); err != nil {
			return errors.Wrap(err, "failed to move mouse on the notification")
		}
		if err := ui.LeftClick(nodewith.Role(role.Button).Name("Notification close"))(ctx); err != nil {
			return errors.Wrap(err, "failed to click notification close button")
		}
	}

	return nil
}

func testForStyle(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, d *androidui.Device, ui *uiauto.Context, mousePc, touchPc pointer.Context, style string, close closeMethod) error {
	if err := quicksettings.Show(ctx, tconn); err != nil {
		return errors.Wrap(err, "failed to open Quick Settings")
	}
	defer quicksettings.Hide(ctx, tconn)

	if _, err := a.BroadcastIntent(ctx, arcNotificationTest2StartCommand, "-p", arcNotificationTest2PackageName, "--es", "style", style, "--ez", "autoCancel", "true", "--esn", "notify"); err != nil {
		return errors.Wrap(err, "failed to send a broadcast")
	}

	notification, err := ash.WaitForNotification(ctx, tconn, 5*time.Second, ash.WaitIDContains(arcNotificationTest2NotificationID))
	if err != nil {
		return errors.Wrap(err, "failed to wait until the notification appears")
	}

	if err := d.WaitForIdle(ctx, 10*time.Second); err != nil {
		return errors.Wrap(err, "failed to wait for Android to be idle")
	}

	if err := closeNotification(ctx, tconn, ui, mousePc, touchPc, close); err != nil {
		return errors.Wrap(err, "failed to close the notification")
	}

	if err := ash.WaitUntilNotificationGone(ctx, tconn, 5*time.Second, ash.WaitIDContains(notification.ID)); err != nil {
		return errors.Wrap(err, "failed to wait until the notification disappears")
	}

	return nil
}

func NotificationExperimental(ctx context.Context, s *testing.State) {
	// Reserve ten seconds for various cleanup.
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, time.Second*10)
	defer cancel()

	cr := s.FixtValue().(*arc.PreData).Chrome
	tconn, err := cr.TestAPIConn(ctx)
	if err != nil {
		s.Fatal("Failed to create Test API connection: ", err)
	}
	a := s.FixtValue().(*arc.PreData).ARC
	d := s.FixtValue().(*arc.PreData).UIDevice
	ui := uiauto.New(tconn).WithTimeout(5 * time.Second)

	mousePc := pointer.NewMouse(tconn)
	defer mousePc.Close()

	touchPc, err := pointer.NewTouch(ctx, tconn)
	if err != nil {
		s.Fatal("Failed to set up the touch context: ", err)
	}
	defer touchPc.Close()

	// Install the test app.
	if err := a.Install(ctx, s.DataPath(arcNotificationTest2ApkFilename)); err != nil {
		s.Fatal("Failed to install app: ", err)
	}
	defer a.Uninstall(cleanupCtx, arcNotificationTest2PackageName)

	// Launch the test app.
	act, err := arc.NewActivity(a, arcNotificationTest2PackageName, arcNotificationTest2ActivityName)
	if err != nil {
		s.Fatal("Failed to create a new activity: ", err)
	}
	defer act.Close()
	if err := act.Start(ctx, tconn); err != nil {
		s.Fatal("Failed to start the activity: ", err)
	}
	defer act.Stop(cleanupCtx, tconn)
	if err := ash.WaitForVisible(ctx, tconn, act.PackageName()); err != nil {
		s.Fatal("Failed to wait until the activity gets visible: ", err)
	}
	if err := d.WaitForIdle(ctx, 10*time.Second); err != nil {
		s.Fatal("Failed to wait for Android to be idle: ", err)
	}

	// Test a single notification with a style.
	for _, style := range []string{"basic", "big_text", "big_picture", "inbox", "messaging"} {
		for _, close := range []closeMethod{swipeOut, clickEvent, clearAllButton, closeButton} {
			if err := testForStyle(ctx, tconn, a, d, ui, mousePc, touchPc, style, close); err != nil {
				s.Errorf("Failed to test a notification with style=%s closeMethod=%s: %v", style, close, err)
				if err := ash.CloseNotifications(ctx, tconn); err != nil {
					s.Fatal("Failed to close notifications")
				}
			}
		}
	}
}
