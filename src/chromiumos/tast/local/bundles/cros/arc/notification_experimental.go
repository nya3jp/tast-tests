// Copyright 2022 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package arc

import (
	"context"
	"time"

	"chromiumos/tast/ctxutil"
	"chromiumos/tast/errors"
	"chromiumos/tast/local/arc"
	"chromiumos/tast/local/chrome"
	"chromiumos/tast/local/chrome/ash"
	"chromiumos/tast/local/chrome/uiauto"
	"chromiumos/tast/local/chrome/uiauto/nodewith"
	"chromiumos/tast/local/chrome/uiauto/pointer"
	"chromiumos/tast/local/chrome/uiauto/quicksettings"
	"chromiumos/tast/testing"
)

const (
	arcNotificationTest2ApkFilename  = "ArcNotificationTest2.apk"
	arcNotificationTest2PackageName  = "org.chromium.arc.testapp.notification2"
	arcNotificationTest2ActivityName = ".MainActivity"
	arcNotificationTest2StartCommand = arcNotificationTest2PackageName + ".SHOW_NOTIFICATION"
	// Notification ID on Android is composed of many components.
	// So this is just the substring to match the notification generated by the test app.
	arcNotificationTest2NotificationID = "|" + arcNotificationTest2PackageName + "|"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         NotificationExperimental,
		LacrosStatus: testing.LacrosVariantUnneeded,
		Desc:         "Launches a testing APK to generate various kinds of notifications and verifies its state",
		Contacts: []string{
			"toshikikikuchi@chromium.org",
			"yhanada@chromium.org",
			"arc-framework+tast@google.com",
		},
		Attr:         []string{"group:mainline", "informational"},
		Data:         []string{arcNotificationTest2ApkFilename},
		Fixture:      "arcBootedWithNotificationRefresh",
		SoftwareDeps: []string{"chrome"},
		Timeout:      4 * time.Minute,
		Params: []testing.Param{{
			ExtraSoftwareDeps: []string{"android_p"},
		}, {
			Name:              "vm",
			ExtraSoftwareDeps: []string{"android_vm"},
		}},
	})
}

func testForStyle(ctx context.Context, tconn *chrome.TestConn, a *arc.ARC, ui *uiauto.Context, pc pointer.Context, style string) error {
	if err := quicksettings.Show(ctx, tconn); err != nil {
		return errors.Wrap(err, "failed to open Quick Settings")
	}
	defer quicksettings.Hide(ctx, tconn)

	if _, err := a.BroadcastIntent(ctx, arcNotificationTest2StartCommand, "-p", arcNotificationTest2PackageName, "--es", "style", style, "--ez", "autoCancel", "true", "--esn", "notify"); err != nil {
		return errors.Wrap(err, "failed to send a broadcast")
	}

	notification, err := ash.WaitForNotification(ctx, tconn, 5*time.Second, ash.WaitIDContains(arcNotificationTest2NotificationID))
	if err != nil {
		return errors.Wrap(err, "failed to wait until the notification appears")
	}

	// Sleep to wait until the notification surface is available.
	if err := testing.Sleep(ctx, 3*time.Second); err != nil {
		return errors.Wrap(err, "failed to sleep")
	}

	notificationBounds, err := ui.Location(ctx, nodewith.ClassName("ArcNotificationView"))
	if err != nil {
		return errors.Wrap(err, "failed to get the notification bounds")
	}

	if err := pc.ClickAt(notificationBounds.CenterPoint())(ctx); err != nil {
		return errors.Wrap(err, "failed to click the notification")
	}

	if err := ash.WaitUntilNotificationGone(ctx, tconn, 5*time.Second, ash.WaitIDContains(arcNotificationTest2NotificationID.ID)); err != nil {
		return errors.Wrap(err, "failed to wait until the notification disappears")
	}

	return nil
}

func NotificationExperimental(ctx context.Context, s *testing.State) {
	// Reserve ten seconds for various cleanup.
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, time.Second*10)
	defer cancel()

	cr := s.FixtValue().(*arc.PreData).Chrome
	tconn, err := cr.TestAPIConn(ctx)
	if err != nil {
		s.Fatal("Failed to create Test API connection: ", err)
	}
	a := s.FixtValue().(*arc.PreData).ARC
	d := s.FixtValue().(*arc.PreData).UIDevice
	ui := uiauto.New(tconn)

	pc := pointer.NewMouse(tconn)
	defer pc.Close()

	// Install the test app.
	if err := a.Install(ctx, s.DataPath(arcNotificationTest2ApkFilename)); err != nil {
		s.Fatal("Failed to install app: ", err)
	}
	defer a.Uninstall(cleanupCtx, arcNotificationTest2PackageName)

	// Launch the test app.
	act, err := arc.NewActivity(a, arcNotificationTest2PackageName, arcNotificationTest2ActivityName)
	if err != nil {
		s.Fatal("Failed to create a new activity: ", err)
	}
	defer act.Close()
	if err := act.Start(ctx, tconn); err != nil {
		s.Fatal("Failed to start the activity: ", err)
	}
	defer act.Stop(cleanupCtx, tconn)
	if err := ash.WaitForVisible(ctx, tconn, act.PackageName()); err != nil {
		s.Fatal("Failed to wait until the activity gets visible: ", err)
	}
	if err := d.WaitForIdle(ctx, 10*time.Second); err != nil {
		s.Fatal("Failed to wait for Android to be idle: ", err)
	}

	// Test a single notification with a style.
	for _, style := range []string{"basic", "big_text", "big_picture", "inbox", "messaging"} {
		if err := testForStyle(ctx, tconn, a, ui, pc, style); err != nil {
			s.Fatalf("Failed to test a notification with style=%s: %v", style, err)
		}
	}
}
