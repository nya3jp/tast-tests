// Copyright 2022 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package arc

import (
	"context"
	"encoding/binary"
	"io"
	"math"
	"os"
	"path/filepath"
	"time"

	"chromiumos/tast/common/testexec"
	"chromiumos/tast/ctxutil"
	"chromiumos/tast/errors"
	"chromiumos/tast/local/arc"
	"chromiumos/tast/local/audio"
	"chromiumos/tast/local/audio/crastestclient"
	arcaudio "chromiumos/tast/local/bundles/cros/arc/audio"
	"chromiumos/tast/local/chrome/ash"
	"chromiumos/tast/local/chrome/uiauto/faillog"
	"chromiumos/tast/local/chrome/uiauto/quicksettings"
	"chromiumos/tast/testing"
	"chromiumos/tast/testing/hwdep"
)

var lowPerformanceModel = []string{
	// dedede
	"beadrix", "beetley", "blipper", "bookem", "boten", "bugzzy",
	"cret", "cret360", "drawcia", "drawlat", "drawman", "drawper",
	"galith", "galith360", "gallop", "galnat", "galnat360", "galtic",
	"galtic360", "kracko", "kracko360", "landia", "landrid", "lantis",
	"madoo", "magister", "maglet", "maglia", "maglith", "magma",
	"magneto", "magolor", "magpie", "metaknight", "pasara", "pirette",
	"pirika", "sasuke", "sasukette", "storo", "storo360",
	// octopus
	"ampton", "apel", "bloog", "blooglet", "blooguard", "blorb",
	"bluebird", "bobba", "bobba360", "casta", "dood", "dorp", "droid",
	"fleex", "foob", "foob360", "garfour", "garg", "garg360",
	"grabbiter", "laser14", "lick", "meep", "mimrock", "nospike",
	"orbatrix", "phaser", "phaser360", "sparky", "sparky360",
	"vorticon", "vortininja",
	// fizz
	"jax",
	// hatch
	"akemi", "nightfury",
	// puff
	"kaisa", "wyvern",
	// volteer
	"chronicler",
}

type audioLoopbackCorrectnessVal struct {
	arcaudioTestParams   arcaudio.TestParameters
	incorrectSlicesLimit int
}

func init() {
	testing.AddTest(&testing.Test{
		Func:         AudioLoopbackCorrectness,
		LacrosStatus: testing.LacrosVariantUnneeded,
		Desc:         "Plays sine wave with different config in ARC. Captures output audio via loopback and verifies the frequency of each channel",
		Contacts: []string{
			"chromeos-audio-bugs@google.com", // Media team
			"pteerapong@chromium.org",        // Author
		},
		SoftwareDeps: []string{"chrome", "arc"},
		Fixture:      "arcBooted",
		Attr:         []string{"group:mainline", "informational"},
		Timeout:      3 * time.Minute,
		Params: []testing.Param{
			// Parameters generated by audio_loopback_correctness_test.go. DO NOT EDIT.
			{
				Name:              "stereo_8000",
				ExtraHardwareDeps: hwdep.D(hwdep.SkipOnModel(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      8000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 2,
				},
			},
			{
				Name:              "stereo_11025",
				ExtraHardwareDeps: hwdep.D(hwdep.SkipOnModel(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      11025,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 2,
				},
			},
			{
				Name:              "stereo_16000",
				ExtraHardwareDeps: hwdep.D(hwdep.SkipOnModel(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      16000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 2,
				},
			},
			{
				Name:              "stereo_22050",
				ExtraHardwareDeps: hwdep.D(hwdep.SkipOnModel(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      22050,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 2,
				},
			},
			{
				Name:              "stereo_32000",
				ExtraHardwareDeps: hwdep.D(hwdep.SkipOnModel(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      32000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 2,
				},
			},
			{
				Name:              "stereo_44100",
				ExtraHardwareDeps: hwdep.D(hwdep.SkipOnModel(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      44100,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 2,
				},
			},
			{
				Name:              "stereo_48000",
				ExtraHardwareDeps: hwdep.D(hwdep.SkipOnModel(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      48000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 2,
				},
			},
			{
				Name:              "stereo_48000_powersaving",
				ExtraHardwareDeps: hwdep.D(hwdep.SkipOnModel(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      48000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModePowerSaving,
					},
					incorrectSlicesLimit: 2,
				},
			},
			{
				Name:              "stereo_48000_lowlatency",
				ExtraHardwareDeps: hwdep.D(hwdep.SkipOnModel(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      48000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeLowLatency,
					},
					incorrectSlicesLimit: 2,
				},
			},
			{
				Name:              "lowperf_stereo_8000",
				ExtraHardwareDeps: hwdep.D(hwdep.Model(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      8000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 10,
				},
			},
			{
				Name:              "lowperf_stereo_11025",
				ExtraHardwareDeps: hwdep.D(hwdep.Model(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      11025,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 10,
				},
			},
			{
				Name:              "lowperf_stereo_16000",
				ExtraHardwareDeps: hwdep.D(hwdep.Model(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      16000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 10,
				},
			},
			{
				Name:              "lowperf_stereo_22050",
				ExtraHardwareDeps: hwdep.D(hwdep.Model(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      22050,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 10,
				},
			},
			{
				Name:              "lowperf_stereo_32000",
				ExtraHardwareDeps: hwdep.D(hwdep.Model(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      32000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 10,
				},
			},
			{
				Name:              "lowperf_stereo_44100",
				ExtraHardwareDeps: hwdep.D(hwdep.Model(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      44100,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 10,
				},
			},
			{
				Name:              "lowperf_stereo_48000",
				ExtraHardwareDeps: hwdep.D(hwdep.Model(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      48000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeNone,
					},
					incorrectSlicesLimit: 10,
				},
			},
			{
				Name:              "lowperf_stereo_48000_powersaving",
				ExtraHardwareDeps: hwdep.D(hwdep.Model(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      48000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModePowerSaving,
					},
					incorrectSlicesLimit: 10,
				},
			},
			{
				Name:              "lowperf_stereo_48000_lowlatency",
				ExtraHardwareDeps: hwdep.D(hwdep.Model(lowPerformanceModel...)),
				Val: audioLoopbackCorrectnessVal{
					arcaudioTestParams: arcaudio.TestParameters{
						Class:           "org.chromium.arc.testapp.arcaudiotest.TestOutputSineActivity",
						SampleRate:      48000,
						ChannelConfig:   arcaudio.ChannelConfigOutStereo,
						PerformanceMode: arcaudio.PerformanceModeLowLatency,
					},
					incorrectSlicesLimit: 10,
				},
			},
		},
	})
}

// captureOutputAndReadData captures audio data and reads the data.
// The return data is a 2-d array, where arr[i] is the audio data of i-th channel.
func captureOutputAndReadData(ctx context.Context, output audio.TestRawData) ([][]int64, error) {
	if _, err := crastestclient.WaitForStreams(ctx, 5*time.Second); err != nil {
		return nil, errors.Wrap(err, "failed to wait for streams")
	}

	testing.ContextLog(ctx, "Capture output to ", output.Path)
	if err := crastestclient.CaptureFileCommand(
		ctx, output.Path,
		output.Duration,
		output.Channels,
		output.Rate).Run(testexec.DumpLogOnError); err != nil {
		return nil, errors.Wrap(err, "failed to capture data")
	}

	// Read file
	f, err := os.Open(output.Path)
	if err != nil {
		return nil, errors.Wrap(err, "failed to open file")
	}
	defer f.Close()

	// Each sample is 16-bit signed integer.
	// Data order: <ch 1 sample 1> <ch 2 sample 1> ... <ch 8 sample 1> <ch 1 sample 2> ...
	arr := make([][]int64, output.Channels)
	channel := 0
	var samp int16
	for {
		if err := binary.Read(f, binary.LittleEndian, &samp); err != nil {
			if err == io.EOF {
				break
			}
			return nil, errors.Wrap(err, "error while reading file")
		}
		arr[channel] = append(arr[channel], int64(samp))
		channel = (channel + 1) % output.Channels
	}

	return arr, nil
}

// analyzeData analyzes single channel audio data by slicing it into smaller slices, then check the
// frequency of each slice. There must be no more than `incorrectLimit` slices that have incorrect
// frequency to pass.
//
// Ignore slices in the beginning that contain only zeros and the first slice with non-zero data.
// The number of these slices must be less than `startingSlicesLimit`, or the test will fail.
func analyzeData(ctx context.Context, data []int64, sampleRate, expectedFreq float64, incorrectLimit int) error {
	const (
		samplesPerSlice     = 1000 // Number of samples per slice. 1000 on 48kHz = 21ms
		startingSlicesLimit = 24   // Max starting slices allowed. 24 on 48kHz = 500ms
		freqTolerance       = 10
	)

	isAnyNonZeroData := func(data []int64) bool {
		for _, d := range data {
			if d != 0 {
				return true
			}
		}
		return false
	}

	isStarting := true
	startingSlices := 0
	incorrectSlices := 0

	// Loop through each slice of data. Ignore the last slice if there is not enough data.
	for i := 0; i+samplesPerSlice <= len(data); i += samplesPerSlice {
		dataSlice := data[i : i+samplesPerSlice]
		if isStarting {
			if isAnyNonZeroData(dataSlice) {
				// First slice with non-zero data, still ignore this slice and start checking at the next slice.
				isStarting = false
			} else {
				startingSlices++
				if startingSlices > startingSlicesLimit {
					return errors.New("reached starting slices limit")
				}
			}
		} else {
			dataFloat := make([]float64, samplesPerSlice)
			for j := range dataSlice {
				dataFloat[j] = float64(dataSlice[j])
			}

			freq := arcaudio.GetFrequencyFromData(dataFloat, sampleRate)
			if math.Abs(freq-expectedFreq) > freqTolerance {
				testing.ContextLogf(ctx, "Slice %d frequency incorrect. expect:%.2f got:%.2f", i/samplesPerSlice, expectedFreq, freq)
				incorrectSlices++
			}
		}
	}

	if isStarting {
		return errors.New("not enough data to get out of starting phase")
	}
	if incorrectSlices > incorrectLimit {
		return errors.Errorf("incorrect slices count over limit, incorrect slices: %v, limit: %v", incorrectSlices, incorrectLimit)
	}
	return nil
}

// AudioLoopbackCorrectness plays sine wave with different config in ARC.
// Captures output audio via loopback and verifies the frequency of each channel.
func AudioLoopbackCorrectness(ctx context.Context, s *testing.State) {
	const (
		cleanupTime     = 30 * time.Second
		captureDuration = 3 // second(s)
		captureRate     = 48000
		retries         = 3

		keySampleRate      = "sample_rate"
		keyChannelConfig   = "channel_config"
		keyPerformanceMode = "perf_mode"
	)

	a := s.FixtValue().(*arc.PreData).ARC
	cr := s.FixtValue().(*arc.PreData).Chrome
	param := s.Param().(audioLoopbackCorrectnessVal)
	arcaudioTestParam := param.arcaudioTestParams

	tconn, err := cr.TestAPIConn(ctx)
	if err != nil {
		s.Fatal("Failed to create Test API connection: ", err)
	}

	// Reserve time to remove input file and unload ALSA loopback at the end of the test.
	cleanupCtx := ctx
	ctx, cancel := ctxutil.Shorten(ctx, cleanupTime)
	defer cancel()

	if err := quicksettings.Show(ctx, tconn); err != nil {
		s.Fatal("Failed to show Quick Settings: ", err)
	}
	defer quicksettings.Hide(cleanupCtx, tconn)

	// Defer this after deferring quicksettings.Hide to make sure quicksettings is still open when we
	// get the failure info.
	defer faillog.DumpUITreeOnError(cleanupCtx, s.OutDir(), s.HasError, tconn)

	// Set up capture (aloop) module.
	testing.ContextLog(ctx, "Setup aloop")
	unload, err := audio.LoadAloop(ctx)
	if err != nil {
		s.Fatal("Failed to load ALSA loopback module: ", err)
	}

	defer func(ctx context.Context) {
		// Wait for no stream before unloading aloop as unloading while there is a stream
		// will cause the stream in ARC to be in an invalid state.
		if err := crastestclient.WaitForNoStream(ctx, 5*time.Second); err != nil {
			s.Error("Wait for no stream error: ", err)
		}
		unload(ctx)
	}(cleanupCtx)

	// Select ALSA loopback output and input nodes as active nodes by UI.
	if err := quicksettings.SelectAudioOption(ctx, tconn, "Loopback Playback"); err != nil {
		s.Fatal("Failed to select ALSA loopback output: ", err)
	}
	// After selecting Loopback Playback, SelectAudioOption() sometimes detected that audio setting
	// is still opened while it is actually fading out, and failed to select Loopback Capture.
	// Call Hide() and Show() to reset the quicksettings menu first.
	quicksettings.Hide(ctx, tconn)
	quicksettings.Show(ctx, tconn)
	if err := quicksettings.SelectAudioOption(ctx, tconn, "Loopback Capture"); err != nil {
		s.Fatal("Failed to select ALSA loopback input: ", err)
	}

	testing.ContextLog(ctx, "Install app")
	if err := a.Install(ctx, arc.APKPath(arcaudio.Apk)); err != nil {
		s.Fatal("Failed to install app: ", err)
	}

	defer a.Uninstall(cleanupCtx, arcaudio.Pkg)

	pkg := arcaudio.Pkg
	activityName := arcaudioTestParam.Class
	output := audio.TestRawData{
		Path:          filepath.Join(s.OutDir(), "audio_loopback_recorded.raw"),
		BitsPerSample: 16,
		Channels:      8, // Loopback module has 8 channels.
		Rate:          captureRate,
		Duration:      captureDuration,
	}
	var expectedFreqs []int
	switch arcaudioTestParam.ChannelConfig {
	case arcaudio.ChannelConfigOutStereo:
		expectedFreqs = []int{200, 500}
	case arcaudio.ChannelConfigOutQuad:
		expectedFreqs = []int{200, 300, 400, 500}
	case arcaudio.ChannelConfigOut5Point1:
		expectedFreqs = []int{200, 250, 400, 450, 300, 350}
	}

	var lastErr error
	testPass := false
	for attempt := 1; attempt <= retries && !testPass; attempt++ {
		testing.ContextLogf(ctx, "Starting activity %s/%s (attempt %d/%d)", pkg, activityName, attempt, retries)

		func() {
			var activity *arc.Activity
			activity, lastErr = arc.NewActivity(a, pkg, activityName)
			if lastErr != nil {
				testing.ContextLogf(ctx, "Failed to create activity %q in package %q: %v", activityName, pkg, lastErr)
				return
			}
			defer activity.Close()

			if lastErr = activity.Start(ctx, tconn,
				arc.WithExtraIntUint64(keyPerformanceMode, uint64(arcaudioTestParam.PerformanceMode)),
				arc.WithExtraIntUint64(keySampleRate, arcaudioTestParam.SampleRate),
				arc.WithExtraIntUint64(keyChannelConfig, uint64(arcaudioTestParam.ChannelConfig))); lastErr != nil {
				testing.ContextLogf(ctx, "Failed to start activity %q in package %q: %v", activityName, pkg, lastErr)
				return
			}
			defer func(ctx context.Context) error {
				// Check that app is still running
				if _, err := ash.GetARCAppWindowInfo(ctx, tconn, activity.PackageName()); err != nil {
					return err
				}

				testing.ContextLog(ctx, "Stopping activities in package", pkg)
				return activity.Stop(ctx, tconn)
			}(cleanupCtx)

			var capturedData [][]int64
			capturedData, lastErr = captureOutputAndReadData(ctx, output)
			if lastErr != nil {
				testing.ContextLog(ctx, "Failed to capture output: ", lastErr)
				return
			}

			for channel := 0; channel < len(expectedFreqs); channel++ {
				expectedFreq := expectedFreqs[channel]
				if lastErr = analyzeData(ctx, capturedData[channel], float64(captureRate), float64(expectedFreq), param.incorrectSlicesLimit); lastErr != nil {
					testing.ContextLogf(ctx, "Channel %d failed: %v", channel+1, lastErr)
					return
				}
			}

			testPass = true
		}()
	}

	if !testPass {
		s.Fatal("Test failed for all attempts. Last error: ", lastErr)
	}
}
