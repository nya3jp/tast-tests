// Copyright 2018 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Copied from

package ui

import (
	"context"
	"io"
	"net/http"
	"net/http/httptest"
	"time"
	"fmt"

	"chromiumos/tast/local/chrome"
	"chromiumos/tast/local/chrome/ime"
	// Library for raw input
	"chromiumos/tast/local/input"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:         RulebasedImeTyping,
		Desc:         "Checks that the PK can type into a text field",
		Contacts:     []string{"essential-inputs-team@google.com"},
		Attr:         []string{"informational"},
		SoftwareDeps: []string{"chrome"},
	})
}

// Test data maps each M17N language to a mapping of inputs to outputs
// The M17N keyboard types are defined in
// https://cs.chromium.org/chromium/src/chrome/browser/resources/chromeos/input_method/google_xkb_manifest.json
var ruelbasedTestData map[string](map[string]string)= map[string](map[string]string){
	// The left strings can be generated by using runeKeyCodes or shiftedRuneKeyCodes defined in
	// `tast/local/input/key_mappings.go`
	"vkd_ar": map[string]string{
		"Hello":"أثممخ",
		"hello world": "اثممخ صخقمي",
		"google": "لخخلمث",
	},
	"vkd_bn_phone": map[string]string{
		"Hello":"ঃএল্লো",
		"google": "গূগ্লে",
		"":"",
	},
}

func RulebasedImeTyping(ctx context.Context, s *testing.State) {
	cr, err := chrome.New(ctx, chrome.ExtraArgs("--enable-virtual-keyboard"))
	if err != nil {
		s.Fatal("Failed to start Chrome: ", err)
	}
	defer cr.Close(ctx)

	tconn, err := cr.TestAPIConn(ctx)
	if err != nil {
		s.Fatal("Creating test API connection failed: ", err)
	}

	// Show a page with a text field that autofocuses. Turn off autocorrect as it
	// can interfere with the test.
	const html = `<input type="text" id="text" autocorrect="off" autofocus/>`
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Add("Content-Type", "text/html")
		io.WriteString(w, html)
	}))
	defer server.Close()

	conn, err := cr.NewConn(ctx, server.URL)
	if err != nil {
		s.Fatal("Creating renderer for test page failed: ", err)
	}
	defer conn.Close()

	// Wait for the text field to focus.
	if err := conn.WaitForExpr(ctx,
		`document.getElementById('text') === document.activeElement`); err != nil {
		s.Fatal("Failed to wait for text field to focus: ", err)
	}

	kb, err := input.Keyboard(ctx)
	if err != nil {
		s.Fatal("Failed to find keyboard: ", err)
	}
	defer kb.Close()

	// Loop through different input methods and test that when a specific input
	// is entered, the correct corresponding output is printed out
	const m17nExtensionID = "_comp_ime_jkghodnilhceideoidjikpgommlajknk"
	for inputMethod, inputMapping := range ruelbasedTestData {
		s.Log("setting input method to ", inputMethod)
		// Swap to the new input method
		inputMethod = m17nExtensionID + inputMethod
		if err := ime.SetCurrentInputMethod(ctx, tconn, inputMethod); err != nil {
			s.Fatal("Failed to set the input method: ", err)
		}
		// TODO(keithlee) Remove time.Sleep once the ime.SetCurrentInputMethod
		// does not return until the IME has been set
		// We could also use
		// The logs indicated that the IME took 7 milliseconds to startup
		// In practice, I found that the test was flaky when this was set to 10 ms
		time.Sleep(time.Millisecond * 500)

		for keystrokes, expectedOutput :=range inputMapping{
			// Press a sequence of keys.
			// without causing flaky failures.
			if err := kb.Type(ctx, keystrokes); err != nil {
				s.Fatalf("Failed to type %q: %v", keystrokes, err)
			}

			// Verify that the text element has the correct contents typed out
			s.Log("Waiting for the text field to contain ", expectedOutput)
			if err := conn.WaitForExpr(ctx,
				fmt.Sprintf("document.getElementById('text').value === '%s'", expectedOutput)); err != nil {
					s.Fatal("Failed to get the contents of the text field: ", err)
			}
			// Reset the text field to be empty
			s.Log("Waiting to reset the text field to be empty")
			if err:= conn.WaitForExpr(ctx, `!(document.getElementById('text').value = "")`); err != nil {
				s.Fatal("Failed to reset the text field to be empty", err)
			}
		}
	}

}
