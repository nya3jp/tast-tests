<!DOCTYPE html>
<html>
<head><title>RTCPeerConnection Loopback test</title></head>
<body>
  <video id="remoteVideo" autoplay muted style="max-width:100%;max-height:100%"></video>
<script src="third_party/blackframe.js"></script>
<script src="third_party/munge_sdp.js"></script>
<script src="third_party/simulcast.js"></script>
<script src="third_party/sdp.js"></script>
<script src="third_party/ssim.js"></script>
<script>

let localPeerConnection = new RTCPeerConnection({sdpSemantics: 'unified-plan'});
let remotePeerConnection = new RTCPeerConnection({sdpSemantics: 'unified-plan'});

async function start(profile, isSimulcast, width = 1280, height = 720) {
  localPeerConnection.onicecandidate = e => remotePeerConnection.addIceCandidate(e.candidate).catch(e => reject(e.toString()));
  remotePeerConnection.onicecandidate = e => localPeerConnection.addIceCandidate(e.candidate).catch(e => reject(e.toString()));
  remotePeerConnection.ontrack = e => {
    let remoteVideo = document.getElementById('remoteVideo');
    remoteVideo.srcObject = e.streams[0];
    resolve();
  };

  const offerOptions = {
    offerToReceiveAudio: 1,
    offerToReceiveVideo: 1
  };
  const constraints =  {
    audio: false,
    video: {
      mandatory: {
        minWidth: width,
        maxWidth: width,
        minHeight: height,
        maxHeight: height
      }
    },
  };
  const rids = [0, 1, 2];

  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  if (!isSimulcast) {
    stream.getTracks().forEach(track => localPeerConnection.addTrack(track, stream));
  } else {
    localPeerConnection.addTransceiver(stream.getVideoTracks()[0], {
      streams: [stream],
      sendEncodings: rids.map(rid => {rid}),
    });
  }

  const offer = await localPeerConnection.createOffer();
  if (profile && !isSimulcast) {
    offer.sdp = setSdpDefaultVideoCodec(offer.sdp, profile, false, "");
  }
  await localPeerConnection.setLocalDescription(offer);
  if (!isSimulcast) {
    await remotePeerConnection.setRemoteDescription(localPeerConnection.localDescription);
  } else {
    await remotePeerConnection.setRemoteDescription({
      type: 'offer',
      sdp: swapRidAndMidExtensionsInSimulcastOffer(offer, rids),
    });
  }

  const answer = await remotePeerConnection.createAnswer();
  await remotePeerConnection.setLocalDescription(answer);
  if (!isSimulcast) {
    await localPeerConnection.setRemoteDescription(remotePeerConnection.localDescription);
  } else {
    await localPeerConnection.setRemoteDescription({
      type: 'answer',
      sdp: swapRidAndMidExtensionsInSimulcastAnswer(answer, localPeerConnection.localDescription, rids),
    });
  }
}

// Returns true if the video frame being displayed is considered "black".
// Specifying |width| or |height| smaller than the feeding |remoteVideo| can be
// used for speeding up the calculation by downscaling.
function isBlackVideoFrame(width = 1280, height = 720) {
  const context = new OffscreenCanvas(width, height).getContext('2d');

  const remoteVideo = document.getElementById('remoteVideo');
  context.drawImage(remoteVideo, 0, 0, width, height);
  const imageData = context.getImageData(0, 0, width, height);
  return isBlackFrame(imageData.data, imageData.data.length);
}

const IDENTICAL_FRAME_SSIM_THRESHOLD = 0.99;
// Returns true if the previous video frame is too similar to the current video
// frame, implying that the video feed is frozen. The similarity is calculated
// using ssim() and comparing with the IDENTICAL_FRAME_SSIM_THRESHOLD.
// Specifying |width| or |height| smaller than the feeding |remoteVideo| can be
// used for speeding up the calculation by downscaling.
function isFrozenVideoFrame(width = 1280, height = 720) {
  const context = new OffscreenCanvas(width, height).getContext('2d');

  const remoteVideo = document.getElementById('remoteVideo');
  context.drawImage(remoteVideo, 0, 0, width, height);
  const imageData = context.getImageData(0, 0, width, height);

  if (isFrozenVideoFrame.previousImageData == null) {
    isFrozenVideoFrame.previousImageData = imageData;
    return false;
  }

  const ssim = new Ssim();
  const ssimValue = ssim.calculate(imageData.data, isFrozenVideoFrame.previousImageData.data)
  isFrozenVideoFrame.previousImageData = imageData;
  return ssimValue > IDENTICAL_FRAME_SSIM_THRESHOLD;
}

</script>
</body>
</html>
