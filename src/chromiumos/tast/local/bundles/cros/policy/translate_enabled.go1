// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package policy

import (
	"context"
	"io/ioutil"

	"chromiumos/tast/common/policy"
	"chromiumos/tast/local/policyutil"
	"chromiumos/tast/local/policyutil/pre"
   "chromiumos/tast/local/chrome/ui"
   "chromiumos/tast/local/chrome/ui/faillog"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func: TranslateEnabled,
		Desc: "Behavior of Translate policy",
		Contacts: []string{
			"marcgrimme@google.com", // Test author
			"kathrelkeld@chromium.org",
			"chromeos-commercial-managed-user-experience@google.com",
		},
		SoftwareDeps: []string{"chrome"},
      Attr:         []string{"group:mainline", "informational"},
		Pre:          pre.User,
	})
}

// TranslateEnabled validates the UI behaviour of the different
// states the policy introduces. When enabled/unset the translate widget
// appears otherwise it should not appear. The correct UI behaviours are
// checked.
func TranslateEnabled(ctx context.Context, s *testing.State) {
   cr := s.PreValue().(*pre.PreData).Chrome

	for _, param := range []struct {
		// name is the subtest name.
		name string
		// value is the policy value.
		value *policy.TranslateEnabled
	}{
		{
			name:  "true",
			value: &policy.TranslateEnabled{Val: true},
		},
		{
			name:  "false",
			value: &policy.TranslateEnabled{Val: false},
		},
		{
			name:  "unset",
			value: &policy.TranslateEnabled{Stat: policy.StatusUnset},
		},
	} {
		s.Run(ctx, param.name, func(ctx context.Context, s *testing.State) {
         setupChrome(ctx, s, param.value)
         tconn, err := cr.TestAPIConn(ctx)
         if err != nil {
            s.Fatal("Failed to create Test API connection: ", err)
         }

         // find the translate node and validate against error.
			_, err = ui.Find(ctx, tconn, ui.FindParams{
				Role: ui.RoleTypeButton,
				Name: "Translate this page",
			})
         isTranslate := err == nil

         expectedTranslate := (param.value.Stat == policy.StatusUnset) || param.value.Val

			if isTranslate != expectedTranslate {
            s.Errorf("Wrong visibility for translated gadget: got %t; want %t, policy: %s", isTranslate, expectedTranslate, param.value.Stat)
			}
		})
	}
}

func createTranslateDoc(s *testing.State) string {
   // setup (should live in precondition)
   content := []byte(`<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>Ceci est un paragraphe.</title>
</head>

<body>
Â¦<h4>Ceci est un paragraphe.</h4>
</body>
</html>
`)
   tmpfile, err := ioutil.TempFile("/tmp", "translate_page_fr.*.html")
   if err != nil { 
      s.Fatal("Could not create tempfile translate_page_fr.html. Error: ", err)
   } 
   // make file readable for all
   if err := tmpfile.Chmod(0644); err != nil {
      s.Fatal("Could not create tempfile translate_page_fr.html. Error: ", err)
   }

   if _, err := tmpfile.Write(content); err != nil {
      s.Fatal("Could not write contents to tempfile. Error: ", err)
   }
   if err := tmpfile.Close(); err != nil {
      s.Fatal("Cannot flose tmpfile. Error: ", err)
   }

   return tmpfile.Name()
}

func setupChrome(ctx context.Context, s *testing.State, pval *policy.TranslateEnabled) {
   cr := s.PreValue().(*pre.PreData).Chrome
   fdms := s.PreValue().(*pre.PreData).FakeDMS
   // Perform cleanup.
   if err := policyutil.ResetChrome(ctx, fdms, cr); err != nil {
      s.Fatal("Failed to clean up: ", err)
   }

   // Update policies.
   if err := policyutil.ServeAndRefresh(ctx, fdms, cr, []policy.Policy{pval}); err != nil {
      s.Fatal("Failed to update policies: ", err)
   }

   // Connect to Test API to use it with the ui library.
   tconn, err := cr.TestAPIConn(ctx)
   if err != nil {
      s.Fatal("Failed to create Test API connection: ", err)
   }

   defer faillog.DumpUITreeOnError(ctx, s.OutDir(), s.HasError, tconn)
   url := "file://" + createTranslateDoc(s)
   conn, err := cr.NewConn(ctx, url)
   if err != nil {
      s.Fatal("Failed to connect to chrome: ", err)
   }
   defer conn.Close()

   if err := ui.WaitForLocationChangeCompleted(ctx, tconn); err != nil {
      s.Fatal("Failed to wait for location change. Error: ", err)
   }
}
