// Copyright 2021 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package gpucuj tests GPU CUJ tests on lacros Chrome and Chrome OS Chrome.
package gpucuj

import (
	"math"
	"sort"

	"android.googlesource.com/platform/external/perfetto/protos/perfetto/trace"

	"chromiumos/tast/errors"
)

// Below is a quick explanation of the idea behind this analysis. Sources of
// data:
// 1. Graphics.Pipeline
//   This gives us IssueBeginFrame, ReceiveCompositorFrame, DidNotProduceFrame.
//   We can use flow events to get the relative ordering between these.
// 2. Display + DisplayScheduler
//   This gives us BeginFrame and DrawAndSwap
// We associate page flip (Display::FrameDisplayed) with
// DisplayScheduler::DrawAndSwap, and CompositorFrames. Note that the content
// displayed on page flip may (will) not be the content generated by
// DrawAndSwap, but it's only important that our results be correct on average.
// A delay in a draw, if it causes dropped frames, will produce a late page flip
// later in the trace. We use an alignment dynamic programming algorithm to
// produce this association.
//
// Then, we want to associate each draw with the compositor frames it used. This
// is done by assuming that the last event out of IssueBeginFrame,
// DidNotProduceFrame, and ReceiveCompositorFrame is associated with the draw
// directly after it. It's not guaranteed that IssueBeginFrame occurs after
// BeginFrame, if we were to try to associate each BeginFrame with a draw. In
// general, it's difficult to predict the number of expected frames from the
// combination of BeginFrame and draw calls. In particular, an IssueBeginFrame
// may be followed by any number of DidNotProduceFrames before a
// ReceiveCompositorFrame, without any intermediate BeginFrame calls, in some
// configurations.
//
// Instead, we measure the time between the last ReceiveCompositorFrame or
// DidNotProduceFrame event and the presentation time on screen, where which
// event is last is determined using event flow IDs. If this time exceeds the
// interval time the flip is marked as late. Also, if an IssueBeginFrame call
// was sent but there was no response, it is also counted as late. This
// produces an underestimate of the number of dropped frames but seems to be
// close enough in practice.
//
// BeginFrame data is only used to retrieve the interval time, which currently
// is always 16.7ms.
//
// From these data, we compute two metrics. A percent dropped frames metric, and
// an average fps.

type flip struct {
	drawNS           uint64
	presentedNS      uint64
	intervalNS       uint64
	compositorFrames [][]uint64
}

type frameStats struct {
	ta               *traceAnalyzer
	flips            []*flip
	presentedNS      []uint64
	compositorFrames map[uint64][][]uint64 // This is per flow-event chain.
	curFlip          *flip
}

func newFrameStats(tr *trace.Trace) (*frameStats, error) {
	return &frameStats{
		ta:               newTraceAnalyzer(tr),
		curFlip:          &flip{},
		compositorFrames: make(map[uint64][][]uint64),
	}, nil
}

func (fs *frameStats) parseVizThread(ts uint64, trackName string, sd *seqData, p *trace.TracePacket, flowID uint64, newFlow bool) error {
	if trackName != "VizCompositorThread" {
		return nil
	}

	d := p.GetTrackEvent()
	name := fs.ta.eventName(p, d)

	if name == "DisplayScheduler::BeginFrame" && d.GetType() == trace.TrackEvent_TYPE_SLICE_BEGIN {
		for _, da := range d.GetDebugAnnotations() {
			if fs.ta.annotationName(p, da) == "args" {
				nv := da.GetNestedValue()
				if nv == nil || len(nv.DictKeys) != len(nv.DictValues) {
					return errors.New("broken trace")
				}

				for i, v := range nv.DictValues {
					if nv.DictKeys[i] == "interval_us" {
						fs.curFlip.intervalNS = 1000 * uint64(v.GetDoubleValue())
					}
				}
			}
		}
	}

	if name == "Graphics.Pipeline" && d.GetType() == trace.TrackEvent_TYPE_SLICE_BEGIN {
		for _, da := range d.GetDebugAnnotations() {
			if fs.ta.annotationName(p, da) == "step" {
				switch da.GetStringValue() {
				case "IssueBeginFrame", "ReceiveCompositorFrame", "DidNotProduceFrame":
					// DidNotProduceFrame can be followed by ReceiveCompositorFrame for the same IssueBeginFrame, in some circumstances.
					// So, store all the events in an array.
					if newFlow {
						fs.compositorFrames[flowID] = append(fs.compositorFrames[flowID], []uint64{})
					}
					last := len(fs.compositorFrames[flowID]) - 1
					if last >= 0 {
						fs.compositorFrames[flowID][last] = append(fs.compositorFrames[flowID][last], ts)
					}
				}
			}
		}
	}

	if name == "Display::DrawAndSwap" && d.GetType() == trace.TrackEvent_TYPE_SLICE_BEGIN {
		fs.curFlip.drawNS = ts
		fs.flips = append(fs.flips, fs.curFlip)
		fs.curFlip = &flip{}
	}

	if name == "Display::FrameDisplayed" {
		fs.presentedNS = append(fs.presentedNS, ts)
	}

	return nil
}

type results struct {
	proportionDropped float64
	fps               float64
	numFrames         int
}

func analyzeFlips(flips []*flip) (*results, error) {
	dropped := 0
	startTime := uint64(math.MaxUint64)
	endTime := uint64(0)

	for _, v := range flips {
		if v.drawNS == 0 || v.presentedNS == 0 {
			dropped++
			continue
		}
		startTime = min(startTime, v.presentedNS)
		endTime = max(endTime, v.presentedNS)

		// Dropped because we didn't hear back from client compositors.
		for _, f := range v.compositorFrames {
			diff := int64(v.presentedNS) - int64(f[len(f)-1])
			// If there was an IssueBeginFrame but no response, or it took a long time from response to page flip,
			// count it as a dropped frame. This is a heuristic, because ideally we would measure from IssueBeginFrame
			// to the response, but, an IssueBeginFrame can be followed by multiple DidNotProduceFrames if the source
			// decides it doesn't have any frames to produce for multiple vblanks in a row.
			if len(f) == 1 || diff > int64(v.intervalNS) {
				dropped++
				break
			}
		}
	}

	res := &results{
		proportionDropped: 0.0,
		fps:               0.0,
		numFrames:         len(flips),
	}

	if len(flips) != 0 {
		res.proportionDropped = float64(dropped) / float64(len(flips))
	}

	if endTime > startTime {
		// Subtract 1 since we are measuring from the start of the first frame to the start of the last frame.
		res.fps = (1000000000.0 * float64(len(flips)-1)) / float64(endTime-startTime)
	}

	return res, nil
}

func absDiff(a, b uint64) uint64 {
	v := int64(a) - int64(b)
	if v < 0 {
		v = -v
	}
	return uint64(v)
}

func min(a, b uint64) uint64 {
	if a > b {
		return b
	}
	return a
}

func max(a, b uint64) uint64 {
	if a < b {
		return b
	}
	return a
}

const maxCost uint64 = 2 << 58

func align(a, b int, skipACost, skipBCost uint64, costFn func(a, b int) uint64, matchFn func(a, b int)) {
	type state struct {
		i int
		j int
	}

	dp := make([][]uint64, a+1)
	back := make([][]state, a+1)
	for i := range dp {
		dp[i] = make([]uint64, b+1)
		back[i] = make([]state, b+1)
		for j := range dp[i] {
			dp[i][j] = maxCost
		}
	}
	dp[0][0] = 0

	for i := 0; i < a+1; i++ {
		for j := 0; j < b+1; j++ {
			if i < a && dp[i][j]+skipACost < dp[i+1][j] { // Don't match a.
				back[i+1][j] = state{i: i, j: j}
				dp[i+1][j] = dp[i][j] + skipACost
			}
			if j < b && dp[i][j]+skipBCost < dp[i][j+1] { // Don't match b.
				back[i][j+1] = state{i: i, j: j}
				dp[i][j+1] = dp[i][j] + skipBCost
			}

			if i < a && j < b {
				cost := costFn(i, j)
				if dp[i][j]+cost < dp[i+1][j+1] { // Match here if allowed.
					back[i+1][j+1] = state{i: i, j: j}
					dp[i+1][j+1] = dp[i][j] + cost
				}
			}
		}
	}

	// Backtrack
	cur := state{i: a, j: b}
	for cur.i > 0 && cur.j > 0 {
		next := back[cur.i][cur.j]
		if cur.i != next.i && cur.j != next.j { // There was a match if both cursors move.
			matchFn(next.i, next.j)
		}
		cur = next
	}
}

func (fs *frameStats) computeProportionDroppedFrames() (*results, error) {
	err := fs.ta.parseTrackEvents(func(ts uint64, trackName string, sd *seqData, p *trace.TracePacket, flowID uint64, newFlow bool) error {
		return fs.parseVizThread(ts, trackName, sd, p, flowID, newFlow)
	})
	if err != nil {
		return nil, err
	}

	sort.Slice(fs.flips, func(i, j int) bool {
		return fs.flips[i].drawNS < fs.flips[j].drawNS
	})

	// Match up compositor frames to flips
	for _, vouter := range fs.compositorFrames {
		for _, v := range vouter {
			idx := 0
			for idx < len(fs.flips) && fs.flips[idx].drawNS < v[len(v)-1] {
				idx++
			}
			if idx < len(fs.flips) {
				fs.flips[idx].compositorFrames = append(fs.flips[idx].compositorFrames, v)
			}
		}
	}

	// High (but not max) cost.
	const highCost = 1000 * 1000 * 1000
	// Expect there to be one flip per DrawAndSwap
	align(len(fs.flips), len(fs.presentedNS), highCost, highCost, func(a, b int) uint64 {
		return absDiff(fs.flips[a].drawNS, fs.presentedNS[b])
	}, func(a, b int) {
		fs.flips[a].presentedNS = fs.presentedNS[b]
	})

	res, err := analyzeFlips(fs.flips)
	if err != nil {
		return nil, err
	}

	return res, nil
}
