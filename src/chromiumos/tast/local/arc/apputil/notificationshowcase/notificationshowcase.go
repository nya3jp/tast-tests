// Copyright 2022 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package notificationshowcase is used for writing test cases which use Notification Showcase app.
package notificationshowcase

import (
	"context"
	"time"

	"chromiumos/tast/common/android/adb"
	"chromiumos/tast/errors"
	"chromiumos/tast/local/arc"
	"chromiumos/tast/local/arc/apputil"
	"chromiumos/tast/local/chrome"
	"chromiumos/tast/local/chrome/ash"
	"chromiumos/tast/local/input"
)

const (
	// AppName is the name of Notification Showcase app.
	AppName = "Notification Showcase"
	// PkgName is the package name of Notification Showcase app.
	PkgName = "org.chromium.arc.testapp.notification2"
	// AppID is the app ID of Notification Showcase app.
	AppID = "ealboieclppkdlimieennaeddhpemdmo"

	appStartCommand = PkgName + ".SHOW_NOTIFICATION"

	// Notification ID on Android is composed of many components.
	// So this is just the substring to match the notification generated by the test app.
	appNotificationID = "|" + PkgName + "|"

	defaultTimeout = 5 * time.Second
)

// NotificationShowcase represents an instance of the Notification Showcase app.
type NotificationShowcase struct {
	*apputil.App
	sdkPath string
}

// NewApp creates a new instance of the Android application version of gmail.
// This app requires the actual apk file in order to install.
// App installation and launch are needed after initialization.
func NewApp(ctx context.Context, a *arc.ARC, tconn *chrome.TestConn, kb *input.KeyboardEventWriter, sdkPath string) (*NotificationShowcase, error) {
	app, err := apputil.NewApp(ctx, kb, tconn, a, AppName, PkgName)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create Notification Showcase app instance")
	}

	return &NotificationShowcase{app, sdkPath}, nil
}

// Install installs the Notification Showcase app.
func (app *NotificationShowcase) Install(ctx context.Context) error {
	return app.ARC.Install(ctx, app.sdkPath, adb.InstallOptionGrantPermissions)
}

type notificationStyle string

const (
	// BasicNotification is the default style of notification.
	BasicNotification notificationStyle = "basic"
	// BigTextNotification is the style of notification with big text.
	BigTextNotification notificationStyle = "big_text"
	// BigPictureNotification is the style of notification with big picture.
	BigPictureNotification notificationStyle = "big_picture"
	// InboxNotification is the style of notification without detailed message.
	InboxNotification notificationStyle = "inbox"
	// MessagingNotification is the style of notification with message-liked appearance.
	MessagingNotification notificationStyle = "messaging"
	// MediaNotification is the style of notification that appears like media player on Holding Space.
	MediaNotification notificationStyle = "media"
	// GroupingNotification is the style of notification with bundled notifications.
	GroupingNotification notificationStyle = "group"
)

// composeNotification creates a notification with given commands arguments and returns the notification ID if completed.
// The complete document is available at https://developer.android.com/studio/command-line/adb#IntentSpec
func (app *NotificationShowcase) composeNotification(ctx context.Context, style notificationStyle, optionArgs ...string) (*ash.Notification, error) {
	// Compose main command and optionals.
	args := []string{"-p", PkgName, "--es", "style", string(style)}
	args = append(args, optionArgs...)
	args = append(args,
		"--ez", "autoCancel", "true", // Enable "Auto-cancel" to dismiss the notification after clicking.
		"--esn", "notify", // Set extra key as "notify".
	)

	if _, err := app.ARC.BroadcastIntent(ctx, appStartCommand, args...); err != nil {
		return nil, errors.Wrap(err, "failed to send a broadcast")
	}

	notification, err := ash.WaitForNotification(ctx, app.Tconn, defaultTimeout, ash.WaitIDContains(appNotificationID))
	if err != nil {
		return nil, errors.Wrap(err, "failed to wait until the notification appears")
	}

	return notification, nil
}

// ComposeGroupedNotification creates a grouped notification with specified times.
func (app *NotificationShowcase) ComposeGroupedNotification(ctx context.Context, times int) error {
	for i := 0; i < times; i++ {
		if _, err := app.composeNotification(ctx, BasicNotification, "--es", "bundle", "post"); err != nil {
			return errors.Wrap(err, "failed to compose a grouped notification")
		}
	}

	return nil
}
