// Code generated by protoc-gen-go. DO NOT EDIT.
// source: bluetooth_service.proto

package bluetooth

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Case039Request struct {
	A2DPDeviceName       string   `protobuf:"bytes,1,opt,name=A2DP_device_name,json=A2DPDeviceName,proto3" json:"A2DP_device_name,omitempty"`
	HangoutsURL          string   `protobuf:"bytes,2,opt,name=hangoutsURL,proto3" json:"hangoutsURL,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Case039Request) Reset()         { *m = Case039Request{} }
func (m *Case039Request) String() string { return proto.CompactTextString(m) }
func (*Case039Request) ProtoMessage()    {}
func (*Case039Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8a85ab5c487a308, []int{0}
}

func (m *Case039Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Case039Request.Unmarshal(m, b)
}
func (m *Case039Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Case039Request.Marshal(b, m, deterministic)
}
func (m *Case039Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Case039Request.Merge(m, src)
}
func (m *Case039Request) XXX_Size() int {
	return xxx_messageInfo_Case039Request.Size(m)
}
func (m *Case039Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Case039Request.DiscardUnknown(m)
}

var xxx_messageInfo_Case039Request proto.InternalMessageInfo

func (m *Case039Request) GetA2DPDeviceName() string {
	if m != nil {
		return m.A2DPDeviceName
	}
	return ""
}

func (m *Case039Request) GetHangoutsURL() string {
	if m != nil {
		return m.HangoutsURL
	}
	return ""
}

func init() {
	proto.RegisterType((*Case039Request)(nil), "tast.mtbf.bluetooth.Case039Request")
}

func init() { proto.RegisterFile("bluetooth_service.proto", fileDescriptor_d8a85ab5c487a308) }

var fileDescriptor_d8a85ab5c487a308 = []byte{
	// 383 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x93, 0x4f, 0x8b, 0xda, 0x40,
	0x18, 0xc6, 0xb1, 0x58, 0xc5, 0x11, 0x44, 0xa6, 0xd0, 0x4a, 0x5a, 0x8a, 0xb4, 0x87, 0xda, 0xcb,
	0xc4, 0x26, 0x97, 0x7a, 0x69, 0x31, 0x2a, 0xad, 0x20, 0xad, 0xc4, 0xb6, 0x87, 0x52, 0x90, 0x49,
	0xf2, 0x1a, 0x03, 0xc9, 0x4c, 0x3a, 0xef, 0xa4, 0x65, 0xbf, 0xc9, 0x7e, 0xda, 0x65, 0x49, 0xa2,
	0xb2, 0xbb, 0xae, 0x0a, 0xeb, 0x5e, 0x9f, 0x3f, 0xbf, 0x3c, 0x13, 0x66, 0xc8, 0x0b, 0x2f, 0xce,
	0x40, 0x4b, 0xa9, 0xd7, 0x4b, 0x04, 0xf5, 0x2f, 0xf2, 0x81, 0xa5, 0x4a, 0x6a, 0x49, 0x9f, 0x69,
	0x8e, 0x9a, 0x25, 0xda, 0x5b, 0xb1, 0x5d, 0xc4, 0x78, 0x19, 0x4a, 0x19, 0xc6, 0x60, 0x16, 0x11,
	0x2f, 0x5b, 0x99, 0x90, 0xa4, 0xfa, 0xa2, 0x6c, 0x18, 0xaf, 0xef, 0x9a, 0xff, 0x15, 0x4f, 0x53,
	0x50, 0x58, 0xfa, 0x6f, 0xfe, 0x90, 0xd6, 0x88, 0x23, 0xf4, 0xed, 0x81, 0x0b, 0x7f, 0x33, 0x40,
	0x4d, 0x7b, 0xa4, 0x3d, 0xb4, 0xc6, 0xf3, 0x65, 0x00, 0xf9, 0x87, 0x97, 0x82, 0x27, 0xd0, 0xa9,
	0x74, 0x2b, 0xbd, 0x86, 0xdb, 0xca, 0xf5, 0x71, 0x21, 0x7f, 0xe3, 0x09, 0xd0, 0x2e, 0x69, 0xae,
	0xb9, 0x08, 0x65, 0xa6, 0xf1, 0xa7, 0x3b, 0xeb, 0x3c, 0x29, 0x42, 0x37, 0x25, 0xeb, 0xb2, 0x4a,
	0x1a, 0xce, 0x76, 0x28, 0xfd, 0x48, 0x6a, 0x13, 0xc1, 0xbd, 0x18, 0xe8, 0x73, 0x56, 0xce, 0x62,
	0xdb, 0x59, 0x6c, 0x92, 0x6f, 0x36, 0x0e, 0xe8, 0x74, 0x40, 0xea, 0xe3, 0x08, 0x1f, 0x54, 0x9d,
	0x90, 0xfa, 0x30, 0x08, 0x14, 0x20, 0xd2, 0x57, 0x7b, 0x91, 0x85, 0x56, 0x91, 0x08, 0x7f, 0xf1,
	0x38, 0x03, 0xe3, 0xa8, 0x4b, 0x1d, 0x52, 0x9b, 0x62, 0x7e, 0xfe, 0x13, 0x14, 0x63, 0xcf, 0x75,
	0xa4, 0x8c, 0x4b, 0xc6, 0x90, 0x3c, 0x9d, 0xe2, 0xd7, 0xc5, 0x39, 0x88, 0xcf, 0xa4, 0x3e, 0x92,
	0x42, 0x80, 0xaf, 0x4f, 0x40, 0x0e, 0xfd, 0x8e, 0x2f, 0xa4, 0x39, 0xc5, 0x0d, 0x02, 0x82, 0x33,
	0x96, 0x7c, 0x22, 0xd5, 0x85, 0xcf, 0x05, 0x3d, 0x92, 0x39, 0xd6, 0xb7, 0xae, 0x2a, 0xa4, 0xf1,
	0x03, 0x50, 0xfb, 0x1c, 0x01, 0xe9, 0x77, 0xd2, 0x76, 0x33, 0x31, 0x93, 0x3e, 0x8f, 0xfb, 0xf6,
	0x60, 0xce, 0x95, 0xfe, 0x40, 0xdf, 0xb2, 0x7b, 0x6e, 0x3b, 0xbb, 0x7d, 0x5b, 0x0f, 0x9e, 0x73,
	0x1f, 0x68, 0x3d, 0x36, 0xd0, 0x3e, 0x0b, 0xe8, 0xbc, 0xff, 0xfd, 0xce, 0x5f, 0x2b, 0x99, 0x44,
	0x59, 0x22, 0xd1, 0xcc, 0x41, 0xe6, 0xe6, 0xb1, 0xa3, 0x99, 0x13, 0xcd, 0x1d, 0xd1, 0xab, 0x15,
	0x55, 0xfb, 0x3a, 0x00, 0x00, 0xff, 0xff, 0x63, 0x7d, 0x19, 0x51, 0x18, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BluetoothClient is the client API for Bluetooth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BluetoothClient interface {
	// Enable turns on the bluetooth.
	Enable(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Disable turns off the bluetooth.
	Disable(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Address returns the internal address of the bluetooth.
	Address(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.StringValue, error)
	// IsA2DP checks if bluetooth device type is IsA2DP.
	IsA2DP(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error)
	// IsHSP checks if bluetooth device type is HSP.
	IsHSP(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error)
	Connect(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*empty.Empty, error)
	// IsConnected checks if the device is connected by the given address.
	IsConnected(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error)
	Scan(ctx context.Context, in *wrappers.BoolValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error)
}

type bluetoothClient struct {
	cc *grpc.ClientConn
}

func NewBluetoothClient(cc *grpc.ClientConn) BluetoothClient {
	return &bluetoothClient{cc}
}

func (c *bluetoothClient) Enable(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Bluetooth/Enable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothClient) Disable(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Bluetooth/Disable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothClient) Address(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.StringValue, error) {
	out := new(wrappers.StringValue)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Bluetooth/Address", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothClient) IsA2DP(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error) {
	out := new(wrappers.BoolValue)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Bluetooth/IsA2DP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothClient) IsHSP(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error) {
	out := new(wrappers.BoolValue)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Bluetooth/IsHSP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothClient) Connect(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Bluetooth/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothClient) IsConnected(ctx context.Context, in *wrappers.StringValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error) {
	out := new(wrappers.BoolValue)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Bluetooth/IsConnected", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bluetoothClient) Scan(ctx context.Context, in *wrappers.BoolValue, opts ...grpc.CallOption) (*wrappers.BoolValue, error) {
	out := new(wrappers.BoolValue)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Bluetooth/Scan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BluetoothServer is the server API for Bluetooth service.
type BluetoothServer interface {
	// Enable turns on the bluetooth.
	Enable(context.Context, *empty.Empty) (*empty.Empty, error)
	// Disable turns off the bluetooth.
	Disable(context.Context, *empty.Empty) (*empty.Empty, error)
	// Address returns the internal address of the bluetooth.
	Address(context.Context, *wrappers.StringValue) (*wrappers.StringValue, error)
	// IsA2DP checks if bluetooth device type is IsA2DP.
	IsA2DP(context.Context, *wrappers.StringValue) (*wrappers.BoolValue, error)
	// IsHSP checks if bluetooth device type is HSP.
	IsHSP(context.Context, *wrappers.StringValue) (*wrappers.BoolValue, error)
	Connect(context.Context, *wrappers.StringValue) (*empty.Empty, error)
	// IsConnected checks if the device is connected by the given address.
	IsConnected(context.Context, *wrappers.StringValue) (*wrappers.BoolValue, error)
	Scan(context.Context, *wrappers.BoolValue) (*wrappers.BoolValue, error)
}

// UnimplementedBluetoothServer can be embedded to have forward compatible implementations.
type UnimplementedBluetoothServer struct {
}

func (*UnimplementedBluetoothServer) Enable(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enable not implemented")
}
func (*UnimplementedBluetoothServer) Disable(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disable not implemented")
}
func (*UnimplementedBluetoothServer) Address(ctx context.Context, req *wrappers.StringValue) (*wrappers.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Address not implemented")
}
func (*UnimplementedBluetoothServer) IsA2DP(ctx context.Context, req *wrappers.StringValue) (*wrappers.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsA2DP not implemented")
}
func (*UnimplementedBluetoothServer) IsHSP(ctx context.Context, req *wrappers.StringValue) (*wrappers.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsHSP not implemented")
}
func (*UnimplementedBluetoothServer) Connect(ctx context.Context, req *wrappers.StringValue) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (*UnimplementedBluetoothServer) IsConnected(ctx context.Context, req *wrappers.StringValue) (*wrappers.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsConnected not implemented")
}
func (*UnimplementedBluetoothServer) Scan(ctx context.Context, req *wrappers.BoolValue) (*wrappers.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Scan not implemented")
}

func RegisterBluetoothServer(s *grpc.Server, srv BluetoothServer) {
	s.RegisterService(&_Bluetooth_serviceDesc, srv)
}

func _Bluetooth_Enable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothServer).Enable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Bluetooth/Enable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothServer).Enable(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bluetooth_Disable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothServer).Disable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Bluetooth/Disable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothServer).Disable(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bluetooth_Address_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothServer).Address(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Bluetooth/Address",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothServer).Address(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bluetooth_IsA2DP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothServer).IsA2DP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Bluetooth/IsA2DP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothServer).IsA2DP(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bluetooth_IsHSP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothServer).IsHSP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Bluetooth/IsHSP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothServer).IsHSP(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bluetooth_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Bluetooth/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothServer).Connect(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bluetooth_IsConnected_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothServer).IsConnected(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Bluetooth/IsConnected",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothServer).IsConnected(ctx, req.(*wrappers.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bluetooth_Scan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrappers.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BluetoothServer).Scan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Bluetooth/Scan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BluetoothServer).Scan(ctx, req.(*wrappers.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

var _Bluetooth_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.mtbf.bluetooth.Bluetooth",
	HandlerType: (*BluetoothServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Enable",
			Handler:    _Bluetooth_Enable_Handler,
		},
		{
			MethodName: "Disable",
			Handler:    _Bluetooth_Disable_Handler,
		},
		{
			MethodName: "Address",
			Handler:    _Bluetooth_Address_Handler,
		},
		{
			MethodName: "IsA2DP",
			Handler:    _Bluetooth_IsA2DP_Handler,
		},
		{
			MethodName: "IsHSP",
			Handler:    _Bluetooth_IsHSP_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _Bluetooth_Connect_Handler,
		},
		{
			MethodName: "IsConnected",
			Handler:    _Bluetooth_IsConnected_Handler,
		},
		{
			MethodName: "Scan",
			Handler:    _Bluetooth_Scan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bluetooth_service.proto",
}

// TestcasesClient is the client API for Testcases service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TestcasesClient interface {
	RunLocal039Part1(ctx context.Context, in *Case039Request, opts ...grpc.CallOption) (*empty.Empty, error)
	RunLocal039Part2(ctx context.Context, in *Case039Request, opts ...grpc.CallOption) (*empty.Empty, error)
	RunLocal039Part3(ctx context.Context, in *Case039Request, opts ...grpc.CallOption) (*empty.Empty, error)
}

type testcasesClient struct {
	cc *grpc.ClientConn
}

func NewTestcasesClient(cc *grpc.ClientConn) TestcasesClient {
	return &testcasesClient{cc}
}

func (c *testcasesClient) RunLocal039Part1(ctx context.Context, in *Case039Request, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Testcases/RunLocal039Part1", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testcasesClient) RunLocal039Part2(ctx context.Context, in *Case039Request, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Testcases/RunLocal039Part2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testcasesClient) RunLocal039Part3(ctx context.Context, in *Case039Request, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.bluetooth.Testcases/RunLocal039Part3", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TestcasesServer is the server API for Testcases service.
type TestcasesServer interface {
	RunLocal039Part1(context.Context, *Case039Request) (*empty.Empty, error)
	RunLocal039Part2(context.Context, *Case039Request) (*empty.Empty, error)
	RunLocal039Part3(context.Context, *Case039Request) (*empty.Empty, error)
}

// UnimplementedTestcasesServer can be embedded to have forward compatible implementations.
type UnimplementedTestcasesServer struct {
}

func (*UnimplementedTestcasesServer) RunLocal039Part1(ctx context.Context, req *Case039Request) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunLocal039Part1 not implemented")
}
func (*UnimplementedTestcasesServer) RunLocal039Part2(ctx context.Context, req *Case039Request) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunLocal039Part2 not implemented")
}
func (*UnimplementedTestcasesServer) RunLocal039Part3(ctx context.Context, req *Case039Request) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunLocal039Part3 not implemented")
}

func RegisterTestcasesServer(s *grpc.Server, srv TestcasesServer) {
	s.RegisterService(&_Testcases_serviceDesc, srv)
}

func _Testcases_RunLocal039Part1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Case039Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestcasesServer).RunLocal039Part1(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Testcases/RunLocal039Part1",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestcasesServer).RunLocal039Part1(ctx, req.(*Case039Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Testcases_RunLocal039Part2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Case039Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestcasesServer).RunLocal039Part2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Testcases/RunLocal039Part2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestcasesServer).RunLocal039Part2(ctx, req.(*Case039Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Testcases_RunLocal039Part3_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Case039Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestcasesServer).RunLocal039Part3(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.bluetooth.Testcases/RunLocal039Part3",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestcasesServer).RunLocal039Part3(ctx, req.(*Case039Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _Testcases_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.mtbf.bluetooth.Testcases",
	HandlerType: (*TestcasesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunLocal039Part1",
			Handler:    _Testcases_RunLocal039Part1_Handler,
		},
		{
			MethodName: "RunLocal039Part2",
			Handler:    _Testcases_RunLocal039Part2_Handler,
		},
		{
			MethodName: "RunLocal039Part3",
			Handler:    _Testcases_RunLocal039Part3_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bluetooth_service.proto",
}
