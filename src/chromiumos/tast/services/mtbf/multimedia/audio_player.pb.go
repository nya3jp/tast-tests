// Code generated by protoc-gen-go. DO NOT EDIT.
// source: audio_player.proto

package multimedia

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type FileRequest struct {
	Filepath             string   `protobuf:"bytes,1,opt,name=filepath,proto3" json:"filepath,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileRequest) Reset()         { *m = FileRequest{} }
func (m *FileRequest) String() string { return proto.CompactTextString(m) }
func (*FileRequest) ProtoMessage()    {}
func (*FileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa51753c02ae1497, []int{0}
}

func (m *FileRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileRequest.Unmarshal(m, b)
}
func (m *FileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileRequest.Marshal(b, m, deterministic)
}
func (m *FileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileRequest.Merge(m, src)
}
func (m *FileRequest) XXX_Size() int {
	return xxx_messageInfo_FileRequest.Size(m)
}
func (m *FileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FileRequest proto.InternalMessageInfo

func (m *FileRequest) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

type TimeoutRequest struct {
	Seconds              int64    `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeoutRequest) Reset()         { *m = TimeoutRequest{} }
func (m *TimeoutRequest) String() string { return proto.CompactTextString(m) }
func (*TimeoutRequest) ProtoMessage()    {}
func (*TimeoutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa51753c02ae1497, []int{1}
}

func (m *TimeoutRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TimeoutRequest.Unmarshal(m, b)
}
func (m *TimeoutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TimeoutRequest.Marshal(b, m, deterministic)
}
func (m *TimeoutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeoutRequest.Merge(m, src)
}
func (m *TimeoutRequest) XXX_Size() int {
	return xxx_messageInfo_TimeoutRequest.Size(m)
}
func (m *TimeoutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeoutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TimeoutRequest proto.InternalMessageInfo

func (m *TimeoutRequest) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

type TimeResponse struct {
	CurrentTime          int64    `protobuf:"varint,1,opt,name=current_time,json=currentTime,proto3" json:"current_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeResponse) Reset()         { *m = TimeResponse{} }
func (m *TimeResponse) String() string { return proto.CompactTextString(m) }
func (*TimeResponse) ProtoMessage()    {}
func (*TimeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa51753c02ae1497, []int{2}
}

func (m *TimeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TimeResponse.Unmarshal(m, b)
}
func (m *TimeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TimeResponse.Marshal(b, m, deterministic)
}
func (m *TimeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeResponse.Merge(m, src)
}
func (m *TimeResponse) XXX_Size() int {
	return xxx_messageInfo_TimeResponse.Size(m)
}
func (m *TimeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TimeResponse proto.InternalMessageInfo

func (m *TimeResponse) GetCurrentTime() int64 {
	if m != nil {
		return m.CurrentTime
	}
	return 0
}

func init() {
	proto.RegisterType((*FileRequest)(nil), "tast.mtbf.multimedia.FileRequest")
	proto.RegisterType((*TimeoutRequest)(nil), "tast.mtbf.multimedia.TimeoutRequest")
	proto.RegisterType((*TimeResponse)(nil), "tast.mtbf.multimedia.TimeResponse")
}

func init() { proto.RegisterFile("audio_player.proto", fileDescriptor_aa51753c02ae1497) }

var fileDescriptor_aa51753c02ae1497 = []byte{
	// 349 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0x5f, 0x4b, 0x32, 0x41,
	0x14, 0xc6, 0x91, 0xd7, 0xb7, 0xec, 0xac, 0x14, 0x0c, 0x11, 0x62, 0x37, 0xb9, 0x74, 0x61, 0x5e,
	0xcc, 0x52, 0x41, 0x41, 0x77, 0x66, 0x09, 0xf6, 0x87, 0x64, 0xe9, 0xaa, 0x1b, 0x59, 0x77, 0x8f,
	0x3a, 0x30, 0xbb, 0x67, 0xdb, 0x99, 0x29, 0xfc, 0xb2, 0x7d, 0x96, 0x98, 0x55, 0xb3, 0xc0, 0x0d,
	0xb4, 0xcb, 0x91, 0xe7, 0xf7, 0xf0, 0xfc, 0x3c, 0x0b, 0x2c, 0x30, 0x91, 0xa0, 0x41, 0x2a, 0x83,
	0x29, 0x66, 0x3c, 0xcd, 0x48, 0x13, 0xdb, 0xd7, 0x81, 0xd2, 0x3c, 0xd6, 0xc3, 0x11, 0x8f, 0x8d,
	0xd4, 0x22, 0xc6, 0x48, 0x04, 0xf5, 0xc3, 0x31, 0xd1, 0x58, 0xa2, 0x97, 0x67, 0x86, 0x66, 0xe4,
	0x61, 0x9c, 0xea, 0xe9, 0x0c, 0x71, 0x4f, 0xc0, 0xe9, 0x0a, 0x89, 0x3e, 0xbe, 0x1a, 0x54, 0x9a,
	0xd5, 0xa1, 0x32, 0x12, 0x12, 0xd3, 0x40, 0x4f, 0x6a, 0xa5, 0xa3, 0x52, 0x73, 0xc7, 0xff, 0x7a,
	0xbb, 0x2d, 0xd8, 0x7d, 0x16, 0x31, 0x92, 0xd1, 0x8b, 0x74, 0x0d, 0xb6, 0x15, 0x86, 0x94, 0x44,
	0x2a, 0x0f, 0xff, 0xf3, 0x17, 0x4f, 0xf7, 0x14, 0xaa, 0x36, 0xeb, 0xa3, 0x4a, 0x29, 0x51, 0xc8,
	0x1a, 0x50, 0x0d, 0x4d, 0x96, 0x61, 0xa2, 0x07, 0x76, 0xd6, 0x3c, 0xee, 0xcc, 0x7f, 0xb3, 0xd1,
	0xb3, 0x8f, 0x32, 0x38, 0x6d, 0xeb, 0xd4, 0xcf, 0x95, 0xd8, 0x03, 0xec, 0x3d, 0xa5, 0x98, 0xf4,
	0x92, 0x1b, 0x7a, 0x4f, 0x24, 0x05, 0x91, 0x62, 0x0d, 0xbe, 0x4a, 0x90, 0x7f, 0x13, 0xa8, 0x1f,
	0xf0, 0x99, 0x2d, 0x5f, 0xd8, 0xf2, 0x5b, 0x6b, 0xcb, 0x2e, 0xe1, 0x7f, 0x97, 0x42, 0xa3, 0x58,
	0x41, 0xe0, 0x37, 0xb0, 0x23, 0x49, 0xe1, 0xda, 0xe0, 0x15, 0x54, 0x72, 0xb0, 0x2d, 0xe5, 0xda,
	0xec, 0x05, 0x94, 0xed, 0xbf, 0xb0, 0xc9, 0xd8, 0x7e, 0x60, 0x36, 0x18, 0xdb, 0x03, 0xa7, 0xb3,
	0xbc, 0x45, 0x21, 0xee, 0xae, 0x3e, 0xc0, 0x8f, 0x53, 0xdf, 0x83, 0xf3, 0x68, 0x94, 0xb6, 0xfb,
	0x45, 0x32, 0x66, 0xc7, 0xc5, 0xc8, 0xf2, 0x4b, 0x2a, 0xdc, 0x75, 0x07, 0x90, 0x97, 0x59, 0xa9,
	0xe8, 0x6f, 0x5d, 0xd7, 0xad, 0x97, 0x66, 0x38, 0xc9, 0x28, 0x16, 0x26, 0x26, 0xe5, 0xd9, 0x26,
	0x4f, 0x61, 0xf6, 0x26, 0x42, 0x54, 0x9e, 0xad, 0xf4, 0x96, 0x95, 0xc3, 0xad, 0x9c, 0x3d, 0xff,
	0x0c, 0x00, 0x00, 0xff, 0xff, 0x9e, 0x24, 0x02, 0xf2, 0x66, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AudioPlayerClient is the client API for AudioPlayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AudioPlayerClient interface {
	// OpenInDownloads launches the Files app, opening the file by the
	// relative path insides the Downloads directory.
	OpenInDownloads(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Focus makes the window switched to the audio player.
	Focus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Close closes the Audio Player app.
	Close(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// CloseAll closes the Audio Player and the Files app.
	CloseAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Play resumes the audio in the player.
	Play(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Pause pauses the audio the player is playing.
	Pause(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// CurrentTime returns the playing time of the player in seconds.
	CurrentTime(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TimeResponse, error)
	// MustPlaying checks if the player is playing the audio, retunring
	// an error if it's not.
	MustPlaying(ctx context.Context, in *TimeoutRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// MustPaused checks if the player is paused, returning an error
	// if it's not.
	MustPaused(ctx context.Context, in *TimeoutRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type audioPlayerClient struct {
	cc *grpc.ClientConn
}

func NewAudioPlayerClient(cc *grpc.ClientConn) AudioPlayerClient {
	return &audioPlayerClient{cc}
}

func (c *audioPlayerClient) OpenInDownloads(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.AudioPlayer/OpenInDownloads", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioPlayerClient) Focus(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.AudioPlayer/Focus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioPlayerClient) Close(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.AudioPlayer/Close", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioPlayerClient) CloseAll(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.AudioPlayer/CloseAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioPlayerClient) Play(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.AudioPlayer/Play", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioPlayerClient) Pause(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.AudioPlayer/Pause", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioPlayerClient) CurrentTime(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TimeResponse, error) {
	out := new(TimeResponse)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.AudioPlayer/CurrentTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioPlayerClient) MustPlaying(ctx context.Context, in *TimeoutRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.AudioPlayer/MustPlaying", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *audioPlayerClient) MustPaused(ctx context.Context, in *TimeoutRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.AudioPlayer/MustPaused", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AudioPlayerServer is the server API for AudioPlayer service.
type AudioPlayerServer interface {
	// OpenInDownloads launches the Files app, opening the file by the
	// relative path insides the Downloads directory.
	OpenInDownloads(context.Context, *FileRequest) (*empty.Empty, error)
	// Focus makes the window switched to the audio player.
	Focus(context.Context, *empty.Empty) (*empty.Empty, error)
	// Close closes the Audio Player app.
	Close(context.Context, *empty.Empty) (*empty.Empty, error)
	// CloseAll closes the Audio Player and the Files app.
	CloseAll(context.Context, *empty.Empty) (*empty.Empty, error)
	// Play resumes the audio in the player.
	Play(context.Context, *empty.Empty) (*empty.Empty, error)
	// Pause pauses the audio the player is playing.
	Pause(context.Context, *empty.Empty) (*empty.Empty, error)
	// CurrentTime returns the playing time of the player in seconds.
	CurrentTime(context.Context, *empty.Empty) (*TimeResponse, error)
	// MustPlaying checks if the player is playing the audio, retunring
	// an error if it's not.
	MustPlaying(context.Context, *TimeoutRequest) (*empty.Empty, error)
	// MustPaused checks if the player is paused, returning an error
	// if it's not.
	MustPaused(context.Context, *TimeoutRequest) (*empty.Empty, error)
}

// UnimplementedAudioPlayerServer can be embedded to have forward compatible implementations.
type UnimplementedAudioPlayerServer struct {
}

func (*UnimplementedAudioPlayerServer) OpenInDownloads(ctx context.Context, req *FileRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenInDownloads not implemented")
}
func (*UnimplementedAudioPlayerServer) Focus(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Focus not implemented")
}
func (*UnimplementedAudioPlayerServer) Close(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Close not implemented")
}
func (*UnimplementedAudioPlayerServer) CloseAll(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseAll not implemented")
}
func (*UnimplementedAudioPlayerServer) Play(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Play not implemented")
}
func (*UnimplementedAudioPlayerServer) Pause(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pause not implemented")
}
func (*UnimplementedAudioPlayerServer) CurrentTime(ctx context.Context, req *empty.Empty) (*TimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentTime not implemented")
}
func (*UnimplementedAudioPlayerServer) MustPlaying(ctx context.Context, req *TimeoutRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MustPlaying not implemented")
}
func (*UnimplementedAudioPlayerServer) MustPaused(ctx context.Context, req *TimeoutRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MustPaused not implemented")
}

func RegisterAudioPlayerServer(s *grpc.Server, srv AudioPlayerServer) {
	s.RegisterService(&_AudioPlayer_serviceDesc, srv)
}

func _AudioPlayer_OpenInDownloads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioPlayerServer).OpenInDownloads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.AudioPlayer/OpenInDownloads",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioPlayerServer).OpenInDownloads(ctx, req.(*FileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioPlayer_Focus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioPlayerServer).Focus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.AudioPlayer/Focus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioPlayerServer).Focus(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioPlayer_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioPlayerServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.AudioPlayer/Close",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioPlayerServer).Close(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioPlayer_CloseAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioPlayerServer).CloseAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.AudioPlayer/CloseAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioPlayerServer).CloseAll(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioPlayer_Play_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioPlayerServer).Play(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.AudioPlayer/Play",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioPlayerServer).Play(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioPlayer_Pause_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioPlayerServer).Pause(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.AudioPlayer/Pause",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioPlayerServer).Pause(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioPlayer_CurrentTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioPlayerServer).CurrentTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.AudioPlayer/CurrentTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioPlayerServer).CurrentTime(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioPlayer_MustPlaying_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioPlayerServer).MustPlaying(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.AudioPlayer/MustPlaying",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioPlayerServer).MustPlaying(ctx, req.(*TimeoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AudioPlayer_MustPaused_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AudioPlayerServer).MustPaused(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.AudioPlayer/MustPaused",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AudioPlayerServer).MustPaused(ctx, req.(*TimeoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AudioPlayer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.mtbf.multimedia.AudioPlayer",
	HandlerType: (*AudioPlayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpenInDownloads",
			Handler:    _AudioPlayer_OpenInDownloads_Handler,
		},
		{
			MethodName: "Focus",
			Handler:    _AudioPlayer_Focus_Handler,
		},
		{
			MethodName: "Close",
			Handler:    _AudioPlayer_Close_Handler,
		},
		{
			MethodName: "CloseAll",
			Handler:    _AudioPlayer_CloseAll_Handler,
		},
		{
			MethodName: "Play",
			Handler:    _AudioPlayer_Play_Handler,
		},
		{
			MethodName: "Pause",
			Handler:    _AudioPlayer_Pause_Handler,
		},
		{
			MethodName: "CurrentTime",
			Handler:    _AudioPlayer_CurrentTime_Handler,
		},
		{
			MethodName: "MustPlaying",
			Handler:    _AudioPlayer_MustPlaying_Handler,
		},
		{
			MethodName: "MustPaused",
			Handler:    _AudioPlayer_MustPaused_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "audio_player.proto",
}
