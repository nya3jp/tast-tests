// Code generated by protoc-gen-go. DO NOT EDIT.
// source: volume_service.proto

package multimedia

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type FnKey int32

const (
	FnKey_UNKNOWN FnKey = 0
	FnKey_F8      FnKey = 8
	FnKey_F9      FnKey = 9
	FnKey_F10     FnKey = 10
)

var FnKey_name = map[int32]string{
	0:  "UNKNOWN",
	8:  "F8",
	9:  "F9",
	10: "F10",
}

var FnKey_value = map[string]int32{
	"UNKNOWN": 0,
	"F8":      8,
	"F9":      9,
	"F10":     10,
}

func (x FnKey) String() string {
	return proto.EnumName(FnKey_name, int32(x))
}

func (FnKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eb8bec198281e5c, []int{0}
}

type VolumeRequest struct {
	Value int64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	// Check indicates whether to verify the new volume after the request
	// is applied.
	Check                bool     `protobuf:"varint,2,opt,name=check,proto3" json:"check,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeRequest) Reset()         { *m = VolumeRequest{} }
func (m *VolumeRequest) String() string { return proto.CompactTextString(m) }
func (*VolumeRequest) ProtoMessage()    {}
func (*VolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4eb8bec198281e5c, []int{0}
}

func (m *VolumeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeRequest.Unmarshal(m, b)
}
func (m *VolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeRequest.Marshal(b, m, deterministic)
}
func (m *VolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeRequest.Merge(m, src)
}
func (m *VolumeRequest) XXX_Size() int {
	return xxx_messageInfo_VolumeRequest.Size(m)
}
func (m *VolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeRequest proto.InternalMessageInfo

func (m *VolumeRequest) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *VolumeRequest) GetCheck() bool {
	if m != nil {
		return m.Check
	}
	return false
}

type VolumeResponse struct {
	Value                int64    `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Mute                 bool     `protobuf:"varint,2,opt,name=mute,proto3" json:"mute,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeResponse) Reset()         { *m = VolumeResponse{} }
func (m *VolumeResponse) String() string { return proto.CompactTextString(m) }
func (*VolumeResponse) ProtoMessage()    {}
func (*VolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4eb8bec198281e5c, []int{1}
}

func (m *VolumeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeResponse.Unmarshal(m, b)
}
func (m *VolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeResponse.Marshal(b, m, deterministic)
}
func (m *VolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeResponse.Merge(m, src)
}
func (m *VolumeResponse) XXX_Size() int {
	return xxx_messageInfo_VolumeResponse.Size(m)
}
func (m *VolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeResponse proto.InternalMessageInfo

func (m *VolumeResponse) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *VolumeResponse) GetMute() bool {
	if m != nil {
		return m.Mute
	}
	return false
}

type PressKeyRequest struct {
	Key FnKey `protobuf:"varint,1,opt,name=key,proto3,enum=tast.mtbf.multimedia.FnKey" json:"key,omitempty"`
	// Check indicates whether to verify the new volume after the request
	// is applied.
	Check                bool     `protobuf:"varint,2,opt,name=check,proto3" json:"check,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PressKeyRequest) Reset()         { *m = PressKeyRequest{} }
func (m *PressKeyRequest) String() string { return proto.CompactTextString(m) }
func (*PressKeyRequest) ProtoMessage()    {}
func (*PressKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4eb8bec198281e5c, []int{2}
}

func (m *PressKeyRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PressKeyRequest.Unmarshal(m, b)
}
func (m *PressKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PressKeyRequest.Marshal(b, m, deterministic)
}
func (m *PressKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PressKeyRequest.Merge(m, src)
}
func (m *PressKeyRequest) XXX_Size() int {
	return xxx_messageInfo_PressKeyRequest.Size(m)
}
func (m *PressKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PressKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PressKeyRequest proto.InternalMessageInfo

func (m *PressKeyRequest) GetKey() FnKey {
	if m != nil {
		return m.Key
	}
	return FnKey_UNKNOWN
}

func (m *PressKeyRequest) GetCheck() bool {
	if m != nil {
		return m.Check
	}
	return false
}

func init() {
	proto.RegisterEnum("tast.mtbf.multimedia.FnKey", FnKey_name, FnKey_value)
	proto.RegisterType((*VolumeRequest)(nil), "tast.mtbf.multimedia.VolumeRequest")
	proto.RegisterType((*VolumeResponse)(nil), "tast.mtbf.multimedia.VolumeResponse")
	proto.RegisterType((*PressKeyRequest)(nil), "tast.mtbf.multimedia.PressKeyRequest")
}

func init() { proto.RegisterFile("volume_service.proto", fileDescriptor_4eb8bec198281e5c) }

var fileDescriptor_4eb8bec198281e5c = []byte{
	// 349 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0x5f, 0x4b, 0x02, 0x41,
	0x14, 0xc5, 0xd3, 0xf5, 0x5f, 0x37, 0xb2, 0x65, 0x90, 0x10, 0x7d, 0x11, 0x2b, 0x10, 0xc1, 0xd9,
	0x32, 0x08, 0xab, 0x37, 0x23, 0x7b, 0x90, 0x2c, 0x14, 0x15, 0x7a, 0x09, 0xdd, 0xae, 0xba, 0xb8,
	0xe3, 0xd8, 0xce, 0x8c, 0xe0, 0xe7, 0xed, 0x8b, 0xc4, 0xce, 0xba, 0x04, 0xb2, 0x1b, 0xd1, 0xd3,
	0xee, 0x1d, 0xce, 0x6f, 0xee, 0xb9, 0xe7, 0x0e, 0x14, 0x36, 0xdc, 0x55, 0x0c, 0xdf, 0x05, 0x7a,
	0x1b, 0xc7, 0x46, 0xba, 0xf6, 0xb8, 0xe4, 0xa4, 0x20, 0x27, 0x42, 0x52, 0x26, 0xa7, 0x33, 0xca,
	0x94, 0x2b, 0x1d, 0x86, 0x1f, 0xce, 0xa4, 0x54, 0x9e, 0x73, 0x3e, 0x77, 0xd1, 0xd2, 0x9a, 0xa9,
	0x9a, 0x59, 0xc8, 0xd6, 0x72, 0x1b, 0x20, 0xd5, 0x7b, 0x38, 0x1e, 0xe9, 0xab, 0xfa, 0xf8, 0xa9,
	0x50, 0x48, 0x52, 0x80, 0xf4, 0x66, 0xe2, 0x2a, 0x2c, 0x26, 0x2a, 0x89, 0x9a, 0xd1, 0x0f, 0x0a,
	0xff, 0xd4, 0x5e, 0xa0, 0xbd, 0x2c, 0x26, 0x2b, 0x89, 0x5a, 0xae, 0x1f, 0x14, 0xd5, 0x3b, 0xc8,
	0x87, 0xb0, 0x58, 0xf3, 0x95, 0xc0, 0x18, 0x9a, 0x40, 0x8a, 0x29, 0x89, 0x3b, 0x58, 0xff, 0x57,
	0x47, 0x70, 0xf2, 0xea, 0xa1, 0x10, 0x5d, 0xdc, 0x86, 0xad, 0x1b, 0x60, 0x2c, 0x71, 0xab, 0xd1,
	0x7c, 0xb3, 0x4c, 0xa3, 0x86, 0xa1, 0x9d, 0x95, 0x0f, 0xf8, 0xba, 0x68, 0x4f, 0xf5, 0x06, 0xa4,
	0xb5, 0x86, 0x1c, 0x41, 0x76, 0xd8, 0xeb, 0xf6, 0x5e, 0xc6, 0x3d, 0xf3, 0x80, 0x64, 0x20, 0xd9,
	0x69, 0x99, 0x39, 0xfd, 0xbd, 0x35, 0x0f, 0x49, 0x16, 0x8c, 0xce, 0xd5, 0xa5, 0x09, 0xcd, 0xaf,
	0x64, 0x18, 0xc0, 0x20, 0x88, 0x92, 0x3c, 0x80, 0xf1, 0x84, 0x92, 0x9c, 0xd2, 0x20, 0x36, 0x1a,
	0xc6, 0x46, 0x1f, 0xfd, 0xd8, 0x4a, 0xe7, 0xd1, 0xbe, 0xf6, 0x72, 0x68, 0x83, 0x31, 0x40, 0x49,
	0xce, 0x7e, 0x17, 0xeb, 0xb1, 0x4b, 0x31, 0x9d, 0xc8, 0x0d, 0xa4, 0x9e, 0x95, 0xc4, 0x58, 0x27,
	0x71, 0x5c, 0x0b, 0x32, 0xc3, 0x15, 0xfb, 0x0f, 0x39, 0x86, 0x5c, 0xb8, 0x13, 0x72, 0x11, 0x6d,
	0x7d, 0x6f, 0x67, 0x7f, 0x8b, 0xa3, 0x5d, 0x7f, 0xab, 0xd9, 0x0b, 0x8f, 0x33, 0x47, 0x31, 0x2e,
	0x2c, 0x9f, 0xb0, 0x76, 0x2f, 0x57, 0x58, 0x3e, 0x6a, 0xfd, 0xa0, 0xd3, 0x8c, 0x36, 0x75, 0xfd,
	0x1d, 0x00, 0x00, 0xff, 0xff, 0x96, 0xab, 0xff, 0x09, 0xe3, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VolumeServiceClient is the client API for VolumeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VolumeServiceClient interface {
	Get(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VolumeResponse, error)
	Set(ctx context.Context, in *VolumeRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Mute(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	Unmute(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// PressKey sets the volume by simulating a function key pressed.
	PressKey(ctx context.Context, in *PressKeyRequest, opts ...grpc.CallOption) (*VolumeResponse, error)
}

type volumeServiceClient struct {
	cc *grpc.ClientConn
}

func NewVolumeServiceClient(cc *grpc.ClientConn) VolumeServiceClient {
	return &volumeServiceClient{cc}
}

func (c *volumeServiceClient) Get(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VolumeResponse, error) {
	out := new(VolumeResponse)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.VolumeService/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Set(ctx context.Context, in *VolumeRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.VolumeService/Set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Mute(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.VolumeService/Mute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) Unmute(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.VolumeService/Unmute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) PressKey(ctx context.Context, in *PressKeyRequest, opts ...grpc.CallOption) (*VolumeResponse, error) {
	out := new(VolumeResponse)
	err := c.cc.Invoke(ctx, "/tast.mtbf.multimedia.VolumeService/PressKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VolumeServiceServer is the server API for VolumeService service.
type VolumeServiceServer interface {
	Get(context.Context, *empty.Empty) (*VolumeResponse, error)
	Set(context.Context, *VolumeRequest) (*empty.Empty, error)
	Mute(context.Context, *empty.Empty) (*empty.Empty, error)
	Unmute(context.Context, *empty.Empty) (*empty.Empty, error)
	// PressKey sets the volume by simulating a function key pressed.
	PressKey(context.Context, *PressKeyRequest) (*VolumeResponse, error)
}

// UnimplementedVolumeServiceServer can be embedded to have forward compatible implementations.
type UnimplementedVolumeServiceServer struct {
}

func (*UnimplementedVolumeServiceServer) Get(ctx context.Context, req *empty.Empty) (*VolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (*UnimplementedVolumeServiceServer) Set(ctx context.Context, req *VolumeRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (*UnimplementedVolumeServiceServer) Mute(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mute not implemented")
}
func (*UnimplementedVolumeServiceServer) Unmute(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unmute not implemented")
}
func (*UnimplementedVolumeServiceServer) PressKey(ctx context.Context, req *PressKeyRequest) (*VolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PressKey not implemented")
}

func RegisterVolumeServiceServer(s *grpc.Server, srv VolumeServiceServer) {
	s.RegisterService(&_VolumeService_serviceDesc, srv)
}

func _VolumeService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.VolumeService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Get(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.VolumeService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Set(ctx, req.(*VolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Mute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Mute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.VolumeService/Mute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Mute(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_Unmute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).Unmute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.VolumeService/Unmute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).Unmute(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_PressKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PressKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).PressKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.multimedia.VolumeService/PressKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).PressKey(ctx, req.(*PressKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VolumeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.mtbf.multimedia.VolumeService",
	HandlerType: (*VolumeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _VolumeService_Get_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _VolumeService_Set_Handler,
		},
		{
			MethodName: "Mute",
			Handler:    _VolumeService_Mute_Handler,
		},
		{
			MethodName: "Unmute",
			Handler:    _VolumeService_Unmute_Handler,
		},
		{
			MethodName: "PressKey",
			Handler:    _VolumeService_PressKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "volume_service.proto",
}
