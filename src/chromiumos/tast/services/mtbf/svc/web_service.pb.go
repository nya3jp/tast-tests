// Code generated by protoc-gen-go. DO NOT EDIT.
// source: web_service.proto

package svc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type OpenURLRequest struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OpenURLRequest) Reset()         { *m = OpenURLRequest{} }
func (m *OpenURLRequest) String() string { return proto.CompactTextString(m) }
func (*OpenURLRequest) ProtoMessage()    {}
func (*OpenURLRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_401bbbc62b3591d2, []int{0}
}

func (m *OpenURLRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OpenURLRequest.Unmarshal(m, b)
}
func (m *OpenURLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OpenURLRequest.Marshal(b, m, deterministic)
}
func (m *OpenURLRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenURLRequest.Merge(m, src)
}
func (m *OpenURLRequest) XXX_Size() int {
	return xxx_messageInfo_OpenURLRequest.Size(m)
}
func (m *OpenURLRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenURLRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OpenURLRequest proto.InternalMessageInfo

func (m *OpenURLRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type CloseURLRequest struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloseURLRequest) Reset()         { *m = CloseURLRequest{} }
func (m *CloseURLRequest) String() string { return proto.CompactTextString(m) }
func (*CloseURLRequest) ProtoMessage()    {}
func (*CloseURLRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_401bbbc62b3591d2, []int{1}
}

func (m *CloseURLRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloseURLRequest.Unmarshal(m, b)
}
func (m *CloseURLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloseURLRequest.Marshal(b, m, deterministic)
}
func (m *CloseURLRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseURLRequest.Merge(m, src)
}
func (m *CloseURLRequest) XXX_Size() int {
	return xxx_messageInfo_CloseURLRequest.Size(m)
}
func (m *CloseURLRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseURLRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CloseURLRequest proto.InternalMessageInfo

func (m *CloseURLRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type ClickRequest struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Selector             string   `protobuf:"bytes,2,opt,name=selector,proto3" json:"selector,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClickRequest) Reset()         { *m = ClickRequest{} }
func (m *ClickRequest) String() string { return proto.CompactTextString(m) }
func (*ClickRequest) ProtoMessage()    {}
func (*ClickRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_401bbbc62b3591d2, []int{2}
}

func (m *ClickRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClickRequest.Unmarshal(m, b)
}
func (m *ClickRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClickRequest.Marshal(b, m, deterministic)
}
func (m *ClickRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClickRequest.Merge(m, src)
}
func (m *ClickRequest) XXX_Size() int {
	return xxx_messageInfo_ClickRequest.Size(m)
}
func (m *ClickRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClickRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClickRequest proto.InternalMessageInfo

func (m *ClickRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ClickRequest) GetSelector() string {
	if m != nil {
		return m.Selector
	}
	return ""
}

type ClickLinkByNameRequest struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClickLinkByNameRequest) Reset()         { *m = ClickLinkByNameRequest{} }
func (m *ClickLinkByNameRequest) String() string { return proto.CompactTextString(m) }
func (*ClickLinkByNameRequest) ProtoMessage()    {}
func (*ClickLinkByNameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_401bbbc62b3591d2, []int{3}
}

func (m *ClickLinkByNameRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClickLinkByNameRequest.Unmarshal(m, b)
}
func (m *ClickLinkByNameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClickLinkByNameRequest.Marshal(b, m, deterministic)
}
func (m *ClickLinkByNameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClickLinkByNameRequest.Merge(m, src)
}
func (m *ClickLinkByNameRequest) XXX_Size() int {
	return xxx_messageInfo_ClickLinkByNameRequest.Size(m)
}
func (m *ClickLinkByNameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClickLinkByNameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClickLinkByNameRequest proto.InternalMessageInfo

func (m *ClickLinkByNameRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ClickLinkByNameRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PlayElementRequest struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Selector             string   `protobuf:"bytes,2,opt,name=selector,proto3" json:"selector,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayElementRequest) Reset()         { *m = PlayElementRequest{} }
func (m *PlayElementRequest) String() string { return proto.CompactTextString(m) }
func (*PlayElementRequest) ProtoMessage()    {}
func (*PlayElementRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_401bbbc62b3591d2, []int{4}
}

func (m *PlayElementRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlayElementRequest.Unmarshal(m, b)
}
func (m *PlayElementRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlayElementRequest.Marshal(b, m, deterministic)
}
func (m *PlayElementRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayElementRequest.Merge(m, src)
}
func (m *PlayElementRequest) XXX_Size() int {
	return xxx_messageInfo_PlayElementRequest.Size(m)
}
func (m *PlayElementRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayElementRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PlayElementRequest proto.InternalMessageInfo

func (m *PlayElementRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *PlayElementRequest) GetSelector() string {
	if m != nil {
		return m.Selector
	}
	return ""
}

type IsGmailChatRoomExistsResponse struct {
	IsExists             bool     `protobuf:"varint,1,opt,name=isExists,proto3" json:"isExists,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IsGmailChatRoomExistsResponse) Reset()         { *m = IsGmailChatRoomExistsResponse{} }
func (m *IsGmailChatRoomExistsResponse) String() string { return proto.CompactTextString(m) }
func (*IsGmailChatRoomExistsResponse) ProtoMessage()    {}
func (*IsGmailChatRoomExistsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_401bbbc62b3591d2, []int{5}
}

func (m *IsGmailChatRoomExistsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IsGmailChatRoomExistsResponse.Unmarshal(m, b)
}
func (m *IsGmailChatRoomExistsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IsGmailChatRoomExistsResponse.Marshal(b, m, deterministic)
}
func (m *IsGmailChatRoomExistsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsGmailChatRoomExistsResponse.Merge(m, src)
}
func (m *IsGmailChatRoomExistsResponse) XXX_Size() int {
	return xxx_messageInfo_IsGmailChatRoomExistsResponse.Size(m)
}
func (m *IsGmailChatRoomExistsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IsGmailChatRoomExistsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IsGmailChatRoomExistsResponse proto.InternalMessageInfo

func (m *IsGmailChatRoomExistsResponse) GetIsExists() bool {
	if m != nil {
		return m.IsExists
	}
	return false
}

type JoinAppRTCRoomRequest struct {
	RoomName             string   `protobuf:"bytes,1,opt,name=roomName,proto3" json:"roomName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JoinAppRTCRoomRequest) Reset()         { *m = JoinAppRTCRoomRequest{} }
func (m *JoinAppRTCRoomRequest) String() string { return proto.CompactTextString(m) }
func (*JoinAppRTCRoomRequest) ProtoMessage()    {}
func (*JoinAppRTCRoomRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_401bbbc62b3591d2, []int{6}
}

func (m *JoinAppRTCRoomRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JoinAppRTCRoomRequest.Unmarshal(m, b)
}
func (m *JoinAppRTCRoomRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JoinAppRTCRoomRequest.Marshal(b, m, deterministic)
}
func (m *JoinAppRTCRoomRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinAppRTCRoomRequest.Merge(m, src)
}
func (m *JoinAppRTCRoomRequest) XXX_Size() int {
	return xxx_messageInfo_JoinAppRTCRoomRequest.Size(m)
}
func (m *JoinAppRTCRoomRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinAppRTCRoomRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JoinAppRTCRoomRequest proto.InternalMessageInfo

func (m *JoinAppRTCRoomRequest) GetRoomName() string {
	if m != nil {
		return m.RoomName
	}
	return ""
}

func init() {
	proto.RegisterType((*OpenURLRequest)(nil), "tast.mtbf.svc.OpenURLRequest")
	proto.RegisterType((*CloseURLRequest)(nil), "tast.mtbf.svc.CloseURLRequest")
	proto.RegisterType((*ClickRequest)(nil), "tast.mtbf.svc.ClickRequest")
	proto.RegisterType((*ClickLinkByNameRequest)(nil), "tast.mtbf.svc.ClickLinkByNameRequest")
	proto.RegisterType((*PlayElementRequest)(nil), "tast.mtbf.svc.PlayElementRequest")
	proto.RegisterType((*IsGmailChatRoomExistsResponse)(nil), "tast.mtbf.svc.IsGmailChatRoomExistsResponse")
	proto.RegisterType((*JoinAppRTCRoomRequest)(nil), "tast.mtbf.svc.JoinAppRTCRoomRequest")
}

func init() { proto.RegisterFile("web_service.proto", fileDescriptor_401bbbc62b3591d2) }

var fileDescriptor_401bbbc62b3591d2 = []byte{
	// 416 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x93, 0xdf, 0x8b, 0xd3, 0x40,
	0x10, 0xc7, 0x39, 0x3d, 0x35, 0x8e, 0x7a, 0xea, 0xc2, 0x1d, 0x47, 0x8e, 0x13, 0x9b, 0x2a, 0xf8,
	0x20, 0x1b, 0xb0, 0x8f, 0x16, 0xd1, 0x84, 0xe2, 0x0f, 0x4a, 0x2d, 0x51, 0x11, 0x04, 0x91, 0x24,
	0x4c, 0xdb, 0xa5, 0xbb, 0xd9, 0x98, 0xdd, 0x54, 0xfb, 0xb7, 0xf8, 0xcf, 0xca, 0x26, 0x69, 0x35,
	0x69, 0xb7, 0x0f, 0xf7, 0xb6, 0xb3, 0x99, 0xef, 0x27, 0x13, 0x3e, 0x13, 0x78, 0xf8, 0x0b, 0x93,
	0x1f, 0x0a, 0x8b, 0x15, 0x4b, 0x91, 0xe6, 0x85, 0xd4, 0x92, 0xdc, 0xd3, 0xb1, 0xd2, 0x54, 0xe8,
	0x64, 0x46, 0xd5, 0x2a, 0x75, 0x2f, 0xe6, 0x52, 0xce, 0x39, 0xfa, 0xd5, 0xc3, 0xa4, 0x9c, 0xf9,
	0x28, 0x72, 0xbd, 0xae, 0x7b, 0x3d, 0x0f, 0x4e, 0x3e, 0xe6, 0x98, 0x7d, 0x89, 0xc6, 0x11, 0xfe,
	0x2c, 0x51, 0x69, 0xf2, 0x00, 0xae, 0x97, 0x05, 0x3f, 0x3f, 0x7a, 0x7c, 0xf4, 0xec, 0x76, 0x64,
	0x8e, 0x5e, 0x1f, 0xee, 0x87, 0x5c, 0x2a, 0x3c, 0xd8, 0x34, 0x84, 0xbb, 0x21, 0x67, 0xe9, 0xd2,
	0xda, 0x41, 0x5c, 0x70, 0x14, 0x72, 0x4c, 0xb5, 0x2c, 0xce, 0xaf, 0x55, 0xd7, 0xdb, 0xda, 0x7b,
	0x05, 0x67, 0x55, 0x7a, 0xcc, 0xb2, 0x65, 0xb0, 0x9e, 0xc4, 0x02, 0xed, 0x1c, 0x02, 0xc7, 0x59,
	0x2c, 0xb0, 0x61, 0x54, 0x67, 0x2f, 0x00, 0x32, 0xe5, 0xf1, 0x7a, 0xc4, 0x51, 0x60, 0xa6, 0xaf,
	0x36, 0xc3, 0x4b, 0xb8, 0x7c, 0xaf, 0xde, 0x8a, 0x98, 0xf1, 0x70, 0x11, 0xeb, 0x48, 0x4a, 0x31,
	0xfa, 0xcd, 0x94, 0x56, 0x11, 0xaa, 0x5c, 0x66, 0x0a, 0x4d, 0x98, 0xa9, 0xfa, 0xae, 0x62, 0x3a,
	0xd1, 0xb6, 0xf6, 0x06, 0x70, 0xfa, 0x41, 0xb2, 0xec, 0x4d, 0x9e, 0x47, 0x9f, 0x43, 0x93, 0xdd,
	0xcc, 0xe0, 0x82, 0x53, 0x48, 0x29, 0xcc, 0x27, 0x35, 0x83, 0x6c, 0xeb, 0x17, 0x7f, 0x8e, 0x01,
	0xbe, 0x62, 0xf2, 0xa9, 0xb6, 0x47, 0x5e, 0xc3, 0xad, 0xc6, 0x05, 0xb9, 0xa4, 0x2d, 0x87, 0xb4,
	0xed, 0xc8, 0x3d, 0xa3, 0xb5, 0x53, 0xba, 0x71, 0x4a, 0x47, 0xc6, 0x29, 0x09, 0xc0, 0xd9, 0x98,
	0x22, 0x8f, 0x3a, 0x88, 0x8e, 0x42, 0x2b, 0x63, 0x08, 0x37, 0x2a, 0x15, 0xe4, 0x62, 0x07, 0xf0,
	0x4f, 0xaf, 0x35, 0x3d, 0x35, 0xbb, 0xd2, 0x12, 0x49, 0x9e, 0xee, 0xe3, 0xec, 0x88, 0xb6, 0x12,
	0xdf, 0xc1, 0x9d, 0xff, 0xd4, 0x92, 0x5e, 0x87, 0xb6, 0xab, 0xdd, 0x4a, 0xfa, 0x0e, 0xa7, 0x7b,
	0x05, 0x13, 0x4b, 0xc0, 0x7d, 0xde, 0x79, 0xd7, 0xe1, 0xf5, 0x98, 0xc0, 0x49, 0x7b, 0x05, 0xc8,
	0x93, 0x4e, 0x7e, 0xef, 0x86, 0xd8, 0xc6, 0x0d, 0xfa, 0xdf, 0x7a, 0xe9, 0xa2, 0x90, 0x82, 0x95,
	0x42, 0x2a, 0xdf, 0x90, 0xfc, 0xe6, 0x3f, 0x57, 0xbe, 0x41, 0xfa, 0x6a, 0x95, 0x26, 0x37, 0xab,
	0xd0, 0xe0, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x34, 0xdf, 0x5f, 0xcc, 0x07, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WebServiceClient is the client API for WebService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WebServiceClient interface {
	OpenURL(ctx context.Context, in *OpenURLRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	CloseURL(ctx context.Context, in *CloseURLRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	Click(ctx context.Context, in *ClickRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	ClickLinkByName(ctx context.Context, in *ClickLinkByNameRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	PlayElement(ctx context.Context, in *PlayElementRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	IsGmailChatRoomExists(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsGmailChatRoomExistsResponse, error)
	JoinAppRTCRoom(ctx context.Context, in *JoinAppRTCRoomRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type webServiceClient struct {
	cc *grpc.ClientConn
}

func NewWebServiceClient(cc *grpc.ClientConn) WebServiceClient {
	return &webServiceClient{cc}
}

func (c *webServiceClient) OpenURL(ctx context.Context, in *OpenURLRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.svc.WebService/OpenURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webServiceClient) CloseURL(ctx context.Context, in *CloseURLRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.svc.WebService/CloseURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webServiceClient) Click(ctx context.Context, in *ClickRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.svc.WebService/Click", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webServiceClient) ClickLinkByName(ctx context.Context, in *ClickLinkByNameRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.svc.WebService/ClickLinkByName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webServiceClient) PlayElement(ctx context.Context, in *PlayElementRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.svc.WebService/PlayElement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webServiceClient) IsGmailChatRoomExists(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsGmailChatRoomExistsResponse, error) {
	out := new(IsGmailChatRoomExistsResponse)
	err := c.cc.Invoke(ctx, "/tast.mtbf.svc.WebService/IsGmailChatRoomExists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webServiceClient) JoinAppRTCRoom(ctx context.Context, in *JoinAppRTCRoomRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.mtbf.svc.WebService/JoinAppRTCRoom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebServiceServer is the server API for WebService service.
type WebServiceServer interface {
	OpenURL(context.Context, *OpenURLRequest) (*empty.Empty, error)
	CloseURL(context.Context, *CloseURLRequest) (*empty.Empty, error)
	Click(context.Context, *ClickRequest) (*empty.Empty, error)
	ClickLinkByName(context.Context, *ClickLinkByNameRequest) (*empty.Empty, error)
	PlayElement(context.Context, *PlayElementRequest) (*empty.Empty, error)
	IsGmailChatRoomExists(context.Context, *empty.Empty) (*IsGmailChatRoomExistsResponse, error)
	JoinAppRTCRoom(context.Context, *JoinAppRTCRoomRequest) (*empty.Empty, error)
}

// UnimplementedWebServiceServer can be embedded to have forward compatible implementations.
type UnimplementedWebServiceServer struct {
}

func (*UnimplementedWebServiceServer) OpenURL(ctx context.Context, req *OpenURLRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenURL not implemented")
}
func (*UnimplementedWebServiceServer) CloseURL(ctx context.Context, req *CloseURLRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseURL not implemented")
}
func (*UnimplementedWebServiceServer) Click(ctx context.Context, req *ClickRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Click not implemented")
}
func (*UnimplementedWebServiceServer) ClickLinkByName(ctx context.Context, req *ClickLinkByNameRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClickLinkByName not implemented")
}
func (*UnimplementedWebServiceServer) PlayElement(ctx context.Context, req *PlayElementRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PlayElement not implemented")
}
func (*UnimplementedWebServiceServer) IsGmailChatRoomExists(ctx context.Context, req *empty.Empty) (*IsGmailChatRoomExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsGmailChatRoomExists not implemented")
}
func (*UnimplementedWebServiceServer) JoinAppRTCRoom(ctx context.Context, req *JoinAppRTCRoomRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinAppRTCRoom not implemented")
}

func RegisterWebServiceServer(s *grpc.Server, srv WebServiceServer) {
	s.RegisterService(&_WebService_serviceDesc, srv)
}

func _WebService_OpenURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServiceServer).OpenURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.svc.WebService/OpenURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServiceServer).OpenURL(ctx, req.(*OpenURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebService_CloseURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServiceServer).CloseURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.svc.WebService/CloseURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServiceServer).CloseURL(ctx, req.(*CloseURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebService_Click_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServiceServer).Click(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.svc.WebService/Click",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServiceServer).Click(ctx, req.(*ClickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebService_ClickLinkByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClickLinkByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServiceServer).ClickLinkByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.svc.WebService/ClickLinkByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServiceServer).ClickLinkByName(ctx, req.(*ClickLinkByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebService_PlayElement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayElementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServiceServer).PlayElement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.svc.WebService/PlayElement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServiceServer).PlayElement(ctx, req.(*PlayElementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebService_IsGmailChatRoomExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServiceServer).IsGmailChatRoomExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.svc.WebService/IsGmailChatRoomExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServiceServer).IsGmailChatRoomExists(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebService_JoinAppRTCRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinAppRTCRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServiceServer).JoinAppRTCRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.mtbf.svc.WebService/JoinAppRTCRoom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServiceServer).JoinAppRTCRoom(ctx, req.(*JoinAppRTCRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WebService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.mtbf.svc.WebService",
	HandlerType: (*WebServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpenURL",
			Handler:    _WebService_OpenURL_Handler,
		},
		{
			MethodName: "CloseURL",
			Handler:    _WebService_CloseURL_Handler,
		},
		{
			MethodName: "Click",
			Handler:    _WebService_Click_Handler,
		},
		{
			MethodName: "ClickLinkByName",
			Handler:    _WebService_ClickLinkByName_Handler,
		},
		{
			MethodName: "PlayElement",
			Handler:    _WebService_PlayElement_Handler,
		},
		{
			MethodName: "IsGmailChatRoomExists",
			Handler:    _WebService_IsGmailChatRoomExists_Handler,
		},
		{
			MethodName: "JoinAppRTCRoom",
			Handler:    _WebService_JoinAppRTCRoom_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "web_service.proto",
}
