// Code generated by protoc-gen-go. DO NOT EDIT.
// source: power_menu_service.proto

package wilco

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SigninRequest struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SigninRequest) Reset()         { *m = SigninRequest{} }
func (m *SigninRequest) String() string { return proto.CompactTextString(m) }
func (*SigninRequest) ProtoMessage()    {}
func (*SigninRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bff766209769325, []int{0}
}

func (m *SigninRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SigninRequest.Unmarshal(m, b)
}
func (m *SigninRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SigninRequest.Marshal(b, m, deterministic)
}
func (m *SigninRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigninRequest.Merge(m, src)
}
func (m *SigninRequest) XXX_Size() int {
	return xxx_messageInfo_SigninRequest.Size(m)
}
func (m *SigninRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SigninRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SigninRequest proto.InternalMessageInfo

func (m *SigninRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type IsPowerMenuPresentResponse struct {
	IsMenuPresent        bool     `protobuf:"varint,1,opt,name=is_menu_present,json=isMenuPresent,proto3" json:"is_menu_present,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IsPowerMenuPresentResponse) Reset()         { *m = IsPowerMenuPresentResponse{} }
func (m *IsPowerMenuPresentResponse) String() string { return proto.CompactTextString(m) }
func (*IsPowerMenuPresentResponse) ProtoMessage()    {}
func (*IsPowerMenuPresentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bff766209769325, []int{1}
}

func (m *IsPowerMenuPresentResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IsPowerMenuPresentResponse.Unmarshal(m, b)
}
func (m *IsPowerMenuPresentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IsPowerMenuPresentResponse.Marshal(b, m, deterministic)
}
func (m *IsPowerMenuPresentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsPowerMenuPresentResponse.Merge(m, src)
}
func (m *IsPowerMenuPresentResponse) XXX_Size() int {
	return xxx_messageInfo_IsPowerMenuPresentResponse.Size(m)
}
func (m *IsPowerMenuPresentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IsPowerMenuPresentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IsPowerMenuPresentResponse proto.InternalMessageInfo

func (m *IsPowerMenuPresentResponse) GetIsMenuPresent() bool {
	if m != nil {
		return m.IsMenuPresent
	}
	return false
}

type IsPowerMenuPresentNoLogInResponse struct {
	IsMenuPresent        bool     `protobuf:"varint,1,opt,name=is_menu_present,json=isMenuPresent,proto3" json:"is_menu_present,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IsPowerMenuPresentNoLogInResponse) Reset()         { *m = IsPowerMenuPresentNoLogInResponse{} }
func (m *IsPowerMenuPresentNoLogInResponse) String() string { return proto.CompactTextString(m) }
func (*IsPowerMenuPresentNoLogInResponse) ProtoMessage()    {}
func (*IsPowerMenuPresentNoLogInResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6bff766209769325, []int{2}
}

func (m *IsPowerMenuPresentNoLogInResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IsPowerMenuPresentNoLogInResponse.Unmarshal(m, b)
}
func (m *IsPowerMenuPresentNoLogInResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IsPowerMenuPresentNoLogInResponse.Marshal(b, m, deterministic)
}
func (m *IsPowerMenuPresentNoLogInResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsPowerMenuPresentNoLogInResponse.Merge(m, src)
}
func (m *IsPowerMenuPresentNoLogInResponse) XXX_Size() int {
	return xxx_messageInfo_IsPowerMenuPresentNoLogInResponse.Size(m)
}
func (m *IsPowerMenuPresentNoLogInResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IsPowerMenuPresentNoLogInResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IsPowerMenuPresentNoLogInResponse proto.InternalMessageInfo

func (m *IsPowerMenuPresentNoLogInResponse) GetIsMenuPresent() bool {
	if m != nil {
		return m.IsMenuPresent
	}
	return false
}

func init() {
	proto.RegisterType((*SigninRequest)(nil), "tast.cros.wilco.SigninRequest")
	proto.RegisterType((*IsPowerMenuPresentResponse)(nil), "tast.cros.wilco.IsPowerMenuPresentResponse")
	proto.RegisterType((*IsPowerMenuPresentNoLogInResponse)(nil), "tast.cros.wilco.IsPowerMenuPresentNoLogInResponse")
}

func init() { proto.RegisterFile("power_menu_service.proto", fileDescriptor_6bff766209769325) }

var fileDescriptor_6bff766209769325 = []byte{
	// 311 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0xcf, 0x4b, 0x02, 0x41,
	0x14, 0xc7, 0x15, 0x21, 0xf2, 0x85, 0x28, 0x73, 0x08, 0x33, 0x88, 0xdc, 0x28, 0x82, 0x60, 0x16,
	0xec, 0x1c, 0x41, 0xd6, 0x41, 0x32, 0x91, 0xf5, 0x56, 0x07, 0xc9, 0xe5, 0xb5, 0x0d, 0xb9, 0xf3,
	0xb6, 0x79, 0xb3, 0x89, 0xff, 0x51, 0x7f, 0x66, 0xcc, 0xae, 0x49, 0xb9, 0x6c, 0x54, 0xb7, 0x65,
	0x67, 0xde, 0xe7, 0xfb, 0xe3, 0x0d, 0xb4, 0x13, 0x5a, 0xa0, 0x99, 0xc6, 0xa8, 0xd3, 0x29, 0xa3,
	0x79, 0x53, 0x21, 0xca, 0xc4, 0x90, 0x25, 0xd1, 0xb4, 0x8f, 0x6c, 0x65, 0x68, 0x88, 0xe5, 0x42,
	0xcd, 0x43, 0xea, 0xec, 0x47, 0x44, 0xd1, 0x1c, 0xfd, 0xec, 0x78, 0x96, 0x3e, 0xf9, 0x18, 0x27,
	0x76, 0x99, 0xdf, 0xf6, 0xba, 0xd0, 0x98, 0xa8, 0x48, 0x2b, 0x1d, 0xe0, 0x6b, 0x8a, 0x6c, 0x45,
	0x0b, 0x6a, 0x2f, 0xb8, 0x6c, 0x57, 0x0f, 0xab, 0xa7, 0xf5, 0xc0, 0x7d, 0x7a, 0xd7, 0xd0, 0x19,
	0xf0, 0xd8, 0xc9, 0xdd, 0xa1, 0x4e, 0xc7, 0x06, 0x19, 0xb5, 0x0d, 0x90, 0x13, 0xd2, 0x8c, 0xe2,
	0x04, 0x9a, 0x8a, 0x73, 0x1f, 0x49, 0x7e, 0x94, 0xcd, 0x6e, 0x07, 0x0d, 0xc5, 0x5f, 0xee, 0x7b,
	0xb7, 0xd0, 0x2d, 0x52, 0x46, 0x34, 0xa4, 0x68, 0xa0, 0xff, 0x0a, 0xeb, 0xbd, 0xd7, 0xa0, 0xb5,
	0x66, 0x4d, 0xf2, 0xf8, 0xe2, 0x02, 0xea, 0x23, 0x5c, 0xf4, 0x9f, 0x0d, 0xc5, 0x28, 0x76, 0x65,
	0x9e, 0x5a, 0x7e, 0xa6, 0x96, 0x37, 0x2e, 0x75, 0xa7, 0xe4, 0xbf, 0x57, 0x11, 0x43, 0x68, 0xad,
	0xc7, 0x57, 0xbe, 0xc4, 0x81, 0xdc, 0x28, 0x53, 0x7e, 0x2b, 0xeb, 0x07, 0xda, 0x25, 0xec, 0xf4,
	0xe7, 0xc4, 0xf8, 0x6f, 0x3b, 0x0f, 0x20, 0x8a, 0x7d, 0x95, 0x72, 0xce, 0x0a, 0x46, 0xcb, 0x57,
	0xe6, 0x55, 0x84, 0x82, 0xbd, 0xd2, 0x65, 0x94, 0x6a, 0xf4, 0x7e, 0xa1, 0xb1, 0xb1, 0x50, 0xaf,
	0x72, 0x75, 0x7c, 0x7f, 0x14, 0xba, 0x0e, 0x54, 0x1a, 0x13, 0xfb, 0x8e, 0xe0, 0xaf, 0xde, 0x2b,
	0xfb, 0x0e, 0xe5, 0x67, 0xa8, 0xd9, 0x56, 0x26, 0x76, 0xfe, 0x11, 0x00, 0x00, 0xff, 0xff, 0x25,
	0x04, 0xde, 0xd3, 0xd8, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PowerMenuServiceClient is the client API for PowerMenuService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PowerMenuServiceClient interface {
	// New logs into a Chrome session as a fake user. Close must be called later
	// to clean up the associated resources.
	NewChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// NewChromeNoLogIn starts a Chrome session without logging in. Close must be
	// called later to clean up the associated resources.
	NewChromeNoLogIn(ctx context.Context, in *SigninRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Close releases the resources obtained by New.
	CloseChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// IsPowerMenuPresent returns a bool indicating the presence of the power menu
	IsPowerMenuPresent(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsPowerMenuPresentResponse, error)
	// IsPowerMenuPresentNoLogIn returns a bool indicating the presence of the
	// power menu at sign-in.
	IsPowerMenuPresentNoLogIn(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsPowerMenuPresentNoLogInResponse, error)
}

type powerMenuServiceClient struct {
	cc *grpc.ClientConn
}

func NewPowerMenuServiceClient(cc *grpc.ClientConn) PowerMenuServiceClient {
	return &powerMenuServiceClient{cc}
}

func (c *powerMenuServiceClient) NewChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.wilco.PowerMenuService/NewChrome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerMenuServiceClient) NewChromeNoLogIn(ctx context.Context, in *SigninRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.wilco.PowerMenuService/NewChromeNoLogIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerMenuServiceClient) CloseChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.wilco.PowerMenuService/CloseChrome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerMenuServiceClient) IsPowerMenuPresent(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsPowerMenuPresentResponse, error) {
	out := new(IsPowerMenuPresentResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.wilco.PowerMenuService/IsPowerMenuPresent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerMenuServiceClient) IsPowerMenuPresentNoLogIn(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsPowerMenuPresentNoLogInResponse, error) {
	out := new(IsPowerMenuPresentNoLogInResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.wilco.PowerMenuService/IsPowerMenuPresentNoLogIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PowerMenuServiceServer is the server API for PowerMenuService service.
type PowerMenuServiceServer interface {
	// New logs into a Chrome session as a fake user. Close must be called later
	// to clean up the associated resources.
	NewChrome(context.Context, *empty.Empty) (*empty.Empty, error)
	// NewChromeNoLogIn starts a Chrome session without logging in. Close must be
	// called later to clean up the associated resources.
	NewChromeNoLogIn(context.Context, *SigninRequest) (*empty.Empty, error)
	// Close releases the resources obtained by New.
	CloseChrome(context.Context, *empty.Empty) (*empty.Empty, error)
	// IsPowerMenuPresent returns a bool indicating the presence of the power menu
	IsPowerMenuPresent(context.Context, *empty.Empty) (*IsPowerMenuPresentResponse, error)
	// IsPowerMenuPresentNoLogIn returns a bool indicating the presence of the
	// power menu at sign-in.
	IsPowerMenuPresentNoLogIn(context.Context, *empty.Empty) (*IsPowerMenuPresentNoLogInResponse, error)
}

// UnimplementedPowerMenuServiceServer can be embedded to have forward compatible implementations.
type UnimplementedPowerMenuServiceServer struct {
}

func (*UnimplementedPowerMenuServiceServer) NewChrome(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewChrome not implemented")
}
func (*UnimplementedPowerMenuServiceServer) NewChromeNoLogIn(ctx context.Context, req *SigninRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewChromeNoLogIn not implemented")
}
func (*UnimplementedPowerMenuServiceServer) CloseChrome(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseChrome not implemented")
}
func (*UnimplementedPowerMenuServiceServer) IsPowerMenuPresent(ctx context.Context, req *empty.Empty) (*IsPowerMenuPresentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPowerMenuPresent not implemented")
}
func (*UnimplementedPowerMenuServiceServer) IsPowerMenuPresentNoLogIn(ctx context.Context, req *empty.Empty) (*IsPowerMenuPresentNoLogInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPowerMenuPresentNoLogIn not implemented")
}

func RegisterPowerMenuServiceServer(s *grpc.Server, srv PowerMenuServiceServer) {
	s.RegisterService(&_PowerMenuService_serviceDesc, srv)
}

func _PowerMenuService_NewChrome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).NewChrome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.wilco.PowerMenuService/NewChrome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).NewChrome(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerMenuService_NewChromeNoLogIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SigninRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).NewChromeNoLogIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.wilco.PowerMenuService/NewChromeNoLogIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).NewChromeNoLogIn(ctx, req.(*SigninRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerMenuService_CloseChrome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).CloseChrome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.wilco.PowerMenuService/CloseChrome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).CloseChrome(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerMenuService_IsPowerMenuPresent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).IsPowerMenuPresent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.wilco.PowerMenuService/IsPowerMenuPresent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).IsPowerMenuPresent(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerMenuService_IsPowerMenuPresentNoLogIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).IsPowerMenuPresentNoLogIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.wilco.PowerMenuService/IsPowerMenuPresentNoLogIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).IsPowerMenuPresentNoLogIn(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _PowerMenuService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.cros.wilco.PowerMenuService",
	HandlerType: (*PowerMenuServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewChrome",
			Handler:    _PowerMenuService_NewChrome_Handler,
		},
		{
			MethodName: "NewChromeNoLogIn",
			Handler:    _PowerMenuService_NewChromeNoLogIn_Handler,
		},
		{
			MethodName: "CloseChrome",
			Handler:    _PowerMenuService_CloseChrome_Handler,
		},
		{
			MethodName: "IsPowerMenuPresent",
			Handler:    _PowerMenuService_IsPowerMenuPresent_Handler,
		},
		{
			MethodName: "IsPowerMenuPresentNoLogIn",
			Handler:    _PowerMenuService_IsPowerMenuPresentNoLogIn_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "power_menu_service.proto",
}
