// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fixture_service.proto

package crash

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SetUpCrashTestRequest_ConsentType int32

const (
	SetUpCrashTestRequest_MOCK_CONSENT SetUpCrashTestRequest_ConsentType = 0
	SetUpCrashTestRequest_REAL_CONSENT SetUpCrashTestRequest_ConsentType = 1
)

var SetUpCrashTestRequest_ConsentType_name = map[int32]string{
	0: "MOCK_CONSENT",
	1: "REAL_CONSENT",
}

var SetUpCrashTestRequest_ConsentType_value = map[string]int32{
	"MOCK_CONSENT": 0,
	"REAL_CONSENT": 1,
}

func (x SetUpCrashTestRequest_ConsentType) String() string {
	return proto.EnumName(SetUpCrashTestRequest_ConsentType_name, int32(x))
}

func (SetUpCrashTestRequest_ConsentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4b51ac24a74eb33d, []int{0, 0}
}

type SetUpCrashTestRequest struct {
	Consent              SetUpCrashTestRequest_ConsentType `protobuf:"varint,1,opt,name=consent,proto3,enum=tast.cros.crash.SetUpCrashTestRequest_ConsentType" json:"consent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *SetUpCrashTestRequest) Reset()         { *m = SetUpCrashTestRequest{} }
func (m *SetUpCrashTestRequest) String() string { return proto.CompactTextString(m) }
func (*SetUpCrashTestRequest) ProtoMessage()    {}
func (*SetUpCrashTestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b51ac24a74eb33d, []int{0}
}

func (m *SetUpCrashTestRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetUpCrashTestRequest.Unmarshal(m, b)
}
func (m *SetUpCrashTestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetUpCrashTestRequest.Marshal(b, m, deterministic)
}
func (m *SetUpCrashTestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetUpCrashTestRequest.Merge(m, src)
}
func (m *SetUpCrashTestRequest) XXX_Size() int {
	return xxx_messageInfo_SetUpCrashTestRequest.Size(m)
}
func (m *SetUpCrashTestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetUpCrashTestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetUpCrashTestRequest proto.InternalMessageInfo

func (m *SetUpCrashTestRequest) GetConsent() SetUpCrashTestRequest_ConsentType {
	if m != nil {
		return m.Consent
	}
	return SetUpCrashTestRequest_MOCK_CONSENT
}

type EnableCrashFilterRequest struct {
	// Name of the program to be handled by crash_reporter.
	// There are two special cases:
	// An empty string means all crashes should be handled. Equivalent to DisableCrashFilter.
	// A string "none" means no crashes should be handled at all regardless of process name.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnableCrashFilterRequest) Reset()         { *m = EnableCrashFilterRequest{} }
func (m *EnableCrashFilterRequest) String() string { return proto.CompactTextString(m) }
func (*EnableCrashFilterRequest) ProtoMessage()    {}
func (*EnableCrashFilterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b51ac24a74eb33d, []int{1}
}

func (m *EnableCrashFilterRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnableCrashFilterRequest.Unmarshal(m, b)
}
func (m *EnableCrashFilterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnableCrashFilterRequest.Marshal(b, m, deterministic)
}
func (m *EnableCrashFilterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableCrashFilterRequest.Merge(m, src)
}
func (m *EnableCrashFilterRequest) XXX_Size() int {
	return xxx_messageInfo_EnableCrashFilterRequest.Size(m)
}
func (m *EnableCrashFilterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableCrashFilterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EnableCrashFilterRequest proto.InternalMessageInfo

func (m *EnableCrashFilterRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// This deliberately does NOT use the "oldFiles" parameter in WaitForCrashFiles
// because that is redundant with SetUp's function of moving crashes to a
// temporary stash directory (and will eventually be removed).
type WaitForCrashFilesRequest struct {
	Dirs                 []string `protobuf:"bytes,1,rep,name=dirs,proto3" json:"dirs,omitempty"`
	Regexes              []string `protobuf:"bytes,2,rep,name=regexes,proto3" json:"regexes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WaitForCrashFilesRequest) Reset()         { *m = WaitForCrashFilesRequest{} }
func (m *WaitForCrashFilesRequest) String() string { return proto.CompactTextString(m) }
func (*WaitForCrashFilesRequest) ProtoMessage()    {}
func (*WaitForCrashFilesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b51ac24a74eb33d, []int{2}
}

func (m *WaitForCrashFilesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WaitForCrashFilesRequest.Unmarshal(m, b)
}
func (m *WaitForCrashFilesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WaitForCrashFilesRequest.Marshal(b, m, deterministic)
}
func (m *WaitForCrashFilesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WaitForCrashFilesRequest.Merge(m, src)
}
func (m *WaitForCrashFilesRequest) XXX_Size() int {
	return xxx_messageInfo_WaitForCrashFilesRequest.Size(m)
}
func (m *WaitForCrashFilesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WaitForCrashFilesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WaitForCrashFilesRequest proto.InternalMessageInfo

func (m *WaitForCrashFilesRequest) GetDirs() []string {
	if m != nil {
		return m.Dirs
	}
	return nil
}

func (m *WaitForCrashFilesRequest) GetRegexes() []string {
	if m != nil {
		return m.Regexes
	}
	return nil
}

type WaitForCrashFilesResponse struct {
	Matches              []*RegexMatch `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *WaitForCrashFilesResponse) Reset()         { *m = WaitForCrashFilesResponse{} }
func (m *WaitForCrashFilesResponse) String() string { return proto.CompactTextString(m) }
func (*WaitForCrashFilesResponse) ProtoMessage()    {}
func (*WaitForCrashFilesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b51ac24a74eb33d, []int{3}
}

func (m *WaitForCrashFilesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WaitForCrashFilesResponse.Unmarshal(m, b)
}
func (m *WaitForCrashFilesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WaitForCrashFilesResponse.Marshal(b, m, deterministic)
}
func (m *WaitForCrashFilesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WaitForCrashFilesResponse.Merge(m, src)
}
func (m *WaitForCrashFilesResponse) XXX_Size() int {
	return xxx_messageInfo_WaitForCrashFilesResponse.Size(m)
}
func (m *WaitForCrashFilesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WaitForCrashFilesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WaitForCrashFilesResponse proto.InternalMessageInfo

func (m *WaitForCrashFilesResponse) GetMatches() []*RegexMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

type RemoveAllFilesRequest struct {
	Matches              []*RegexMatch `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RemoveAllFilesRequest) Reset()         { *m = RemoveAllFilesRequest{} }
func (m *RemoveAllFilesRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveAllFilesRequest) ProtoMessage()    {}
func (*RemoveAllFilesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b51ac24a74eb33d, []int{4}
}

func (m *RemoveAllFilesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoveAllFilesRequest.Unmarshal(m, b)
}
func (m *RemoveAllFilesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoveAllFilesRequest.Marshal(b, m, deterministic)
}
func (m *RemoveAllFilesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveAllFilesRequest.Merge(m, src)
}
func (m *RemoveAllFilesRequest) XXX_Size() int {
	return xxx_messageInfo_RemoveAllFilesRequest.Size(m)
}
func (m *RemoveAllFilesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveAllFilesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveAllFilesRequest proto.InternalMessageInfo

func (m *RemoveAllFilesRequest) GetMatches() []*RegexMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

type RegexMatch struct {
	Regex                string   `protobuf:"bytes,1,opt,name=regex,proto3" json:"regex,omitempty"`
	Files                []string `protobuf:"bytes,2,rep,name=files,proto3" json:"files,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegexMatch) Reset()         { *m = RegexMatch{} }
func (m *RegexMatch) String() string { return proto.CompactTextString(m) }
func (*RegexMatch) ProtoMessage()    {}
func (*RegexMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b51ac24a74eb33d, []int{5}
}

func (m *RegexMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegexMatch.Unmarshal(m, b)
}
func (m *RegexMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegexMatch.Marshal(b, m, deterministic)
}
func (m *RegexMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegexMatch.Merge(m, src)
}
func (m *RegexMatch) XXX_Size() int {
	return xxx_messageInfo_RegexMatch.Size(m)
}
func (m *RegexMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RegexMatch.DiscardUnknown(m)
}

var xxx_messageInfo_RegexMatch proto.InternalMessageInfo

func (m *RegexMatch) GetRegex() string {
	if m != nil {
		return m.Regex
	}
	return ""
}

func (m *RegexMatch) GetFiles() []string {
	if m != nil {
		return m.Files
	}
	return nil
}

func init() {
	proto.RegisterEnum("tast.cros.crash.SetUpCrashTestRequest_ConsentType", SetUpCrashTestRequest_ConsentType_name, SetUpCrashTestRequest_ConsentType_value)
	proto.RegisterType((*SetUpCrashTestRequest)(nil), "tast.cros.crash.SetUpCrashTestRequest")
	proto.RegisterType((*EnableCrashFilterRequest)(nil), "tast.cros.crash.EnableCrashFilterRequest")
	proto.RegisterType((*WaitForCrashFilesRequest)(nil), "tast.cros.crash.WaitForCrashFilesRequest")
	proto.RegisterType((*WaitForCrashFilesResponse)(nil), "tast.cros.crash.WaitForCrashFilesResponse")
	proto.RegisterType((*RemoveAllFilesRequest)(nil), "tast.cros.crash.RemoveAllFilesRequest")
	proto.RegisterType((*RegexMatch)(nil), "tast.cros.crash.RegexMatch")
}

func init() { proto.RegisterFile("fixture_service.proto", fileDescriptor_4b51ac24a74eb33d) }

var fileDescriptor_4b51ac24a74eb33d = []byte{
	// 461 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xd1, 0x6e, 0xd3, 0x30,
	0x14, 0x6d, 0x18, 0xa3, 0x70, 0x87, 0xca, 0x66, 0x51, 0x14, 0xba, 0x97, 0xc9, 0x08, 0x04, 0x3c,
	0x38, 0xa2, 0x08, 0x89, 0x07, 0x5e, 0x46, 0xd7, 0x0a, 0xc4, 0xd6, 0x49, 0x6e, 0x10, 0x88, 0x97,
	0x29, 0x0d, 0xb7, 0x6d, 0xa4, 0x24, 0x0e, 0xb6, 0x33, 0xb6, 0x3f, 0xe1, 0x67, 0x91, 0x90, 0xed,
	0x06, 0xb6, 0x25, 0xad, 0xc6, 0xde, 0xec, 0x9b, 0x73, 0x8f, 0xcf, 0xbd, 0xe7, 0x28, 0xd0, 0x9d,
	0x25, 0x67, 0xba, 0x94, 0x78, 0xa2, 0x50, 0x9e, 0x26, 0x31, 0xb2, 0x42, 0x0a, 0x2d, 0xc8, 0x03,
	0x1d, 0x29, 0xcd, 0x62, 0x29, 0x14, 0x8b, 0x65, 0xa4, 0x16, 0xbd, 0xdd, 0xb9, 0x10, 0xf3, 0x14,
	0x03, 0xfb, 0x79, 0x5a, 0xce, 0x02, 0xcc, 0x0a, 0x7d, 0xee, 0xd0, 0xf4, 0x97, 0x07, 0xdd, 0x09,
	0xea, 0xcf, 0xc5, 0xc0, 0x60, 0x43, 0x54, 0x9a, 0xe3, 0x8f, 0x12, 0x95, 0x26, 0x87, 0xd0, 0x8e,
	0x45, 0xae, 0x30, 0xd7, 0xbe, 0xb7, 0xe7, 0x3d, 0xef, 0xf4, 0xfb, 0xec, 0x0a, 0x33, 0x6b, 0x6c,
	0x64, 0x03, 0xd7, 0x15, 0x9e, 0x17, 0xc8, 0x2b, 0x0a, 0xfa, 0x0a, 0xb6, 0x2e, 0xd4, 0xc9, 0x36,
	0xdc, 0x3f, 0x3a, 0x1e, 0x7c, 0x3a, 0x19, 0x1c, 0x8f, 0x27, 0xc3, 0x71, 0xb8, 0xdd, 0x32, 0x15,
	0x3e, 0xdc, 0x3f, 0xfc, 0x5b, 0xf1, 0x28, 0x03, 0x7f, 0x98, 0x47, 0xd3, 0x14, 0xed, 0x0b, 0xa3,
	0x24, 0xd5, 0x28, 0x2b, 0x71, 0x04, 0x6e, 0xe7, 0x51, 0x86, 0x56, 0xd9, 0x3d, 0x6e, 0xcf, 0xf4,
	0x03, 0xf8, 0x5f, 0xa2, 0x44, 0x8f, 0x84, 0xac, 0x1a, 0x50, 0x5d, 0xc0, 0x7f, 0x4f, 0xa4, 0xf2,
	0xbd, 0xbd, 0x0d, 0x83, 0x37, 0x67, 0xe2, 0x43, 0x5b, 0xe2, 0x1c, 0xcf, 0x50, 0xf9, 0xb7, 0x6c,
	0xb9, 0xba, 0x52, 0x0e, 0x8f, 0x1b, 0x98, 0x54, 0x61, 0x06, 0x20, 0x6f, 0xa0, 0x9d, 0x45, 0x3a,
	0x5e, 0xa0, 0x63, 0xdb, 0xea, 0xef, 0xd6, 0xf6, 0xc2, 0x0d, 0xcf, 0x91, 0x01, 0xf1, 0x0a, 0x4b,
	0xc7, 0xd0, 0xe5, 0x98, 0x89, 0x53, 0xdc, 0x4f, 0xd3, 0x4b, 0xd2, 0x6e, 0xc8, 0xf7, 0x16, 0xe0,
	0x5f, 0x99, 0x3c, 0x84, 0x4d, 0x2b, 0x7e, 0xb9, 0x10, 0x77, 0x31, 0xd5, 0x99, 0x79, 0x6a, 0x39,
	0x9f, 0xbb, 0xf4, 0x7f, 0x6f, 0x40, 0x67, 0xe4, 0xa2, 0x33, 0x71, 0xc9, 0x21, 0x1f, 0x61, 0xd3,
	0x7a, 0x49, 0x9e, 0x5d, 0xcf, 0xe3, 0xde, 0x23, 0xe6, 0x42, 0xc5, 0xaa, 0x50, 0xb1, 0xa1, 0x09,
	0x15, 0x6d, 0x91, 0xaf, 0xb0, 0x53, 0x73, 0x8d, 0xbc, 0xa8, 0xd1, 0xae, 0x72, 0x76, 0x0d, 0xf3,
	0x08, 0xc8, 0x41, 0xa2, 0xae, 0x52, 0xaf, 0xc0, 0xaf, 0xe1, 0x49, 0x61, 0xa7, 0xe6, 0x6e, 0x83,
	0xc2, 0x55, 0x59, 0xea, 0xbd, 0xbc, 0x0e, 0xd4, 0x85, 0x85, 0xb6, 0x08, 0x87, 0xce, 0x65, 0xdf,
	0x1b, 0x76, 0xdc, 0x18, 0x8c, 0x35, 0x13, 0xbc, 0x83, 0xbb, 0x21, 0x46, 0xf2, 0x40, 0xfc, 0xcc,
	0xff, 0x7f, 0xfe, 0xf7, 0x4f, 0xbf, 0x3d, 0x89, 0x17, 0x52, 0x64, 0x49, 0x99, 0x09, 0x15, 0x18,
	0x2d, 0xc1, 0xf2, 0x0f, 0xa2, 0x02, 0x23, 0x2a, 0xb0, 0xa2, 0xa6, 0x77, 0x6c, 0xe3, 0xeb, 0x3f,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x80, 0x1f, 0x23, 0x9f, 0x67, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FixtureServiceClient is the client API for FixtureService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FixtureServiceClient interface {
	// SetUp sets up the DUT for a crash test.
	// For more details on what, precisely, it does, see documentation for
	// "SetUpCrashTest" in the local/crash tast library.
	// *NOTE*: If the DUT reboots during the test, it will clear
	// crash_test_in_progress state.
	// After the test is complete, you must call TearDown to clean up the
	// associated resources.
	SetUp(ctx context.Context, in *SetUpCrashTestRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// EnableCrashFilter sets crash_reporter filter by process name.
	EnableCrashFilter(ctx context.Context, in *EnableCrashFilterRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// DisableCrashFilter disables crash_reporter filter.
	DisableCrashFilter(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// WaitForCrashFiles waits for the specified crash files to be present.
	// See crash.go's WaitForCrashFiles for interface details.
	WaitForCrashFiles(ctx context.Context, in *WaitForCrashFilesRequest, opts ...grpc.CallOption) (*WaitForCrashFilesResponse, error)
	// RemoveAllFiles removes all files in the request.
	RemoveAllFiles(ctx context.Context, in *RemoveAllFilesRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// TearDown undoes the actions SetUp does and resets the machine to normal
	// state.
	TearDown(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
}

type fixtureServiceClient struct {
	cc *grpc.ClientConn
}

func NewFixtureServiceClient(cc *grpc.ClientConn) FixtureServiceClient {
	return &fixtureServiceClient{cc}
}

func (c *fixtureServiceClient) SetUp(ctx context.Context, in *SetUpCrashTestRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.crash.FixtureService/SetUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fixtureServiceClient) EnableCrashFilter(ctx context.Context, in *EnableCrashFilterRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.crash.FixtureService/EnableCrashFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fixtureServiceClient) DisableCrashFilter(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.crash.FixtureService/DisableCrashFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fixtureServiceClient) WaitForCrashFiles(ctx context.Context, in *WaitForCrashFilesRequest, opts ...grpc.CallOption) (*WaitForCrashFilesResponse, error) {
	out := new(WaitForCrashFilesResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.crash.FixtureService/WaitForCrashFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fixtureServiceClient) RemoveAllFiles(ctx context.Context, in *RemoveAllFilesRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.crash.FixtureService/RemoveAllFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fixtureServiceClient) TearDown(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.crash.FixtureService/TearDown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FixtureServiceServer is the server API for FixtureService service.
type FixtureServiceServer interface {
	// SetUp sets up the DUT for a crash test.
	// For more details on what, precisely, it does, see documentation for
	// "SetUpCrashTest" in the local/crash tast library.
	// *NOTE*: If the DUT reboots during the test, it will clear
	// crash_test_in_progress state.
	// After the test is complete, you must call TearDown to clean up the
	// associated resources.
	SetUp(context.Context, *SetUpCrashTestRequest) (*empty.Empty, error)
	// EnableCrashFilter sets crash_reporter filter by process name.
	EnableCrashFilter(context.Context, *EnableCrashFilterRequest) (*empty.Empty, error)
	// DisableCrashFilter disables crash_reporter filter.
	DisableCrashFilter(context.Context, *empty.Empty) (*empty.Empty, error)
	// WaitForCrashFiles waits for the specified crash files to be present.
	// See crash.go's WaitForCrashFiles for interface details.
	WaitForCrashFiles(context.Context, *WaitForCrashFilesRequest) (*WaitForCrashFilesResponse, error)
	// RemoveAllFiles removes all files in the request.
	RemoveAllFiles(context.Context, *RemoveAllFilesRequest) (*empty.Empty, error)
	// TearDown undoes the actions SetUp does and resets the machine to normal
	// state.
	TearDown(context.Context, *empty.Empty) (*empty.Empty, error)
}

// UnimplementedFixtureServiceServer can be embedded to have forward compatible implementations.
type UnimplementedFixtureServiceServer struct {
}

func (*UnimplementedFixtureServiceServer) SetUp(ctx context.Context, req *SetUpCrashTestRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUp not implemented")
}
func (*UnimplementedFixtureServiceServer) EnableCrashFilter(ctx context.Context, req *EnableCrashFilterRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableCrashFilter not implemented")
}
func (*UnimplementedFixtureServiceServer) DisableCrashFilter(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableCrashFilter not implemented")
}
func (*UnimplementedFixtureServiceServer) WaitForCrashFiles(ctx context.Context, req *WaitForCrashFilesRequest) (*WaitForCrashFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForCrashFiles not implemented")
}
func (*UnimplementedFixtureServiceServer) RemoveAllFiles(ctx context.Context, req *RemoveAllFilesRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAllFiles not implemented")
}
func (*UnimplementedFixtureServiceServer) TearDown(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TearDown not implemented")
}

func RegisterFixtureServiceServer(s *grpc.Server, srv FixtureServiceServer) {
	s.RegisterService(&_FixtureService_serviceDesc, srv)
}

func _FixtureService_SetUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUpCrashTestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FixtureServiceServer).SetUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.crash.FixtureService/SetUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FixtureServiceServer).SetUp(ctx, req.(*SetUpCrashTestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FixtureService_EnableCrashFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableCrashFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FixtureServiceServer).EnableCrashFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.crash.FixtureService/EnableCrashFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FixtureServiceServer).EnableCrashFilter(ctx, req.(*EnableCrashFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FixtureService_DisableCrashFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FixtureServiceServer).DisableCrashFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.crash.FixtureService/DisableCrashFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FixtureServiceServer).DisableCrashFilter(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _FixtureService_WaitForCrashFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitForCrashFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FixtureServiceServer).WaitForCrashFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.crash.FixtureService/WaitForCrashFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FixtureServiceServer).WaitForCrashFiles(ctx, req.(*WaitForCrashFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FixtureService_RemoveAllFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveAllFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FixtureServiceServer).RemoveAllFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.crash.FixtureService/RemoveAllFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FixtureServiceServer).RemoveAllFiles(ctx, req.(*RemoveAllFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FixtureService_TearDown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FixtureServiceServer).TearDown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.crash.FixtureService/TearDown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FixtureServiceServer).TearDown(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _FixtureService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.cros.crash.FixtureService",
	HandlerType: (*FixtureServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetUp",
			Handler:    _FixtureService_SetUp_Handler,
		},
		{
			MethodName: "EnableCrashFilter",
			Handler:    _FixtureService_EnableCrashFilter_Handler,
		},
		{
			MethodName: "DisableCrashFilter",
			Handler:    _FixtureService_DisableCrashFilter_Handler,
		},
		{
			MethodName: "WaitForCrashFiles",
			Handler:    _FixtureService_WaitForCrashFiles_Handler,
		},
		{
			MethodName: "RemoveAllFiles",
			Handler:    _FixtureService_RemoveAllFiles_Handler,
		},
		{
			MethodName: "TearDown",
			Handler:    _FixtureService_TearDown_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fixture_service.proto",
}
