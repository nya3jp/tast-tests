// Code generated by protoc-gen-go. DO NOT EDIT.
// source: boot_lockbox_service.proto

package security

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ReadBootLockboxRequest struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadBootLockboxRequest) Reset()         { *m = ReadBootLockboxRequest{} }
func (m *ReadBootLockboxRequest) String() string { return proto.CompactTextString(m) }
func (*ReadBootLockboxRequest) ProtoMessage()    {}
func (*ReadBootLockboxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c1fd4f38c1ac2f6, []int{0}
}

func (m *ReadBootLockboxRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadBootLockboxRequest.Unmarshal(m, b)
}
func (m *ReadBootLockboxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadBootLockboxRequest.Marshal(b, m, deterministic)
}
func (m *ReadBootLockboxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadBootLockboxRequest.Merge(m, src)
}
func (m *ReadBootLockboxRequest) XXX_Size() int {
	return xxx_messageInfo_ReadBootLockboxRequest.Size(m)
}
func (m *ReadBootLockboxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadBootLockboxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadBootLockboxRequest proto.InternalMessageInfo

func (m *ReadBootLockboxRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type ReadBootLockboxResponse struct {
	Value                []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadBootLockboxResponse) Reset()         { *m = ReadBootLockboxResponse{} }
func (m *ReadBootLockboxResponse) String() string { return proto.CompactTextString(m) }
func (*ReadBootLockboxResponse) ProtoMessage()    {}
func (*ReadBootLockboxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c1fd4f38c1ac2f6, []int{1}
}

func (m *ReadBootLockboxResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadBootLockboxResponse.Unmarshal(m, b)
}
func (m *ReadBootLockboxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadBootLockboxResponse.Marshal(b, m, deterministic)
}
func (m *ReadBootLockboxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadBootLockboxResponse.Merge(m, src)
}
func (m *ReadBootLockboxResponse) XXX_Size() int {
	return xxx_messageInfo_ReadBootLockboxResponse.Size(m)
}
func (m *ReadBootLockboxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadBootLockboxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadBootLockboxResponse proto.InternalMessageInfo

func (m *ReadBootLockboxResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type StoreBootLockboxRequest struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoreBootLockboxRequest) Reset()         { *m = StoreBootLockboxRequest{} }
func (m *StoreBootLockboxRequest) String() string { return proto.CompactTextString(m) }
func (*StoreBootLockboxRequest) ProtoMessage()    {}
func (*StoreBootLockboxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c1fd4f38c1ac2f6, []int{2}
}

func (m *StoreBootLockboxRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StoreBootLockboxRequest.Unmarshal(m, b)
}
func (m *StoreBootLockboxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StoreBootLockboxRequest.Marshal(b, m, deterministic)
}
func (m *StoreBootLockboxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreBootLockboxRequest.Merge(m, src)
}
func (m *StoreBootLockboxRequest) XXX_Size() int {
	return xxx_messageInfo_StoreBootLockboxRequest.Size(m)
}
func (m *StoreBootLockboxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreBootLockboxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StoreBootLockboxRequest proto.InternalMessageInfo

func (m *StoreBootLockboxRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StoreBootLockboxRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*ReadBootLockboxRequest)(nil), "tast.cros.security.ReadBootLockboxRequest")
	proto.RegisterType((*ReadBootLockboxResponse)(nil), "tast.cros.security.ReadBootLockboxResponse")
	proto.RegisterType((*StoreBootLockboxRequest)(nil), "tast.cros.security.StoreBootLockboxRequest")
}

func init() { proto.RegisterFile("boot_lockbox_service.proto", fileDescriptor_8c1fd4f38c1ac2f6) }

var fileDescriptor_8c1fd4f38c1ac2f6 = []byte{
	// 293 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0xc1, 0x4a, 0xf3, 0x40,
	0x14, 0x85, 0xdb, 0xfe, 0x7f, 0x05, 0xaf, 0x22, 0x72, 0x91, 0x56, 0xe2, 0x46, 0xb2, 0x90, 0x52,
	0x61, 0x06, 0xf4, 0x01, 0xc4, 0x14, 0x77, 0xa5, 0x8b, 0x74, 0xe7, 0xa6, 0x24, 0xf1, 0x1a, 0x43,
	0x93, 0xde, 0x38, 0x33, 0xa9, 0xe6, 0x1d, 0x7d, 0x28, 0x99, 0x8c, 0xc5, 0x42, 0x1b, 0x28, 0xee,
	0x92, 0xe1, 0x9c, 0x8f, 0x39, 0x1f, 0x03, 0x5e, 0xcc, 0x6c, 0x16, 0x39, 0x27, 0xcb, 0x98, 0x3f,
	0x17, 0x9a, 0xd4, 0x3a, 0x4b, 0x48, 0x94, 0x8a, 0x0d, 0x23, 0x9a, 0x48, 0x1b, 0x91, 0x28, 0xd6,
	0x42, 0x53, 0x52, 0xa9, 0xcc, 0xd4, 0xde, 0x55, 0xca, 0x9c, 0xe6, 0x24, 0x9b, 0x44, 0x5c, 0xbd,
	0x4a, 0x2a, 0x4a, 0x53, 0xbb, 0x82, 0x3f, 0x86, 0x41, 0x48, 0xd1, 0x4b, 0xc0, 0x6c, 0xa6, 0x8e,
	0x18, 0xd2, 0x7b, 0x45, 0xda, 0xe0, 0x39, 0xfc, 0x5b, 0x52, 0x7d, 0xd9, 0xbd, 0xee, 0x8e, 0x8e,
	0x43, 0xfb, 0xe9, 0x4b, 0x18, 0xee, 0x64, 0x75, 0xc9, 0x2b, 0x4d, 0x78, 0x01, 0xfd, 0x75, 0x94,
	0x57, 0xd4, 0xc4, 0x4f, 0x43, 0xf7, 0xe3, 0x3f, 0xc2, 0x70, 0x6e, 0x58, 0xd1, 0x21, 0xf4, 0x5f,
	0x44, 0x6f, 0x0b, 0x71, 0xf7, 0xd5, 0x03, 0xdc, 0xaa, 0xcf, 0xdd, 0x5a, 0x0c, 0xe0, 0x6c, 0x46,
	0x1f, 0x93, 0x37, 0xc5, 0x05, 0x4d, 0x39, 0xcd, 0x56, 0x38, 0x10, 0x6e, 0xa6, 0xd8, 0xcc, 0x14,
	0x4f, 0x76, 0xa6, 0xd7, 0x72, 0xee, 0x77, 0xf0, 0x01, 0x4e, 0x26, 0x39, 0x6b, 0x72, 0x94, 0x3f,
	0x00, 0x22, 0xf8, 0x6f, 0x7d, 0xe0, 0x58, 0xec, 0x5a, 0x17, 0xfb, 0xad, 0x7a, 0xb7, 0x07, 0x65,
	0x9d, 0x55, 0xbf, 0x83, 0x33, 0xe8, 0x37, 0x06, 0x71, 0x6f, 0xaf, 0x45, 0x6e, 0xfb, 0x95, 0x83,
	0xd1, 0xf3, 0x4d, 0x62, 0xe7, 0x66, 0x55, 0xc1, 0x5a, 0x5a, 0xa4, 0xfc, 0x79, 0x40, 0x5a, 0x5a,
	0xb6, 0xdc, 0xb0, 0xe3, 0xa3, 0xa6, 0x7b, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0xa7, 0x86, 0xb6,
	0x3f, 0x6e, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BootLockboxServiceClient is the client API for BootLockboxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BootLockboxServiceClient interface {
	// New logs into a Chrome session as a fake user. Close must be called later
	// to clean up the associated resources.
	NewChromeLogin(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Close releases the resources obtained by New.
	CloseChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Reads a value from Boot Lockbox.
	Read(ctx context.Context, in *ReadBootLockboxRequest, opts ...grpc.CallOption) (*ReadBootLockboxResponse, error)
	// Stores a value to Boot Lockbox.
	Store(ctx context.Context, in *StoreBootLockboxRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type bootLockboxServiceClient struct {
	cc *grpc.ClientConn
}

func NewBootLockboxServiceClient(cc *grpc.ClientConn) BootLockboxServiceClient {
	return &bootLockboxServiceClient{cc}
}

func (c *bootLockboxServiceClient) NewChromeLogin(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.security.BootLockboxService/NewChromeLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bootLockboxServiceClient) CloseChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.security.BootLockboxService/CloseChrome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bootLockboxServiceClient) Read(ctx context.Context, in *ReadBootLockboxRequest, opts ...grpc.CallOption) (*ReadBootLockboxResponse, error) {
	out := new(ReadBootLockboxResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.security.BootLockboxService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bootLockboxServiceClient) Store(ctx context.Context, in *StoreBootLockboxRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.security.BootLockboxService/Store", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BootLockboxServiceServer is the server API for BootLockboxService service.
type BootLockboxServiceServer interface {
	// New logs into a Chrome session as a fake user. Close must be called later
	// to clean up the associated resources.
	NewChromeLogin(context.Context, *empty.Empty) (*empty.Empty, error)
	// Close releases the resources obtained by New.
	CloseChrome(context.Context, *empty.Empty) (*empty.Empty, error)
	// Reads a value from Boot Lockbox.
	Read(context.Context, *ReadBootLockboxRequest) (*ReadBootLockboxResponse, error)
	// Stores a value to Boot Lockbox.
	Store(context.Context, *StoreBootLockboxRequest) (*empty.Empty, error)
}

// UnimplementedBootLockboxServiceServer can be embedded to have forward compatible implementations.
type UnimplementedBootLockboxServiceServer struct {
}

func (*UnimplementedBootLockboxServiceServer) NewChromeLogin(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewChromeLogin not implemented")
}
func (*UnimplementedBootLockboxServiceServer) CloseChrome(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseChrome not implemented")
}
func (*UnimplementedBootLockboxServiceServer) Read(ctx context.Context, req *ReadBootLockboxRequest) (*ReadBootLockboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedBootLockboxServiceServer) Store(ctx context.Context, req *StoreBootLockboxRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Store not implemented")
}

func RegisterBootLockboxServiceServer(s *grpc.Server, srv BootLockboxServiceServer) {
	s.RegisterService(&_BootLockboxService_serviceDesc, srv)
}

func _BootLockboxService_NewChromeLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootLockboxServiceServer).NewChromeLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.security.BootLockboxService/NewChromeLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootLockboxServiceServer).NewChromeLogin(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BootLockboxService_CloseChrome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootLockboxServiceServer).CloseChrome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.security.BootLockboxService/CloseChrome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootLockboxServiceServer).CloseChrome(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BootLockboxService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadBootLockboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootLockboxServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.security.BootLockboxService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootLockboxServiceServer).Read(ctx, req.(*ReadBootLockboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BootLockboxService_Store_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreBootLockboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BootLockboxServiceServer).Store(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.security.BootLockboxService/Store",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BootLockboxServiceServer).Store(ctx, req.(*StoreBootLockboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BootLockboxService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.cros.security.BootLockboxService",
	HandlerType: (*BootLockboxServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewChromeLogin",
			Handler:    _BootLockboxService_NewChromeLogin_Handler,
		},
		{
			MethodName: "CloseChrome",
			Handler:    _BootLockboxService_CloseChrome_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _BootLockboxService_Read_Handler,
		},
		{
			MethodName: "Store",
			Handler:    _BootLockboxService_Store_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "boot_lockbox_service.proto",
}
