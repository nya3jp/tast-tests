// Code generated by protoc-gen-go. DO NOT EDIT.
// source: check_power_menu_service.proto

package ui

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type NewChromeRequest struct {
	// If login is false, a session starts without logging in.
	Login bool `protobuf:"varint,1,opt,name=login,proto3" json:"login,omitempty"`
	// If non-empty, the key is used to load sign-in profile extension.
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewChromeRequest) Reset()         { *m = NewChromeRequest{} }
func (m *NewChromeRequest) String() string { return proto.CompactTextString(m) }
func (*NewChromeRequest) ProtoMessage()    {}
func (*NewChromeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebbff8af15c62e49, []int{0}
}

func (m *NewChromeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewChromeRequest.Unmarshal(m, b)
}
func (m *NewChromeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewChromeRequest.Marshal(b, m, deterministic)
}
func (m *NewChromeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewChromeRequest.Merge(m, src)
}
func (m *NewChromeRequest) XXX_Size() int {
	return xxx_messageInfo_NewChromeRequest.Size(m)
}
func (m *NewChromeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NewChromeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NewChromeRequest proto.InternalMessageInfo

func (m *NewChromeRequest) GetLogin() bool {
	if m != nil {
		return m.Login
	}
	return false
}

func (m *NewChromeRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type IsPowerMenuPresentResponse struct {
	IsMenuPresent        bool     `protobuf:"varint,1,opt,name=is_menu_present,json=isMenuPresent,proto3" json:"is_menu_present,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IsPowerMenuPresentResponse) Reset()         { *m = IsPowerMenuPresentResponse{} }
func (m *IsPowerMenuPresentResponse) String() string { return proto.CompactTextString(m) }
func (*IsPowerMenuPresentResponse) ProtoMessage()    {}
func (*IsPowerMenuPresentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebbff8af15c62e49, []int{1}
}

func (m *IsPowerMenuPresentResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IsPowerMenuPresentResponse.Unmarshal(m, b)
}
func (m *IsPowerMenuPresentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IsPowerMenuPresentResponse.Marshal(b, m, deterministic)
}
func (m *IsPowerMenuPresentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsPowerMenuPresentResponse.Merge(m, src)
}
func (m *IsPowerMenuPresentResponse) XXX_Size() int {
	return xxx_messageInfo_IsPowerMenuPresentResponse.Size(m)
}
func (m *IsPowerMenuPresentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IsPowerMenuPresentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IsPowerMenuPresentResponse proto.InternalMessageInfo

func (m *IsPowerMenuPresentResponse) GetIsMenuPresent() bool {
	if m != nil {
		return m.IsMenuPresent
	}
	return false
}

func init() {
	proto.RegisterType((*NewChromeRequest)(nil), "tast.cros.ui.NewChromeRequest")
	proto.RegisterType((*IsPowerMenuPresentResponse)(nil), "tast.cros.ui.IsPowerMenuPresentResponse")
}

func init() { proto.RegisterFile("check_power_menu_service.proto", fileDescriptor_ebbff8af15c62e49) }

var fileDescriptor_ebbff8af15c62e49 = []byte{
	// 283 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0x41, 0x4b, 0xc3, 0x30,
	0x14, 0x80, 0x57, 0x45, 0x71, 0x51, 0x71, 0x04, 0x91, 0x51, 0x61, 0x94, 0x1e, 0xa4, 0xa7, 0x04,
	0xf4, 0xe6, 0x45, 0x70, 0xee, 0xe0, 0x41, 0x19, 0xf5, 0x22, 0x5e, 0x8a, 0x2b, 0xcf, 0x2e, 0xac,
	0xed, 0xab, 0x79, 0x89, 0x63, 0xff, 0xdb, 0x1f, 0x20, 0x59, 0xea, 0x98, 0x4a, 0xbd, 0xb5, 0xbc,
	0x97, 0x8f, 0xef, 0x4b, 0xd8, 0x28, 0x9f, 0x43, 0xbe, 0xc8, 0x1a, 0x5c, 0x82, 0xce, 0x2a, 0xa8,
	0x6d, 0x46, 0xa0, 0x3f, 0x54, 0x0e, 0xa2, 0xd1, 0x68, 0x90, 0x1f, 0x99, 0x57, 0x32, 0x22, 0xd7,
	0x48, 0xc2, 0xaa, 0xf0, 0xbc, 0x40, 0x2c, 0x4a, 0x90, 0xeb, 0xd9, 0xcc, 0xbe, 0x49, 0xa8, 0x1a,
	0xb3, 0xf2, 0xab, 0xf1, 0x35, 0x1b, 0x3c, 0xc2, 0x72, 0x3c, 0xd7, 0x58, 0x41, 0x0a, 0xef, 0x16,
	0xc8, 0xf0, 0x53, 0xb6, 0x57, 0x62, 0xa1, 0xea, 0x61, 0x10, 0x05, 0xc9, 0x41, 0xea, 0x7f, 0xf8,
	0x80, 0xed, 0x2e, 0x60, 0x35, 0xdc, 0x89, 0x82, 0xa4, 0x9f, 0xba, 0xcf, 0xf8, 0x8e, 0x85, 0xf7,
	0x34, 0x75, 0x12, 0x0f, 0x50, 0xdb, 0xa9, 0x06, 0x82, 0xda, 0xa4, 0x40, 0x0d, 0xd6, 0x04, 0xfc,
	0x82, 0x9d, 0x28, 0xf2, 0x76, 0x8d, 0x1f, 0xb5, 0xbc, 0x63, 0x45, 0x5b, 0xfb, 0x97, 0x9f, 0x01,
	0x1b, 0x6c, 0x20, 0x4f, 0xbe, 0x83, 0x4f, 0x58, 0x7f, 0xa3, 0xc5, 0x47, 0x62, 0xbb, 0x47, 0xfc,
	0xf6, 0x0d, 0xcf, 0x84, 0x2f, 0x14, 0xdf, 0x85, 0x62, 0xe2, 0x0a, 0xe3, 0x1e, 0xbf, 0x61, 0x87,
	0xe3, 0x12, 0x09, 0x5a, 0x50, 0xc7, 0xe2, 0x3f, 0x80, 0x67, 0xc6, 0xff, 0x26, 0x76, 0x72, 0x92,
	0x9f, 0xa2, 0xdd, 0x97, 0x13, 0xf7, 0x6e, 0xe3, 0x97, 0x28, 0x77, 0x56, 0xca, 0x56, 0x48, 0xd2,
	0x9d, 0x93, 0xed, 0x23, 0x92, 0x74, 0x00, 0x69, 0xd5, 0x6c, 0x7f, 0xcd, 0xbf, 0xfa, 0x0a, 0x00,
	0x00, 0xff, 0xff, 0xeb, 0xca, 0x61, 0x1a, 0xf0, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PowerMenuServiceClient is the client API for PowerMenuService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PowerMenuServiceClient interface {
	// NewChrome starts a Chrome session and processes the sign-in request.
	// CloseChrome must be called later to clean up the associated resources.
	NewChrome(ctx context.Context, in *NewChromeRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Close releases the resources obtained by New.
	CloseChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// IsPowerMenuPresent returns a bool indicating the presence of the power menu.
	IsPowerMenuPresent(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsPowerMenuPresentResponse, error)
}

type powerMenuServiceClient struct {
	cc *grpc.ClientConn
}

func NewPowerMenuServiceClient(cc *grpc.ClientConn) PowerMenuServiceClient {
	return &powerMenuServiceClient{cc}
}

func (c *powerMenuServiceClient) NewChrome(ctx context.Context, in *NewChromeRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.ui.PowerMenuService/NewChrome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerMenuServiceClient) CloseChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.ui.PowerMenuService/CloseChrome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerMenuServiceClient) IsPowerMenuPresent(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsPowerMenuPresentResponse, error) {
	out := new(IsPowerMenuPresentResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.ui.PowerMenuService/IsPowerMenuPresent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PowerMenuServiceServer is the server API for PowerMenuService service.
type PowerMenuServiceServer interface {
	// NewChrome starts a Chrome session and processes the sign-in request.
	// CloseChrome must be called later to clean up the associated resources.
	NewChrome(context.Context, *NewChromeRequest) (*empty.Empty, error)
	// Close releases the resources obtained by New.
	CloseChrome(context.Context, *empty.Empty) (*empty.Empty, error)
	// IsPowerMenuPresent returns a bool indicating the presence of the power menu.
	IsPowerMenuPresent(context.Context, *empty.Empty) (*IsPowerMenuPresentResponse, error)
}

// UnimplementedPowerMenuServiceServer can be embedded to have forward compatible implementations.
type UnimplementedPowerMenuServiceServer struct {
}

func (*UnimplementedPowerMenuServiceServer) NewChrome(ctx context.Context, req *NewChromeRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewChrome not implemented")
}
func (*UnimplementedPowerMenuServiceServer) CloseChrome(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseChrome not implemented")
}
func (*UnimplementedPowerMenuServiceServer) IsPowerMenuPresent(ctx context.Context, req *empty.Empty) (*IsPowerMenuPresentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPowerMenuPresent not implemented")
}

func RegisterPowerMenuServiceServer(s *grpc.Server, srv PowerMenuServiceServer) {
	s.RegisterService(&_PowerMenuService_serviceDesc, srv)
}

func _PowerMenuService_NewChrome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewChromeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).NewChrome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.ui.PowerMenuService/NewChrome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).NewChrome(ctx, req.(*NewChromeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerMenuService_CloseChrome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).CloseChrome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.ui.PowerMenuService/CloseChrome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).CloseChrome(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerMenuService_IsPowerMenuPresent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).IsPowerMenuPresent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.ui.PowerMenuService/IsPowerMenuPresent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).IsPowerMenuPresent(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _PowerMenuService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.cros.ui.PowerMenuService",
	HandlerType: (*PowerMenuServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewChrome",
			Handler:    _PowerMenuService_NewChrome_Handler,
		},
		{
			MethodName: "CloseChrome",
			Handler:    _PowerMenuService_CloseChrome_Handler,
		},
		{
			MethodName: "IsPowerMenuPresent",
			Handler:    _PowerMenuService_IsPowerMenuPresent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "check_power_menu_service.proto",
}
