// Code generated by protoc-gen-go. DO NOT EDIT.
// source: check_power_menu_service.proto

package ui

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type NewChromeRequest struct {
	// If login is false, a session starts without logging in.
	Login bool `protobuf:"varint,1,opt,name=login,proto3" json:"login,omitempty"`
	// If non-empty, the key is used to load sign-in profile extension.
	// Namely, to show the login screen, but without logging in, login would
	// be set to false, and the key would be supplied with the
	// signinProfileTestExtensionManifestKey.
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewChromeRequest) Reset()         { *m = NewChromeRequest{} }
func (m *NewChromeRequest) String() string { return proto.CompactTextString(m) }
func (*NewChromeRequest) ProtoMessage()    {}
func (*NewChromeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebbff8af15c62e49, []int{0}
}

func (m *NewChromeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewChromeRequest.Unmarshal(m, b)
}
func (m *NewChromeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewChromeRequest.Marshal(b, m, deterministic)
}
func (m *NewChromeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewChromeRequest.Merge(m, src)
}
func (m *NewChromeRequest) XXX_Size() int {
	return xxx_messageInfo_NewChromeRequest.Size(m)
}
func (m *NewChromeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NewChromeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NewChromeRequest proto.InternalMessageInfo

func (m *NewChromeRequest) GetLogin() bool {
	if m != nil {
		return m.Login
	}
	return false
}

func (m *NewChromeRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type PowerMenuPresentResponse struct {
	IsMenuPresent        bool     `protobuf:"varint,1,opt,name=is_menu_present,json=isMenuPresent,proto3" json:"is_menu_present,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PowerMenuPresentResponse) Reset()         { *m = PowerMenuPresentResponse{} }
func (m *PowerMenuPresentResponse) String() string { return proto.CompactTextString(m) }
func (*PowerMenuPresentResponse) ProtoMessage()    {}
func (*PowerMenuPresentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ebbff8af15c62e49, []int{1}
}

func (m *PowerMenuPresentResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PowerMenuPresentResponse.Unmarshal(m, b)
}
func (m *PowerMenuPresentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PowerMenuPresentResponse.Marshal(b, m, deterministic)
}
func (m *PowerMenuPresentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PowerMenuPresentResponse.Merge(m, src)
}
func (m *PowerMenuPresentResponse) XXX_Size() int {
	return xxx_messageInfo_PowerMenuPresentResponse.Size(m)
}
func (m *PowerMenuPresentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PowerMenuPresentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PowerMenuPresentResponse proto.InternalMessageInfo

func (m *PowerMenuPresentResponse) GetIsMenuPresent() bool {
	if m != nil {
		return m.IsMenuPresent
	}
	return false
}

func init() {
	proto.RegisterType((*NewChromeRequest)(nil), "tast.cros.ui.NewChromeRequest")
	proto.RegisterType((*PowerMenuPresentResponse)(nil), "tast.cros.ui.PowerMenuPresentResponse")
}

func init() { proto.RegisterFile("check_power_menu_service.proto", fileDescriptor_ebbff8af15c62e49) }

var fileDescriptor_ebbff8af15c62e49 = []byte{
	// 283 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0xc1, 0x4b, 0xfb, 0x30,
	0x14, 0xc7, 0xd7, 0xdf, 0x0f, 0xc5, 0x45, 0xc5, 0x12, 0x44, 0xca, 0x84, 0x51, 0x7a, 0x18, 0x3b,
	0x25, 0xa0, 0x37, 0x2f, 0xc2, 0xc6, 0x8e, 0xca, 0xa8, 0x9e, 0xbc, 0x14, 0x57, 0x9e, 0x5d, 0x58,
	0xdb, 0x57, 0xf3, 0x12, 0xc7, 0xfe, 0x6b, 0xff, 0x04, 0xc9, 0x52, 0x47, 0x15, 0xea, 0x2d, 0xe1,
	0x7d, 0xdf, 0x87, 0xcf, 0x37, 0x61, 0xe3, 0x7c, 0x0d, 0xf9, 0x26, 0x6b, 0x70, 0x0b, 0x3a, 0xab,
	0xa0, 0xb6, 0x19, 0x81, 0xfe, 0x50, 0x39, 0x88, 0x46, 0xa3, 0x41, 0x7e, 0x66, 0x5e, 0xc9, 0x88,
	0x5c, 0x23, 0x09, 0xab, 0x46, 0xd7, 0x05, 0x62, 0x51, 0x82, 0xdc, 0xcf, 0x56, 0xf6, 0x4d, 0x42,
	0xd5, 0x98, 0x9d, 0x8f, 0x26, 0x77, 0x2c, 0x7c, 0x84, 0xed, 0x7c, 0xad, 0xb1, 0x82, 0x14, 0xde,
	0x2d, 0x90, 0xe1, 0x97, 0xec, 0xa8, 0xc4, 0x42, 0xd5, 0x51, 0x10, 0x07, 0xd3, 0x93, 0xd4, 0x5f,
	0x78, 0xc8, 0xfe, 0x6f, 0x60, 0x17, 0xfd, 0x8b, 0x83, 0xe9, 0x30, 0x75, 0xc7, 0x64, 0xc6, 0xa2,
	0xa5, 0x53, 0x78, 0x80, 0xda, 0x2e, 0x35, 0x10, 0xd4, 0x26, 0x05, 0x6a, 0xb0, 0x26, 0xe0, 0x13,
	0x76, 0xa1, 0xc8, 0xbb, 0x35, 0x7e, 0xd4, 0xd2, 0xce, 0x15, 0x75, 0xf2, 0x37, 0x9f, 0x01, 0x0b,
	0x0f, 0x90, 0x27, 0xdf, 0x82, 0x2f, 0xd8, 0xf0, 0x20, 0xc5, 0xc7, 0xa2, 0xdb, 0x46, 0xfc, 0xb6,
	0x1d, 0x5d, 0x09, 0xdf, 0x4f, 0x7c, 0xf7, 0x13, 0x0b, 0xd7, 0x2f, 0x19, 0xf0, 0x7b, 0x76, 0x3a,
	0x2f, 0x91, 0xa0, 0x05, 0xf5, 0x04, 0xff, 0x00, 0x3c, 0x77, 0xdc, 0x5a, 0xe1, 0x5e, 0xca, 0xe4,
	0xa7, 0x66, 0xdf, 0xc3, 0x24, 0x83, 0x59, 0xf2, 0x12, 0xe7, 0xce, 0x48, 0xd9, 0x0a, 0x49, 0xba,
	0x2d, 0xd9, 0x7e, 0x1f, 0x49, 0xb7, 0x2e, 0xad, 0x5a, 0x1d, 0xef, 0xe9, 0xb7, 0x5f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x98, 0xc2, 0xe3, 0x85, 0xea, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PowerMenuServiceClient is the client API for PowerMenuService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PowerMenuServiceClient interface {
	// NewChrome starts a Chrome session and processes the sign-in request.
	// CloseChrome must be called later to clean up the associated resources.
	NewChrome(ctx context.Context, in *NewChromeRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Close releases the resources obtained by NewChrome.
	CloseChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// PowerMenuPresent returns a bool to indicate whether the presence of a power menu
	// is true. Chrome instance is necessary prior to the deployment. Used in ECTabletMode,
	// PowerMenuPresent checks whether holding the power button for about one second would
	// bring up the power menu. Test cases that require manipulation of the power menu can
	// make use of this service.
	PowerMenuPresent(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PowerMenuPresentResponse, error)
}

type powerMenuServiceClient struct {
	cc *grpc.ClientConn
}

func NewPowerMenuServiceClient(cc *grpc.ClientConn) PowerMenuServiceClient {
	return &powerMenuServiceClient{cc}
}

func (c *powerMenuServiceClient) NewChrome(ctx context.Context, in *NewChromeRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.ui.PowerMenuService/NewChrome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerMenuServiceClient) CloseChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.ui.PowerMenuService/CloseChrome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *powerMenuServiceClient) PowerMenuPresent(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PowerMenuPresentResponse, error) {
	out := new(PowerMenuPresentResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.ui.PowerMenuService/PowerMenuPresent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PowerMenuServiceServer is the server API for PowerMenuService service.
type PowerMenuServiceServer interface {
	// NewChrome starts a Chrome session and processes the sign-in request.
	// CloseChrome must be called later to clean up the associated resources.
	NewChrome(context.Context, *NewChromeRequest) (*empty.Empty, error)
	// Close releases the resources obtained by NewChrome.
	CloseChrome(context.Context, *empty.Empty) (*empty.Empty, error)
	// PowerMenuPresent returns a bool to indicate whether the presence of a power menu
	// is true. Chrome instance is necessary prior to the deployment. Used in ECTabletMode,
	// PowerMenuPresent checks whether holding the power button for about one second would
	// bring up the power menu. Test cases that require manipulation of the power menu can
	// make use of this service.
	PowerMenuPresent(context.Context, *empty.Empty) (*PowerMenuPresentResponse, error)
}

// UnimplementedPowerMenuServiceServer can be embedded to have forward compatible implementations.
type UnimplementedPowerMenuServiceServer struct {
}

func (*UnimplementedPowerMenuServiceServer) NewChrome(ctx context.Context, req *NewChromeRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewChrome not implemented")
}
func (*UnimplementedPowerMenuServiceServer) CloseChrome(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseChrome not implemented")
}
func (*UnimplementedPowerMenuServiceServer) PowerMenuPresent(ctx context.Context, req *empty.Empty) (*PowerMenuPresentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PowerMenuPresent not implemented")
}

func RegisterPowerMenuServiceServer(s *grpc.Server, srv PowerMenuServiceServer) {
	s.RegisterService(&_PowerMenuService_serviceDesc, srv)
}

func _PowerMenuService_NewChrome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewChromeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).NewChrome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.ui.PowerMenuService/NewChrome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).NewChrome(ctx, req.(*NewChromeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerMenuService_CloseChrome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).CloseChrome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.ui.PowerMenuService/CloseChrome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).CloseChrome(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PowerMenuService_PowerMenuPresent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PowerMenuServiceServer).PowerMenuPresent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.ui.PowerMenuService/PowerMenuPresent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PowerMenuServiceServer).PowerMenuPresent(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _PowerMenuService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.cros.ui.PowerMenuService",
	HandlerType: (*PowerMenuServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewChrome",
			Handler:    _PowerMenuService_NewChrome_Handler,
		},
		{
			MethodName: "CloseChrome",
			Handler:    _PowerMenuService_CloseChrome_Handler,
		},
		{
			MethodName: "PowerMenuPresent",
			Handler:    _PowerMenuService_PowerMenuPresent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "check_power_menu_service.proto",
}
