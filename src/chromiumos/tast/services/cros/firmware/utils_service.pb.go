// Code generated by protoc-gen-go. DO NOT EDIT.
// source: utils_service.proto

package firmware

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// ReadServoKeyboardRequest listens the servo's keyboard emulator for a specified duration in seconds.
type ReadServoKeyboardRequest struct {
	Duration             uint32   `protobuf:"varint,1,opt,name=duration,proto3" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadServoKeyboardRequest) Reset()         { *m = ReadServoKeyboardRequest{} }
func (m *ReadServoKeyboardRequest) String() string { return proto.CompactTextString(m) }
func (*ReadServoKeyboardRequest) ProtoMessage()    {}
func (*ReadServoKeyboardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{0}
}

func (m *ReadServoKeyboardRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadServoKeyboardRequest.Unmarshal(m, b)
}
func (m *ReadServoKeyboardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadServoKeyboardRequest.Marshal(b, m, deterministic)
}
func (m *ReadServoKeyboardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadServoKeyboardRequest.Merge(m, src)
}
func (m *ReadServoKeyboardRequest) XXX_Size() int {
	return xxx_messageInfo_ReadServoKeyboardRequest.Size(m)
}
func (m *ReadServoKeyboardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadServoKeyboardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadServoKeyboardRequest proto.InternalMessageInfo

func (m *ReadServoKeyboardRequest) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// ReadServoKeyboardResponse provides what keys were pressed.
type ReadServoKeyboardResponse struct {
	Keys                 []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadServoKeyboardResponse) Reset()         { *m = ReadServoKeyboardResponse{} }
func (m *ReadServoKeyboardResponse) String() string { return proto.CompactTextString(m) }
func (*ReadServoKeyboardResponse) ProtoMessage()    {}
func (*ReadServoKeyboardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{1}
}

func (m *ReadServoKeyboardResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadServoKeyboardResponse.Unmarshal(m, b)
}
func (m *ReadServoKeyboardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadServoKeyboardResponse.Marshal(b, m, deterministic)
}
func (m *ReadServoKeyboardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadServoKeyboardResponse.Merge(m, src)
}
func (m *ReadServoKeyboardResponse) XXX_Size() int {
	return xxx_messageInfo_ReadServoKeyboardResponse.Size(m)
}
func (m *ReadServoKeyboardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadServoKeyboardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadServoKeyboardResponse proto.InternalMessageInfo

func (m *ReadServoKeyboardResponse) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

// FindPhysicalKeyboardResponse provides the path to /dev/input/event* for physical keyboard.
type FindPhysicalKeyboardResponse struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FindPhysicalKeyboardResponse) Reset()         { *m = FindPhysicalKeyboardResponse{} }
func (m *FindPhysicalKeyboardResponse) String() string { return proto.CompactTextString(m) }
func (*FindPhysicalKeyboardResponse) ProtoMessage()    {}
func (*FindPhysicalKeyboardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{2}
}

func (m *FindPhysicalKeyboardResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FindPhysicalKeyboardResponse.Unmarshal(m, b)
}
func (m *FindPhysicalKeyboardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FindPhysicalKeyboardResponse.Marshal(b, m, deterministic)
}
func (m *FindPhysicalKeyboardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindPhysicalKeyboardResponse.Merge(m, src)
}
func (m *FindPhysicalKeyboardResponse) XXX_Size() int {
	return xxx_messageInfo_FindPhysicalKeyboardResponse.Size(m)
}
func (m *FindPhysicalKeyboardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FindPhysicalKeyboardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FindPhysicalKeyboardResponse proto.InternalMessageInfo

func (m *FindPhysicalKeyboardResponse) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func init() {
	proto.RegisterType((*ReadServoKeyboardRequest)(nil), "tast.cros.firmware.ReadServoKeyboardRequest")
	proto.RegisterType((*ReadServoKeyboardResponse)(nil), "tast.cros.firmware.ReadServoKeyboardResponse")
	proto.RegisterType((*FindPhysicalKeyboardResponse)(nil), "tast.cros.firmware.FindPhysicalKeyboardResponse")
}

func init() { proto.RegisterFile("utils_service.proto", fileDescriptor_187881f7b6ec64e6) }

var fileDescriptor_187881f7b6ec64e6 = []byte{
	// 323 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0x41, 0x4b, 0xc3, 0x30,
	0x14, 0xc7, 0x37, 0x26, 0xe2, 0xe2, 0x3c, 0x18, 0x45, 0x66, 0xf5, 0x30, 0x7a, 0x90, 0x1d, 0x34,
	0x91, 0x09, 0xde, 0x44, 0xd9, 0xd0, 0x8b, 0x20, 0xd2, 0xe1, 0xc5, 0x8b, 0xa4, 0xed, 0xdb, 0x16,
	0xd6, 0xf6, 0xd5, 0xbc, 0x74, 0xa3, 0xdf, 0xc8, 0x8f, 0x29, 0x6d, 0x9d, 0x97, 0x75, 0x22, 0xbb,
	0xbd, 0x84, 0xf7, 0xcb, 0x7b, 0xbf, 0x3f, 0x61, 0x47, 0x99, 0xd5, 0x11, 0x7d, 0x10, 0x98, 0x85,
	0x0e, 0x40, 0xa4, 0x06, 0x2d, 0x72, 0x6e, 0x15, 0x59, 0x11, 0x18, 0x24, 0x31, 0xd1, 0x26, 0x5e,
	0x2a, 0x03, 0xce, 0xd9, 0x14, 0x71, 0x1a, 0x81, 0x2c, 0x3b, 0xfc, 0x6c, 0x22, 0x21, 0x4e, 0x6d,
	0x5e, 0x01, 0xee, 0x2d, 0xeb, 0x7a, 0xa0, 0xc2, 0x31, 0x98, 0x05, 0x3e, 0x43, 0xee, 0xa3, 0x32,
	0xa1, 0x07, 0x9f, 0x19, 0x90, 0xe5, 0x0e, 0xdb, 0x0b, 0x33, 0xa3, 0xac, 0xc6, 0xa4, 0xdb, 0xec,
	0x35, 0xfb, 0x07, 0xde, 0xef, 0xd9, 0x95, 0xec, 0xb4, 0x86, 0xa3, 0x14, 0x13, 0x02, 0xce, 0xd9,
	0xce, 0x1c, 0x72, 0xea, 0x36, 0x7b, 0xad, 0x7e, 0xdb, 0x2b, 0x6b, 0x77, 0xc0, 0xce, 0x9f, 0x74,
	0x12, 0xbe, 0xce, 0x72, 0xd2, 0x81, 0x8a, 0xea, 0x98, 0x54, 0xd9, 0x59, 0x39, 0xa8, 0xed, 0x95,
	0xf5, 0xe0, 0xab, 0xc5, 0x3a, 0x6f, 0x85, 0xe5, 0xb8, 0x92, 0xe4, 0x0f, 0xac, 0x33, 0x8c, 0x30,
	0x98, 0xeb, 0x64, 0x3a, 0xce, 0x93, 0x80, 0x9f, 0x88, 0xca, 0x4d, 0xac, 0xdc, 0xc4, 0x63, 0xe1,
	0xe6, 0x6c, 0xb8, 0x77, 0x1b, 0xdc, 0xb0, 0xc3, 0xb5, 0xbd, 0xf9, 0xa5, 0x58, 0x8f, 0x4d, 0x6c,
	0x8a, 0xc5, 0xb9, 0xfa, 0x67, 0x77, 0x25, 0xe6, 0x36, 0xb8, 0xcf, 0x8e, 0xeb, 0xd4, 0x37, 0x6e,
	0x7f, 0x5d, 0x37, 0xe0, 0xaf, 0xf0, 0xdc, 0x06, 0xbf, 0x63, 0xed, 0x17, 0x58, 0x8e, 0x66, 0x06,
	0x63, 0xd8, 0x22, 0x96, 0x7b, 0xb6, 0x3f, 0x8a, 0x90, 0x60, 0xdb, 0x07, 0x86, 0xfd, 0xf7, 0x8b,
	0xa0, 0x60, 0x75, 0x16, 0x23, 0xc9, 0x62, 0x7f, 0xf9, 0xf3, 0x33, 0x49, 0x16, 0x22, 0x72, 0x25,
	0xe2, 0xef, 0x96, 0xec, 0xcd, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa0, 0xac, 0xf1, 0x00, 0xc0,
	0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UtilsServiceClient is the client API for UtilsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UtilsServiceClient interface {
	// BlockingSync syncs the root device and internal device.
	BlockingSync(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// ReadServoKeyboard reads from the servo's keyboard emulator and decodes the key presses.
	ReadServoKeyboard(ctx context.Context, in *ReadServoKeyboardRequest, opts ...grpc.CallOption) (*ReadServoKeyboardResponse, error)
	// FindPhysicalKeyboard finds /dev/input/event* file for physical a keyboard.
	FindPhysicalKeyboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FindPhysicalKeyboardResponse, error)
	// NewChrome creates a new instance of Chrome
	NewChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// CloseChrome closes an existing instance of Chrome
	CloseChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
}

type utilsServiceClient struct {
	cc *grpc.ClientConn
}

func NewUtilsServiceClient(cc *grpc.ClientConn) UtilsServiceClient {
	return &utilsServiceClient{cc}
}

func (c *utilsServiceClient) BlockingSync(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/BlockingSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsServiceClient) ReadServoKeyboard(ctx context.Context, in *ReadServoKeyboardRequest, opts ...grpc.CallOption) (*ReadServoKeyboardResponse, error) {
	out := new(ReadServoKeyboardResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/ReadServoKeyboard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsServiceClient) FindPhysicalKeyboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*FindPhysicalKeyboardResponse, error) {
	out := new(FindPhysicalKeyboardResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/FindPhysicalKeyboard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsServiceClient) NewChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/NewChrome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsServiceClient) CloseChrome(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/CloseChrome", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UtilsServiceServer is the server API for UtilsService service.
type UtilsServiceServer interface {
	// BlockingSync syncs the root device and internal device.
	BlockingSync(context.Context, *empty.Empty) (*empty.Empty, error)
	// ReadServoKeyboard reads from the servo's keyboard emulator and decodes the key presses.
	ReadServoKeyboard(context.Context, *ReadServoKeyboardRequest) (*ReadServoKeyboardResponse, error)
	// FindPhysicalKeyboard finds /dev/input/event* file for physical a keyboard.
	FindPhysicalKeyboard(context.Context, *empty.Empty) (*FindPhysicalKeyboardResponse, error)
	// NewChrome creates a new instance of Chrome
	NewChrome(context.Context, *empty.Empty) (*empty.Empty, error)
	// CloseChrome closes an existing instance of Chrome
	CloseChrome(context.Context, *empty.Empty) (*empty.Empty, error)
}

// UnimplementedUtilsServiceServer can be embedded to have forward compatible implementations.
type UnimplementedUtilsServiceServer struct {
}

func (*UnimplementedUtilsServiceServer) BlockingSync(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockingSync not implemented")
}
func (*UnimplementedUtilsServiceServer) ReadServoKeyboard(ctx context.Context, req *ReadServoKeyboardRequest) (*ReadServoKeyboardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadServoKeyboard not implemented")
}
func (*UnimplementedUtilsServiceServer) FindPhysicalKeyboard(ctx context.Context, req *empty.Empty) (*FindPhysicalKeyboardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindPhysicalKeyboard not implemented")
}
func (*UnimplementedUtilsServiceServer) NewChrome(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewChrome not implemented")
}
func (*UnimplementedUtilsServiceServer) CloseChrome(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseChrome not implemented")
}

func RegisterUtilsServiceServer(s *grpc.Server, srv UtilsServiceServer) {
	s.RegisterService(&_UtilsService_serviceDesc, srv)
}

func _UtilsService_BlockingSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).BlockingSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/BlockingSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).BlockingSync(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilsService_ReadServoKeyboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadServoKeyboardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).ReadServoKeyboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/ReadServoKeyboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).ReadServoKeyboard(ctx, req.(*ReadServoKeyboardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilsService_FindPhysicalKeyboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).FindPhysicalKeyboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/FindPhysicalKeyboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).FindPhysicalKeyboard(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilsService_NewChrome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).NewChrome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/NewChrome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).NewChrome(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilsService_CloseChrome_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).CloseChrome(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/CloseChrome",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).CloseChrome(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _UtilsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.cros.firmware.UtilsService",
	HandlerType: (*UtilsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BlockingSync",
			Handler:    _UtilsService_BlockingSync_Handler,
		},
		{
			MethodName: "ReadServoKeyboard",
			Handler:    _UtilsService_ReadServoKeyboard_Handler,
		},
		{
			MethodName: "FindPhysicalKeyboard",
			Handler:    _UtilsService_FindPhysicalKeyboard_Handler,
		},
		{
			MethodName: "NewChrome",
			Handler:    _UtilsService_NewChrome_Handler,
		},
		{
			MethodName: "CloseChrome",
			Handler:    _UtilsService_CloseChrome_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "utils_service.proto",
}
