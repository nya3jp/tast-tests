// Code generated by protoc-gen-go. DO NOT EDIT.
// source: utils_service.proto

package firmware

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// BootMode contains values for the three possible modes of a powered-on DUT.
type BootMode int32

const (
	BootMode_BOOT_MODE_UNSPECIFIED BootMode = 0
	BootMode_BOOT_MODE_NORMAL      BootMode = 1
	BootMode_BOOT_MODE_DEV         BootMode = 2
	BootMode_BOOT_MODE_RECOVERY    BootMode = 3
)

var BootMode_name = map[int32]string{
	0: "BOOT_MODE_UNSPECIFIED",
	1: "BOOT_MODE_NORMAL",
	2: "BOOT_MODE_DEV",
	3: "BOOT_MODE_RECOVERY",
}

var BootMode_value = map[string]int32{
	"BOOT_MODE_UNSPECIFIED": 0,
	"BOOT_MODE_NORMAL":      1,
	"BOOT_MODE_DEV":         2,
	"BOOT_MODE_RECOVERY":    3,
}

func (x BootMode) String() string {
	return proto.EnumName(BootMode_name, int32(x))
}

func (BootMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{0}
}

type PlatformResponse struct {
	Platform             string   `protobuf:"bytes,1,opt,name=Platform,proto3" json:"Platform,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlatformResponse) Reset()         { *m = PlatformResponse{} }
func (m *PlatformResponse) String() string { return proto.CompactTextString(m) }
func (*PlatformResponse) ProtoMessage()    {}
func (*PlatformResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{0}
}

func (m *PlatformResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlatformResponse.Unmarshal(m, b)
}
func (m *PlatformResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlatformResponse.Marshal(b, m, deterministic)
}
func (m *PlatformResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlatformResponse.Merge(m, src)
}
func (m *PlatformResponse) XXX_Size() int {
	return xxx_messageInfo_PlatformResponse.Size(m)
}
func (m *PlatformResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PlatformResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PlatformResponse proto.InternalMessageInfo

func (m *PlatformResponse) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

type CheckBootModeRequest struct {
	BootMode             BootMode `protobuf:"varint,1,opt,name=boot_mode,json=bootMode,proto3,enum=tast.cros.firmware.BootMode" json:"boot_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckBootModeRequest) Reset()         { *m = CheckBootModeRequest{} }
func (m *CheckBootModeRequest) String() string { return proto.CompactTextString(m) }
func (*CheckBootModeRequest) ProtoMessage()    {}
func (*CheckBootModeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{1}
}

func (m *CheckBootModeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CheckBootModeRequest.Unmarshal(m, b)
}
func (m *CheckBootModeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CheckBootModeRequest.Marshal(b, m, deterministic)
}
func (m *CheckBootModeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckBootModeRequest.Merge(m, src)
}
func (m *CheckBootModeRequest) XXX_Size() int {
	return xxx_messageInfo_CheckBootModeRequest.Size(m)
}
func (m *CheckBootModeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckBootModeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckBootModeRequest proto.InternalMessageInfo

func (m *CheckBootModeRequest) GetBootMode() BootMode {
	if m != nil {
		return m.BootMode
	}
	return BootMode_BOOT_MODE_UNSPECIFIED
}

type CheckBootModeResponse struct {
	Verified             bool     `protobuf:"varint,1,opt,name=verified,proto3" json:"verified,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckBootModeResponse) Reset()         { *m = CheckBootModeResponse{} }
func (m *CheckBootModeResponse) String() string { return proto.CompactTextString(m) }
func (*CheckBootModeResponse) ProtoMessage()    {}
func (*CheckBootModeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{2}
}

func (m *CheckBootModeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CheckBootModeResponse.Unmarshal(m, b)
}
func (m *CheckBootModeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CheckBootModeResponse.Marshal(b, m, deterministic)
}
func (m *CheckBootModeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckBootModeResponse.Merge(m, src)
}
func (m *CheckBootModeResponse) XXX_Size() int {
	return xxx_messageInfo_CheckBootModeResponse.Size(m)
}
func (m *CheckBootModeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckBootModeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckBootModeResponse proto.InternalMessageInfo

func (m *CheckBootModeResponse) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

type CurrentBootModeResponse struct {
	BootMode             BootMode `protobuf:"varint,1,opt,name=boot_mode,json=bootMode,proto3,enum=tast.cros.firmware.BootMode" json:"boot_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CurrentBootModeResponse) Reset()         { *m = CurrentBootModeResponse{} }
func (m *CurrentBootModeResponse) String() string { return proto.CompactTextString(m) }
func (*CurrentBootModeResponse) ProtoMessage()    {}
func (*CurrentBootModeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{3}
}

func (m *CurrentBootModeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CurrentBootModeResponse.Unmarshal(m, b)
}
func (m *CurrentBootModeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CurrentBootModeResponse.Marshal(b, m, deterministic)
}
func (m *CurrentBootModeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentBootModeResponse.Merge(m, src)
}
func (m *CurrentBootModeResponse) XXX_Size() int {
	return xxx_messageInfo_CurrentBootModeResponse.Size(m)
}
func (m *CurrentBootModeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentBootModeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentBootModeResponse proto.InternalMessageInfo

func (m *CurrentBootModeResponse) GetBootMode() BootMode {
	if m != nil {
		return m.BootMode
	}
	return BootMode_BOOT_MODE_UNSPECIFIED
}

func init() {
	proto.RegisterEnum("tast.cros.firmware.BootMode", BootMode_name, BootMode_value)
	proto.RegisterType((*PlatformResponse)(nil), "tast.cros.firmware.PlatformResponse")
	proto.RegisterType((*CheckBootModeRequest)(nil), "tast.cros.firmware.CheckBootModeRequest")
	proto.RegisterType((*CheckBootModeResponse)(nil), "tast.cros.firmware.CheckBootModeResponse")
	proto.RegisterType((*CurrentBootModeResponse)(nil), "tast.cros.firmware.CurrentBootModeResponse")
}

func init() { proto.RegisterFile("utils_service.proto", fileDescriptor_187881f7b6ec64e6) }

var fileDescriptor_187881f7b6ec64e6 = []byte{
	// 401 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x93, 0x5f, 0x8f, 0x93, 0x40,
	0x14, 0xc5, 0xe9, 0x9a, 0x18, 0xf6, 0x66, 0x57, 0x71, 0xdc, 0x5d, 0x15, 0x7d, 0x30, 0xc4, 0x98,
	0xaa, 0xc9, 0x90, 0xec, 0x3e, 0xf9, 0xa6, 0x50, 0x4c, 0xd6, 0xd8, 0xa5, 0xd2, 0x3f, 0x51, 0x5f,
	0x48, 0xa1, 0x43, 0x4b, 0x0a, 0xdc, 0x3a, 0x33, 0xd4, 0xf4, 0xcb, 0xfa, 0x59, 0x0c, 0xb4, 0x40,
	0x6c, 0x69, 0x62, 0x7c, 0x63, 0x0e, 0x73, 0xce, 0x3d, 0xdc, 0x5f, 0x80, 0xc7, 0xb9, 0x8c, 0x13,
	0xe1, 0x0b, 0xc6, 0xd7, 0x71, 0xc8, 0xe8, 0x8a, 0xa3, 0x44, 0x42, 0xe4, 0x54, 0x48, 0x1a, 0x72,
	0x14, 0x34, 0x8a, 0x79, 0xfa, 0x6b, 0xca, 0x99, 0xfe, 0x7c, 0x8e, 0x38, 0x4f, 0x98, 0x59, 0xde,
	0x08, 0xf2, 0xc8, 0x64, 0xe9, 0x4a, 0x6e, 0xb6, 0x06, 0x83, 0x82, 0x36, 0x48, 0xa6, 0x32, 0x42,
	0x9e, 0x7a, 0x4c, 0xac, 0x30, 0x13, 0x8c, 0xe8, 0xa0, 0x56, 0xda, 0xd3, 0xce, 0xcb, 0x4e, 0xf7,
	0xd4, 0xab, 0xcf, 0xc6, 0x57, 0xb8, 0xb0, 0x17, 0x2c, 0x5c, 0x5a, 0x88, 0xb2, 0x8f, 0x33, 0xe6,
	0xb1, 0x9f, 0x39, 0x13, 0x92, 0xbc, 0x87, 0xd3, 0x00, 0x51, 0xfa, 0x29, 0xce, 0x58, 0x69, 0x7a,
	0x70, 0xfd, 0x82, 0x1e, 0x96, 0xa1, 0xb5, 0x4f, 0x0d, 0x76, 0x4f, 0xc6, 0x0d, 0x5c, 0xee, 0x45,
	0x36, 0x3d, 0xd6, 0x8c, 0xc7, 0x51, 0xcc, 0x66, 0x65, 0xa4, 0xea, 0xd5, 0x67, 0x63, 0x04, 0x4f,
	0xec, 0x9c, 0x73, 0x96, 0xc9, 0x03, 0xdb, 0xff, 0x57, 0x79, 0x1b, 0x81, 0x5a, 0xa9, 0xe4, 0x19,
	0x5c, 0x5a, 0xae, 0x3b, 0xf2, 0xfb, 0x6e, 0xcf, 0xf1, 0xc7, 0x77, 0xc3, 0x81, 0x63, 0xdf, 0x7e,
	0xba, 0x75, 0x7a, 0x9a, 0x42, 0x2e, 0x40, 0x6b, 0x5e, 0xdd, 0xb9, 0x5e, 0xff, 0xe3, 0x17, 0xad,
	0x43, 0x1e, 0xc1, 0x79, 0xa3, 0xf6, 0x9c, 0x89, 0x76, 0x42, 0xae, 0x80, 0x34, 0x92, 0xe7, 0xd8,
	0xee, 0xc4, 0xf1, 0xbe, 0x6b, 0xf7, 0xae, 0x7f, 0x9f, 0xc0, 0xd9, 0xb8, 0xc0, 0x37, 0xdc, 0xd2,
	0x23, 0x9f, 0x9b, 0x95, 0x93, 0x2b, 0xba, 0x05, 0x46, 0x2b, 0x60, 0xd4, 0x29, 0x80, 0xe9, 0xaf,
	0xda, 0x3e, 0x62, 0x1f, 0x9e, 0xa1, 0x90, 0x08, 0xce, 0xff, 0xda, 0x27, 0xe9, 0xb6, 0x19, 0xdb,
	0x28, 0xea, 0x6f, 0xfe, 0xe1, 0x66, 0x3d, 0xe7, 0x1b, 0x3c, 0xdc, 0x43, 0x70, 0xb4, 0xfa, 0xbb,
	0xd6, 0xdc, 0x76, 0x7e, 0x86, 0x42, 0x3e, 0xc0, 0x99, 0x95, 0x60, 0xb8, 0x8c, 0xb3, 0xf9, 0x70,
	0x93, 0x85, 0x47, 0x63, 0x8f, 0xe8, 0x86, 0x62, 0x75, 0x7f, 0xbc, 0x0e, 0x17, 0x1c, 0xd3, 0x38,
	0x4f, 0x51, 0x98, 0xc5, 0x70, 0x73, 0xf7, 0xa3, 0x08, 0xb3, 0x68, 0x61, 0x56, 0x2d, 0x82, 0xfb,
	0xa5, 0xf7, 0xe6, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xce, 0x3c, 0x1b, 0x57, 0x4f, 0x03, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UtilsServiceClient is the client API for UtilsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UtilsServiceClient interface {
	// Platform gets the name of the DUT platform (coral, samus, drallion, etc).
	Platform(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PlatformResponse, error)
	// CheckBootMode verifies whether the DUT is in a certain boot mode.
	CheckBootMode(ctx context.Context, in *CheckBootModeRequest, opts ...grpc.CallOption) (*CheckBootModeResponse, error)
	// CurrentBootMode determines which boot mode the DUT is in.
	CurrentBootMode(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CurrentBootModeResponse, error)
	// BlockingSync syncs the root device and internal device.
	BlockingSync(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
}

type utilsServiceClient struct {
	cc *grpc.ClientConn
}

func NewUtilsServiceClient(cc *grpc.ClientConn) UtilsServiceClient {
	return &utilsServiceClient{cc}
}

func (c *utilsServiceClient) Platform(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PlatformResponse, error) {
	out := new(PlatformResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/Platform", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsServiceClient) CheckBootMode(ctx context.Context, in *CheckBootModeRequest, opts ...grpc.CallOption) (*CheckBootModeResponse, error) {
	out := new(CheckBootModeResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/CheckBootMode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsServiceClient) CurrentBootMode(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CurrentBootModeResponse, error) {
	out := new(CurrentBootModeResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/CurrentBootMode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsServiceClient) BlockingSync(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/BlockingSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UtilsServiceServer is the server API for UtilsService service.
type UtilsServiceServer interface {
	// Platform gets the name of the DUT platform (coral, samus, drallion, etc).
	Platform(context.Context, *empty.Empty) (*PlatformResponse, error)
	// CheckBootMode verifies whether the DUT is in a certain boot mode.
	CheckBootMode(context.Context, *CheckBootModeRequest) (*CheckBootModeResponse, error)
	// CurrentBootMode determines which boot mode the DUT is in.
	CurrentBootMode(context.Context, *empty.Empty) (*CurrentBootModeResponse, error)
	// BlockingSync syncs the root device and internal device.
	BlockingSync(context.Context, *empty.Empty) (*empty.Empty, error)
}

// UnimplementedUtilsServiceServer can be embedded to have forward compatible implementations.
type UnimplementedUtilsServiceServer struct {
}

func (*UnimplementedUtilsServiceServer) Platform(ctx context.Context, req *empty.Empty) (*PlatformResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Platform not implemented")
}
func (*UnimplementedUtilsServiceServer) CheckBootMode(ctx context.Context, req *CheckBootModeRequest) (*CheckBootModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckBootMode not implemented")
}
func (*UnimplementedUtilsServiceServer) CurrentBootMode(ctx context.Context, req *empty.Empty) (*CurrentBootModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentBootMode not implemented")
}
func (*UnimplementedUtilsServiceServer) BlockingSync(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockingSync not implemented")
}

func RegisterUtilsServiceServer(s *grpc.Server, srv UtilsServiceServer) {
	s.RegisterService(&_UtilsService_serviceDesc, srv)
}

func _UtilsService_Platform_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).Platform(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/Platform",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).Platform(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilsService_CheckBootMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckBootModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).CheckBootMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/CheckBootMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).CheckBootMode(ctx, req.(*CheckBootModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilsService_CurrentBootMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).CurrentBootMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/CurrentBootMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).CurrentBootMode(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilsService_BlockingSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).BlockingSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/BlockingSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).BlockingSync(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _UtilsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.cros.firmware.UtilsService",
	HandlerType: (*UtilsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Platform",
			Handler:    _UtilsService_Platform_Handler,
		},
		{
			MethodName: "CheckBootMode",
			Handler:    _UtilsService_CheckBootMode_Handler,
		},
		{
			MethodName: "CurrentBootMode",
			Handler:    _UtilsService_CurrentBootMode_Handler,
		},
		{
			MethodName: "BlockingSync",
			Handler:    _UtilsService_BlockingSync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "utils_service.proto",
}
