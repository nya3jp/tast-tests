// Code generated by protoc-gen-go. DO NOT EDIT.
// source: utils_service.proto

package firmware

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// BootMode contains values for the three possible modes of a powered-on DUT.
type BootMode int32

const (
	BootMode_BOOT_MODE_UNSPECIFIED BootMode = 0
	BootMode_BOOT_MODE_NORMAL      BootMode = 1
	BootMode_BOOT_MODE_DEV         BootMode = 2
	BootMode_BOOT_MODE_RECOVERY    BootMode = 3
)

var BootMode_name = map[int32]string{
	0: "BOOT_MODE_UNSPECIFIED",
	1: "BOOT_MODE_NORMAL",
	2: "BOOT_MODE_DEV",
	3: "BOOT_MODE_RECOVERY",
}

var BootMode_value = map[string]int32{
	"BOOT_MODE_UNSPECIFIED": 0,
	"BOOT_MODE_NORMAL":      1,
	"BOOT_MODE_DEV":         2,
	"BOOT_MODE_RECOVERY":    3,
}

func (x BootMode) String() string {
	return proto.EnumName(BootMode_name, int32(x))
}

func (BootMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{0}
}

type PlatformResponse struct {
	Platform             string   `protobuf:"bytes,1,opt,name=Platform,proto3" json:"Platform,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlatformResponse) Reset()         { *m = PlatformResponse{} }
func (m *PlatformResponse) String() string { return proto.CompactTextString(m) }
func (*PlatformResponse) ProtoMessage()    {}
func (*PlatformResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{0}
}

func (m *PlatformResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlatformResponse.Unmarshal(m, b)
}
func (m *PlatformResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlatformResponse.Marshal(b, m, deterministic)
}
func (m *PlatformResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlatformResponse.Merge(m, src)
}
func (m *PlatformResponse) XXX_Size() int {
	return xxx_messageInfo_PlatformResponse.Size(m)
}
func (m *PlatformResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PlatformResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PlatformResponse proto.InternalMessageInfo

func (m *PlatformResponse) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

type CurrentBootModeResponse struct {
	BootMode             BootMode `protobuf:"varint,1,opt,name=boot_mode,json=bootMode,proto3,enum=tast.cros.firmware.BootMode" json:"boot_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CurrentBootModeResponse) Reset()         { *m = CurrentBootModeResponse{} }
func (m *CurrentBootModeResponse) String() string { return proto.CompactTextString(m) }
func (*CurrentBootModeResponse) ProtoMessage()    {}
func (*CurrentBootModeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{1}
}

func (m *CurrentBootModeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CurrentBootModeResponse.Unmarshal(m, b)
}
func (m *CurrentBootModeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CurrentBootModeResponse.Marshal(b, m, deterministic)
}
func (m *CurrentBootModeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentBootModeResponse.Merge(m, src)
}
func (m *CurrentBootModeResponse) XXX_Size() int {
	return xxx_messageInfo_CurrentBootModeResponse.Size(m)
}
func (m *CurrentBootModeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentBootModeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentBootModeResponse proto.InternalMessageInfo

func (m *CurrentBootModeResponse) GetBootMode() BootMode {
	if m != nil {
		return m.BootMode
	}
	return BootMode_BOOT_MODE_UNSPECIFIED
}

type ReadServoKeyboardResponse struct {
	Keys                 []byte   `protobuf:"bytes,1,opt,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadServoKeyboardResponse) Reset()         { *m = ReadServoKeyboardResponse{} }
func (m *ReadServoKeyboardResponse) String() string { return proto.CompactTextString(m) }
func (*ReadServoKeyboardResponse) ProtoMessage()    {}
func (*ReadServoKeyboardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_187881f7b6ec64e6, []int{2}
}

func (m *ReadServoKeyboardResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadServoKeyboardResponse.Unmarshal(m, b)
}
func (m *ReadServoKeyboardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadServoKeyboardResponse.Marshal(b, m, deterministic)
}
func (m *ReadServoKeyboardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadServoKeyboardResponse.Merge(m, src)
}
func (m *ReadServoKeyboardResponse) XXX_Size() int {
	return xxx_messageInfo_ReadServoKeyboardResponse.Size(m)
}
func (m *ReadServoKeyboardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadServoKeyboardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReadServoKeyboardResponse proto.InternalMessageInfo

func (m *ReadServoKeyboardResponse) GetKeys() []byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func init() {
	proto.RegisterEnum("tast.cros.firmware.BootMode", BootMode_name, BootMode_value)
	proto.RegisterType((*PlatformResponse)(nil), "tast.cros.firmware.PlatformResponse")
	proto.RegisterType((*CurrentBootModeResponse)(nil), "tast.cros.firmware.CurrentBootModeResponse")
	proto.RegisterType((*ReadServoKeyboardResponse)(nil), "tast.cros.firmware.ReadServoKeyboardResponse")
}

func init() { proto.RegisterFile("utils_service.proto", fileDescriptor_187881f7b6ec64e6) }

var fileDescriptor_187881f7b6ec64e6 = []byte{
	// 389 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0x5d, 0x8f, 0x93, 0x40,
	0x14, 0x86, 0xe9, 0x6a, 0x4c, 0xf7, 0xa4, 0x2a, 0x3b, 0xea, 0xea, 0x56, 0x2f, 0x0c, 0x31, 0x66,
	0xa3, 0x71, 0x48, 0xd6, 0x2b, 0xef, 0x94, 0x16, 0x93, 0x55, 0x5b, 0x1a, 0x68, 0x1b, 0x35, 0x26,
	0x84, 0x8f, 0xa1, 0x92, 0x02, 0xa7, 0x99, 0x19, 0x6a, 0xf8, 0x9f, 0xfe, 0xa0, 0x0d, 0xb4, 0x40,
	0xd2, 0x96, 0xbb, 0xe1, 0x85, 0xf7, 0xe1, 0xf0, 0x1c, 0xe0, 0x49, 0x2e, 0xe3, 0x44, 0xb8, 0x82,
	0xf1, 0x6d, 0x1c, 0x30, 0xba, 0xe1, 0x28, 0x91, 0x10, 0xe9, 0x09, 0x49, 0x03, 0x8e, 0x82, 0x46,
	0x31, 0x4f, 0xff, 0x79, 0x9c, 0x0d, 0x5f, 0xae, 0x10, 0x57, 0x09, 0xd3, 0xab, 0x27, 0xfc, 0x3c,
	0xd2, 0x59, 0xba, 0x91, 0xc5, 0xae, 0xa0, 0x51, 0x50, 0x67, 0x89, 0x27, 0x23, 0xe4, 0xa9, 0xcd,
	0xc4, 0x06, 0x33, 0xc1, 0xc8, 0x10, 0xfa, 0x75, 0xf6, 0xa2, 0xf7, 0xba, 0x77, 0x7d, 0x6e, 0x37,
	0xd7, 0xda, 0x1c, 0x9e, 0x8f, 0x72, 0xce, 0x59, 0x26, 0x0d, 0x44, 0x39, 0xc1, 0x90, 0x35, 0xb5,
	0x4f, 0x70, 0xee, 0x23, 0x4a, 0x37, 0xc5, 0x90, 0x55, 0xbd, 0x47, 0x37, 0xaf, 0xe8, 0xf1, 0x3c,
	0xb4, 0x29, 0xf6, 0xfd, 0xfd, 0x49, 0xd3, 0xe1, 0xca, 0x66, 0x5e, 0xe8, 0x30, 0xbe, 0xc5, 0xef,
	0xac, 0xf0, 0xd1, 0xe3, 0x61, 0xc3, 0x25, 0x70, 0x7f, 0xcd, 0x0a, 0x51, 0x21, 0x07, 0x76, 0x75,
	0x7e, 0x17, 0x41, 0xbf, 0xc6, 0x90, 0x2b, 0x78, 0x66, 0x58, 0xd6, 0xdc, 0x9d, 0x58, 0x63, 0xd3,
	0x5d, 0x4c, 0x9d, 0x99, 0x39, 0xba, 0xfd, 0x7a, 0x6b, 0x8e, 0x55, 0x85, 0x3c, 0x05, 0xb5, 0xbd,
	0x35, 0xb5, 0xec, 0xc9, 0x97, 0x1f, 0x6a, 0x8f, 0x5c, 0xc0, 0xc3, 0x36, 0x1d, 0x9b, 0x4b, 0xf5,
	0x8c, 0x5c, 0x02, 0x69, 0x23, 0xdb, 0x1c, 0x59, 0x4b, 0xd3, 0xfe, 0xa5, 0xde, 0xbb, 0xf9, 0x7f,
	0x06, 0x83, 0x45, 0xe9, 0xd9, 0xd9, 0x69, 0x26, 0xdf, 0x5a, 0x37, 0xe4, 0x92, 0xee, 0xcc, 0xd2,
	0xda, 0x2c, 0x35, 0x4b, 0xb3, 0xc3, 0x37, 0xa7, 0xbe, 0xfa, 0xd0, 0xb2, 0xa6, 0x90, 0x9f, 0xf0,
	0xf8, 0xc0, 0x65, 0x27, 0xf2, 0xfd, 0x29, 0x64, 0xc7, 0x22, 0x34, 0x85, 0x7c, 0x86, 0x81, 0x91,
	0x60, 0xb0, 0x8e, 0xb3, 0x95, 0x53, 0x64, 0x41, 0x27, 0xb6, 0x23, 0xd7, 0x14, 0xf2, 0x07, 0x2e,
	0x8e, 0x36, 0xd2, 0x89, 0xf9, 0x70, 0x6a, 0xba, 0xce, 0x85, 0x6a, 0x8a, 0x71, 0xfd, 0xfb, 0x6d,
	0xf0, 0x97, 0x63, 0x1a, 0xe7, 0x29, 0x0a, 0xbd, 0x2c, 0xeb, 0xfb, 0xff, 0x58, 0xe8, 0x25, 0x45,
	0xaf, 0x29, 0xfe, 0x83, 0xea, 0x55, 0x1f, 0xef, 0x02, 0x00, 0x00, 0xff, 0xff, 0x24, 0xba, 0x8d,
	0x3d, 0xee, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UtilsServiceClient is the client API for UtilsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UtilsServiceClient interface {
	// Platform gets the name of the DUT platform (coral, samus, drallion, etc).
	Platform(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PlatformResponse, error)
	// CurrentBootMode determines which boot mode the DUT is in.
	CurrentBootMode(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CurrentBootModeResponse, error)
	// BlockingSync syncs the root device and internal device.
	BlockingSync(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// ReadServoKeyboard reads from the servo's keyboard emulator.
	ReadServoKeyboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ReadServoKeyboardResponse, error)
}

type utilsServiceClient struct {
	cc *grpc.ClientConn
}

func NewUtilsServiceClient(cc *grpc.ClientConn) UtilsServiceClient {
	return &utilsServiceClient{cc}
}

func (c *utilsServiceClient) Platform(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*PlatformResponse, error) {
	out := new(PlatformResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/Platform", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsServiceClient) CurrentBootMode(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*CurrentBootModeResponse, error) {
	out := new(CurrentBootModeResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/CurrentBootMode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsServiceClient) BlockingSync(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/BlockingSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *utilsServiceClient) ReadServoKeyboard(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ReadServoKeyboardResponse, error) {
	out := new(ReadServoKeyboardResponse)
	err := c.cc.Invoke(ctx, "/tast.cros.firmware.UtilsService/ReadServoKeyboard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UtilsServiceServer is the server API for UtilsService service.
type UtilsServiceServer interface {
	// Platform gets the name of the DUT platform (coral, samus, drallion, etc).
	Platform(context.Context, *empty.Empty) (*PlatformResponse, error)
	// CurrentBootMode determines which boot mode the DUT is in.
	CurrentBootMode(context.Context, *empty.Empty) (*CurrentBootModeResponse, error)
	// BlockingSync syncs the root device and internal device.
	BlockingSync(context.Context, *empty.Empty) (*empty.Empty, error)
	// ReadServoKeyboard reads from the servo's keyboard emulator.
	ReadServoKeyboard(context.Context, *empty.Empty) (*ReadServoKeyboardResponse, error)
}

// UnimplementedUtilsServiceServer can be embedded to have forward compatible implementations.
type UnimplementedUtilsServiceServer struct {
}

func (*UnimplementedUtilsServiceServer) Platform(ctx context.Context, req *empty.Empty) (*PlatformResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Platform not implemented")
}
func (*UnimplementedUtilsServiceServer) CurrentBootMode(ctx context.Context, req *empty.Empty) (*CurrentBootModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentBootMode not implemented")
}
func (*UnimplementedUtilsServiceServer) BlockingSync(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockingSync not implemented")
}
func (*UnimplementedUtilsServiceServer) ReadServoKeyboard(ctx context.Context, req *empty.Empty) (*ReadServoKeyboardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadServoKeyboard not implemented")
}

func RegisterUtilsServiceServer(s *grpc.Server, srv UtilsServiceServer) {
	s.RegisterService(&_UtilsService_serviceDesc, srv)
}

func _UtilsService_Platform_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).Platform(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/Platform",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).Platform(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilsService_CurrentBootMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).CurrentBootMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/CurrentBootMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).CurrentBootMode(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilsService_BlockingSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).BlockingSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/BlockingSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).BlockingSync(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UtilsService_ReadServoKeyboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UtilsServiceServer).ReadServoKeyboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.firmware.UtilsService/ReadServoKeyboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UtilsServiceServer).ReadServoKeyboard(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _UtilsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.cros.firmware.UtilsService",
	HandlerType: (*UtilsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Platform",
			Handler:    _UtilsService_Platform_Handler,
		},
		{
			MethodName: "CurrentBootMode",
			Handler:    _UtilsService_CurrentBootMode_Handler,
		},
		{
			MethodName: "BlockingSync",
			Handler:    _UtilsService_BlockingSync_Handler,
		},
		{
			MethodName: "ReadServoKeyboard",
			Handler:    _UtilsService_ReadServoKeyboard_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "utils_service.proto",
}
