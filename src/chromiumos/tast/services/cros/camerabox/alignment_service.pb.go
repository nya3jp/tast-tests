// Code generated by protoc-gen-go. DO NOT EDIT.
// source: alignment_service.proto

package camerabox

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type AspectRatio int32

const (
	// 4 x 3 aspect ratio
	AspectRatio_AR4X3 AspectRatio = 0
	// 16 x 9 aspect ratio
	AspectRatio_AR16X9 AspectRatio = 1
)

var AspectRatio_name = map[int32]string{
	0: "AR4X3",
	1: "AR16X9",
}

var AspectRatio_value = map[string]int32{
	"AR4X3":  0,
	"AR16X9": 1,
}

func (x AspectRatio) String() string {
	return proto.EnumName(AspectRatio_name, int32(x))
}

func (AspectRatio) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_75246d9c3b103f32, []int{0}
}

type PrepareRequest struct {
	// Directory on DUT for exchanging file results with test host.
	OutDir string `protobuf:"bytes,1,opt,name=out_dir,json=outDir,proto3" json:"out_dir,omitempty"`
	// Username to login chrome and prepare chrome remote desktop.
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// Password to login chrome and prepare chrome remote desktop.
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrepareRequest) Reset()         { *m = PrepareRequest{} }
func (m *PrepareRequest) String() string { return proto.CompactTextString(m) }
func (*PrepareRequest) ProtoMessage()    {}
func (*PrepareRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_75246d9c3b103f32, []int{0}
}

func (m *PrepareRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PrepareRequest.Unmarshal(m, b)
}
func (m *PrepareRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PrepareRequest.Marshal(b, m, deterministic)
}
func (m *PrepareRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareRequest.Merge(m, src)
}
func (m *PrepareRequest) XXX_Size() int {
	return xxx_messageInfo_PrepareRequest.Size(m)
}
func (m *PrepareRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareRequest proto.InternalMessageInfo

func (m *PrepareRequest) GetOutDir() string {
	if m != nil {
		return m.OutDir
	}
	return ""
}

func (m *PrepareRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *PrepareRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type GetPreviewFrameRequest struct {
	// DUT's target camera facing.
	Facing Facing `protobuf:"varint,1,opt,name=facing,proto3,enum=tast.cros.camerabox.Facing" json:"facing,omitempty"`
	// Aspect ratio of preview frame.
	Ratio                AspectRatio `protobuf:"varint,2,opt,name=ratio,proto3,enum=tast.cros.camerabox.AspectRatio" json:"ratio,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *GetPreviewFrameRequest) Reset()         { *m = GetPreviewFrameRequest{} }
func (m *GetPreviewFrameRequest) String() string { return proto.CompactTextString(m) }
func (*GetPreviewFrameRequest) ProtoMessage()    {}
func (*GetPreviewFrameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_75246d9c3b103f32, []int{1}
}

func (m *GetPreviewFrameRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetPreviewFrameRequest.Unmarshal(m, b)
}
func (m *GetPreviewFrameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetPreviewFrameRequest.Marshal(b, m, deterministic)
}
func (m *GetPreviewFrameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPreviewFrameRequest.Merge(m, src)
}
func (m *GetPreviewFrameRequest) XXX_Size() int {
	return xxx_messageInfo_GetPreviewFrameRequest.Size(m)
}
func (m *GetPreviewFrameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPreviewFrameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPreviewFrameRequest proto.InternalMessageInfo

func (m *GetPreviewFrameRequest) GetFacing() Facing {
	if m != nil {
		return m.Facing
	}
	return Facing_FACING_UNSET
}

func (m *GetPreviewFrameRequest) GetRatio() AspectRatio {
	if m != nil {
		return m.Ratio
	}
	return AspectRatio_AR4X3
}

type FeedbackAlignRequest struct {
	// Whether the it's feedback for passed result.
	Passed bool `protobuf:"varint,1,opt,name=passed,proto3" json:"passed,omitempty"`
	// Detail message of feedback.
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FeedbackAlignRequest) Reset()         { *m = FeedbackAlignRequest{} }
func (m *FeedbackAlignRequest) String() string { return proto.CompactTextString(m) }
func (*FeedbackAlignRequest) ProtoMessage()    {}
func (*FeedbackAlignRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_75246d9c3b103f32, []int{2}
}

func (m *FeedbackAlignRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeedbackAlignRequest.Unmarshal(m, b)
}
func (m *FeedbackAlignRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeedbackAlignRequest.Marshal(b, m, deterministic)
}
func (m *FeedbackAlignRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedbackAlignRequest.Merge(m, src)
}
func (m *FeedbackAlignRequest) XXX_Size() int {
	return xxx_messageInfo_FeedbackAlignRequest.Size(m)
}
func (m *FeedbackAlignRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedbackAlignRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FeedbackAlignRequest proto.InternalMessageInfo

func (m *FeedbackAlignRequest) GetPassed() bool {
	if m != nil {
		return m.Passed
	}
	return false
}

func (m *FeedbackAlignRequest) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("tast.cros.camerabox.AspectRatio", AspectRatio_name, AspectRatio_value)
	proto.RegisterType((*PrepareRequest)(nil), "tast.cros.camerabox.PrepareRequest")
	proto.RegisterType((*GetPreviewFrameRequest)(nil), "tast.cros.camerabox.GetPreviewFrameRequest")
	proto.RegisterType((*FeedbackAlignRequest)(nil), "tast.cros.camerabox.FeedbackAlignRequest")
}

func init() { proto.RegisterFile("alignment_service.proto", fileDescriptor_75246d9c3b103f32) }

var fileDescriptor_75246d9c3b103f32 = []byte{
	// 417 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x92, 0xcf, 0x6e, 0xd4, 0x30,
	0x10, 0xc6, 0xbb, 0xad, 0x9a, 0x6d, 0x07, 0x58, 0x22, 0x83, 0xb6, 0xab, 0xf4, 0x52, 0x05, 0x24,
	0x28, 0x48, 0x8e, 0xd8, 0x45, 0x95, 0x10, 0x17, 0xc2, 0x9f, 0x85, 0x63, 0x65, 0x38, 0xac, 0xb8,
	0x54, 0x8e, 0x33, 0x0d, 0x16, 0xeb, 0x38, 0xd8, 0x4e, 0x0b, 0x0f, 0xc0, 0xc3, 0xf1, 0x56, 0xc8,
	0xf9, 0xb3, 0xa2, 0x28, 0xdd, 0x5b, 0x46, 0xf3, 0xcd, 0xf8, 0x37, 0xdf, 0x17, 0x38, 0xe2, 0x6b,
	0x59, 0x94, 0x0a, 0x4b, 0x77, 0x61, 0xd1, 0x5c, 0x49, 0x81, 0xb4, 0x32, 0xda, 0x69, 0xf2, 0xc0,
	0x71, 0xeb, 0xa8, 0x30, 0xda, 0x52, 0xc1, 0x15, 0x1a, 0x9e, 0xe9, 0x9f, 0xd1, 0x5d, 0xa1, 0x95,
	0xd2, 0x65, 0x2b, 0x89, 0x8e, 0x0b, 0xad, 0x8b, 0x35, 0x26, 0x4d, 0x95, 0xd5, 0x97, 0x09, 0xaa,
	0xca, 0xfd, 0x6a, 0x9b, 0x31, 0x87, 0xc9, 0xb9, 0xc1, 0x8a, 0x1b, 0x64, 0xf8, 0xa3, 0x46, 0xeb,
	0xc8, 0x11, 0x8c, 0x75, 0xed, 0x2e, 0x72, 0x69, 0x66, 0xa3, 0x93, 0xd1, 0xd3, 0x43, 0x16, 0xe8,
	0xda, 0xbd, 0x97, 0x86, 0x44, 0x70, 0x50, 0x5b, 0x34, 0x25, 0x57, 0x38, 0xdb, 0x6d, 0x3a, 0x9b,
	0xda, 0xf7, 0x2a, 0x6e, 0xed, 0xb5, 0x36, 0xf9, 0x6c, 0xaf, 0xed, 0xf5, 0x75, 0xfc, 0x7b, 0x04,
	0xd3, 0x8f, 0xe8, 0xce, 0x0d, 0x5e, 0x49, 0xbc, 0x5e, 0x1a, 0xae, 0x36, 0x6f, 0x2d, 0x20, 0xb8,
	0xe4, 0x42, 0x96, 0x45, 0xf3, 0xd4, 0x64, 0x7e, 0x4c, 0x07, 0xce, 0xa1, 0xcb, 0x46, 0xc2, 0x3a,
	0x29, 0x39, 0x83, 0x7d, 0xc3, 0x9d, 0xd4, 0x0d, 0xc4, 0x64, 0x7e, 0x32, 0x38, 0x93, 0xda, 0x0a,
	0x85, 0x63, 0x5e, 0xc7, 0x5a, 0x79, 0xfc, 0x06, 0x1e, 0x2e, 0x11, 0xf3, 0x8c, 0x8b, 0xef, 0xa9,
	0x77, 0xb3, 0x87, 0x98, 0x42, 0xe0, 0x59, 0x31, 0x6f, 0x20, 0x0e, 0x58, 0x57, 0x91, 0x10, 0xf6,
	0x94, 0x2d, 0xba, 0x53, 0xfd, 0xe7, 0xb3, 0xc7, 0x70, 0xe7, 0x9f, 0xbd, 0xe4, 0x10, 0xf6, 0x53,
	0xf6, 0x72, 0xb5, 0x08, 0x77, 0x08, 0x40, 0x90, 0xb2, 0x17, 0x67, 0xab, 0x57, 0xe1, 0x68, 0xfe,
	0x67, 0x17, 0xc2, 0xb4, 0x8f, 0xeb, 0x73, 0x9b, 0x16, 0xf9, 0x04, 0xe3, 0xce, 0x67, 0xf2, 0x68,
	0x10, 0xf8, 0x66, 0x0a, 0xd1, 0x94, 0xb6, 0xa9, 0xd1, 0x3e, 0x35, 0xfa, 0xc1, 0xa7, 0x16, 0xef,
	0x90, 0x15, 0xdc, 0xff, 0xcf, 0x4d, 0xf2, 0x7c, 0x70, 0xe3, 0xb0, 0xe7, 0x5b, 0x36, 0x7f, 0x81,
	0x7b, 0x37, 0x0c, 0x22, 0xa7, 0xc3, 0x71, 0x0c, 0x98, 0xb8, 0x65, 0xeb, 0x6b, 0x18, 0xbf, 0x5b,
	0x23, 0x2f, 0xeb, 0x8a, 0xdc, 0x22, 0xba, 0x7d, 0xf8, 0xed, 0xe9, 0xd7, 0x27, 0xe2, 0x9b, 0xd1,
	0x4a, 0xd6, 0x4a, 0xdb, 0xc4, 0xd3, 0x24, 0xdd, 0xff, 0x6f, 0x13, 0x8f, 0x95, 0x6c, 0xb0, 0xb2,
	0xa0, 0x19, 0x5e, 0xfc, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x2b, 0xbe, 0x07, 0x22, 0x2b, 0x03, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AlignmentServiceClient is the client API for AlignmentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AlignmentServiceClient interface {
	// Prepare does preparation on DUT for running the alignment check.
	Prepare(ctx context.Context, in *PrepareRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// GetPreviewFrame gets camera preview frame via preview.html.
	GetPreviewFrame(ctx context.Context, in *GetPreviewFrameRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// FeedbackAlign feedbacks alignment result on preview.html.
	FeedbackAlign(ctx context.Context, in *FeedbackAlignRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Cleanup cleans up service states.
	Cleanup(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
}

type alignmentServiceClient struct {
	cc *grpc.ClientConn
}

func NewAlignmentServiceClient(cc *grpc.ClientConn) AlignmentServiceClient {
	return &alignmentServiceClient{cc}
}

func (c *alignmentServiceClient) Prepare(ctx context.Context, in *PrepareRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.camerabox.AlignmentService/Prepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alignmentServiceClient) GetPreviewFrame(ctx context.Context, in *GetPreviewFrameRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.camerabox.AlignmentService/GetPreviewFrame", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alignmentServiceClient) FeedbackAlign(ctx context.Context, in *FeedbackAlignRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.camerabox.AlignmentService/FeedbackAlign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *alignmentServiceClient) Cleanup(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/tast.cros.camerabox.AlignmentService/Cleanup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AlignmentServiceServer is the server API for AlignmentService service.
type AlignmentServiceServer interface {
	// Prepare does preparation on DUT for running the alignment check.
	Prepare(context.Context, *PrepareRequest) (*empty.Empty, error)
	// GetPreviewFrame gets camera preview frame via preview.html.
	GetPreviewFrame(context.Context, *GetPreviewFrameRequest) (*empty.Empty, error)
	// FeedbackAlign feedbacks alignment result on preview.html.
	FeedbackAlign(context.Context, *FeedbackAlignRequest) (*empty.Empty, error)
	// Cleanup cleans up service states.
	Cleanup(context.Context, *empty.Empty) (*empty.Empty, error)
}

// UnimplementedAlignmentServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAlignmentServiceServer struct {
}

func (*UnimplementedAlignmentServiceServer) Prepare(ctx context.Context, req *PrepareRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prepare not implemented")
}
func (*UnimplementedAlignmentServiceServer) GetPreviewFrame(ctx context.Context, req *GetPreviewFrameRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPreviewFrame not implemented")
}
func (*UnimplementedAlignmentServiceServer) FeedbackAlign(ctx context.Context, req *FeedbackAlignRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FeedbackAlign not implemented")
}
func (*UnimplementedAlignmentServiceServer) Cleanup(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cleanup not implemented")
}

func RegisterAlignmentServiceServer(s *grpc.Server, srv AlignmentServiceServer) {
	s.RegisterService(&_AlignmentService_serviceDesc, srv)
}

func _AlignmentService_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlignmentServiceServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.camerabox.AlignmentService/Prepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlignmentServiceServer).Prepare(ctx, req.(*PrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlignmentService_GetPreviewFrame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPreviewFrameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlignmentServiceServer).GetPreviewFrame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.camerabox.AlignmentService/GetPreviewFrame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlignmentServiceServer).GetPreviewFrame(ctx, req.(*GetPreviewFrameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlignmentService_FeedbackAlign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FeedbackAlignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlignmentServiceServer).FeedbackAlign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.camerabox.AlignmentService/FeedbackAlign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlignmentServiceServer).FeedbackAlign(ctx, req.(*FeedbackAlignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AlignmentService_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AlignmentServiceServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tast.cros.camerabox.AlignmentService/Cleanup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AlignmentServiceServer).Cleanup(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _AlignmentService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.cros.camerabox.AlignmentService",
	HandlerType: (*AlignmentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Prepare",
			Handler:    _AlignmentService_Prepare_Handler,
		},
		{
			MethodName: "GetPreviewFrame",
			Handler:    _AlignmentService_GetPreviewFrame_Handler,
		},
		{
			MethodName: "FeedbackAlign",
			Handler:    _AlignmentService_FeedbackAlign_Handler,
		},
		{
			MethodName: "Cleanup",
			Handler:    _AlignmentService_Cleanup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alignment_service.proto",
}
