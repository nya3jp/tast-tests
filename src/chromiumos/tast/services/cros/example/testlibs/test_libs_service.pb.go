// Code generated by protoc-gen-go. DO NOT EDIT.
// source: chromiumos/test/api/test_libs_service.proto

package testlibs

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GetLibFailure_Reason int32

const (
	GetLibFailure_REASON_UNREGISTERED_LIB      GetLibFailure_Reason = 0
	GetLibFailure_REASON_CONTAINER_START_ERROR GetLibFailure_Reason = 1
	GetLibFailure_REASON_UNKNOWN               GetLibFailure_Reason = 2
)

var GetLibFailure_Reason_name = map[int32]string{
	0: "REASON_UNREGISTERED_LIB",
	1: "REASON_CONTAINER_START_ERROR",
	2: "REASON_UNKNOWN",
}

var GetLibFailure_Reason_value = map[string]int32{
	"REASON_UNREGISTERED_LIB":      0,
	"REASON_CONTAINER_START_ERROR": 1,
	"REASON_UNKNOWN":               2,
}

func (x GetLibFailure_Reason) String() string {
	return proto.EnumName(GetLibFailure_Reason_name, int32(x))
}

func (GetLibFailure_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{1, 0}
}

type RunLibCmdFailure_Reason int32

const (
	RunLibCmdFailure_REASON_INVALID_REQUEST RunLibCmdFailure_Reason = 0
	RunLibCmdFailure_REASON_RUN_ERROR       RunLibCmdFailure_Reason = 1
	RunLibCmdFailure_REASON_TIMEOUT         RunLibCmdFailure_Reason = 2
	RunLibCmdFailure_REASON_UNKNOWN         RunLibCmdFailure_Reason = 3
)

var RunLibCmdFailure_Reason_name = map[int32]string{
	0: "REASON_INVALID_REQUEST",
	1: "REASON_RUN_ERROR",
	2: "REASON_TIMEOUT",
	3: "REASON_UNKNOWN",
}

var RunLibCmdFailure_Reason_value = map[string]int32{
	"REASON_INVALID_REQUEST": 0,
	"REASON_RUN_ERROR":       1,
	"REASON_TIMEOUT":         2,
	"REASON_UNKNOWN":         3,
}

func (x RunLibCmdFailure_Reason) String() string {
	return proto.EnumName(RunLibCmdFailure_Reason_name, int32(x))
}

func (RunLibCmdFailure_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{5, 0}
}

// Get Lib messages.
type GetLibSuccess struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLibSuccess) Reset()         { *m = GetLibSuccess{} }
func (m *GetLibSuccess) String() string { return proto.CompactTextString(m) }
func (*GetLibSuccess) ProtoMessage()    {}
func (*GetLibSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{0}
}

func (m *GetLibSuccess) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLibSuccess.Unmarshal(m, b)
}
func (m *GetLibSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLibSuccess.Marshal(b, m, deterministic)
}
func (m *GetLibSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLibSuccess.Merge(m, src)
}
func (m *GetLibSuccess) XXX_Size() int {
	return xxx_messageInfo_GetLibSuccess.Size(m)
}
func (m *GetLibSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLibSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_GetLibSuccess proto.InternalMessageInfo

func (m *GetLibSuccess) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type GetLibFailure struct {
	Reason               GetLibFailure_Reason `protobuf:"varint,1,opt,name=reason,proto3,enum=chromiumos.test.api.GetLibFailure_Reason" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *GetLibFailure) Reset()         { *m = GetLibFailure{} }
func (m *GetLibFailure) String() string { return proto.CompactTextString(m) }
func (*GetLibFailure) ProtoMessage()    {}
func (*GetLibFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{1}
}

func (m *GetLibFailure) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLibFailure.Unmarshal(m, b)
}
func (m *GetLibFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLibFailure.Marshal(b, m, deterministic)
}
func (m *GetLibFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLibFailure.Merge(m, src)
}
func (m *GetLibFailure) XXX_Size() int {
	return xxx_messageInfo_GetLibFailure.Size(m)
}
func (m *GetLibFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLibFailure.DiscardUnknown(m)
}

var xxx_messageInfo_GetLibFailure proto.InternalMessageInfo

func (m *GetLibFailure) GetReason() GetLibFailure_Reason {
	if m != nil {
		return m.Reason
	}
	return GetLibFailure_REASON_UNREGISTERED_LIB
}

type GetLibRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version              string   `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Options              []string `protobuf:"bytes,3,rep,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLibRequest) Reset()         { *m = GetLibRequest{} }
func (m *GetLibRequest) String() string { return proto.CompactTextString(m) }
func (*GetLibRequest) ProtoMessage()    {}
func (*GetLibRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{2}
}

func (m *GetLibRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLibRequest.Unmarshal(m, b)
}
func (m *GetLibRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLibRequest.Marshal(b, m, deterministic)
}
func (m *GetLibRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLibRequest.Merge(m, src)
}
func (m *GetLibRequest) XXX_Size() int {
	return xxx_messageInfo_GetLibRequest.Size(m)
}
func (m *GetLibRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLibRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLibRequest proto.InternalMessageInfo

func (m *GetLibRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetLibRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GetLibRequest) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

type GetLibResponse struct {
	// Types that are valid to be assigned to Outcome:
	//	*GetLibResponse_Success
	//	*GetLibResponse_Failure
	Outcome              isGetLibResponse_Outcome `protobuf_oneof:"outcome"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetLibResponse) Reset()         { *m = GetLibResponse{} }
func (m *GetLibResponse) String() string { return proto.CompactTextString(m) }
func (*GetLibResponse) ProtoMessage()    {}
func (*GetLibResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{3}
}

func (m *GetLibResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLibResponse.Unmarshal(m, b)
}
func (m *GetLibResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLibResponse.Marshal(b, m, deterministic)
}
func (m *GetLibResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLibResponse.Merge(m, src)
}
func (m *GetLibResponse) XXX_Size() int {
	return xxx_messageInfo_GetLibResponse.Size(m)
}
func (m *GetLibResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLibResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLibResponse proto.InternalMessageInfo

type isGetLibResponse_Outcome interface {
	isGetLibResponse_Outcome()
}

type GetLibResponse_Success struct {
	Success *GetLibSuccess `protobuf:"bytes,1,opt,name=success,proto3,oneof"`
}

type GetLibResponse_Failure struct {
	Failure *GetLibFailure `protobuf:"bytes,2,opt,name=failure,proto3,oneof"`
}

func (*GetLibResponse_Success) isGetLibResponse_Outcome() {}

func (*GetLibResponse_Failure) isGetLibResponse_Outcome() {}

func (m *GetLibResponse) GetOutcome() isGetLibResponse_Outcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

func (m *GetLibResponse) GetSuccess() *GetLibSuccess {
	if x, ok := m.GetOutcome().(*GetLibResponse_Success); ok {
		return x.Success
	}
	return nil
}

func (m *GetLibResponse) GetFailure() *GetLibFailure {
	if x, ok := m.GetOutcome().(*GetLibResponse_Failure); ok {
		return x.Failure
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetLibResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetLibResponse_Success)(nil),
		(*GetLibResponse_Failure)(nil),
	}
}

// Run Lib CMD messages.
type RunLibCmdSuccess struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunLibCmdSuccess) Reset()         { *m = RunLibCmdSuccess{} }
func (m *RunLibCmdSuccess) String() string { return proto.CompactTextString(m) }
func (*RunLibCmdSuccess) ProtoMessage()    {}
func (*RunLibCmdSuccess) Descriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{4}
}

func (m *RunLibCmdSuccess) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RunLibCmdSuccess.Unmarshal(m, b)
}
func (m *RunLibCmdSuccess) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RunLibCmdSuccess.Marshal(b, m, deterministic)
}
func (m *RunLibCmdSuccess) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunLibCmdSuccess.Merge(m, src)
}
func (m *RunLibCmdSuccess) XXX_Size() int {
	return xxx_messageInfo_RunLibCmdSuccess.Size(m)
}
func (m *RunLibCmdSuccess) XXX_DiscardUnknown() {
	xxx_messageInfo_RunLibCmdSuccess.DiscardUnknown(m)
}

var xxx_messageInfo_RunLibCmdSuccess proto.InternalMessageInfo

type RunLibCmdFailure struct {
	Reason               RunLibCmdFailure_Reason `protobuf:"varint,1,opt,name=reason,proto3,enum=chromiumos.test.api.RunLibCmdFailure_Reason" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *RunLibCmdFailure) Reset()         { *m = RunLibCmdFailure{} }
func (m *RunLibCmdFailure) String() string { return proto.CompactTextString(m) }
func (*RunLibCmdFailure) ProtoMessage()    {}
func (*RunLibCmdFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{5}
}

func (m *RunLibCmdFailure) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RunLibCmdFailure.Unmarshal(m, b)
}
func (m *RunLibCmdFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RunLibCmdFailure.Marshal(b, m, deterministic)
}
func (m *RunLibCmdFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunLibCmdFailure.Merge(m, src)
}
func (m *RunLibCmdFailure) XXX_Size() int {
	return xxx_messageInfo_RunLibCmdFailure.Size(m)
}
func (m *RunLibCmdFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_RunLibCmdFailure.DiscardUnknown(m)
}

var xxx_messageInfo_RunLibCmdFailure proto.InternalMessageInfo

func (m *RunLibCmdFailure) GetReason() RunLibCmdFailure_Reason {
	if m != nil {
		return m.Reason
	}
	return RunLibCmdFailure_REASON_INVALID_REQUEST
}

type RunLibCmdRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Cmd                  string   `protobuf:"bytes,2,opt,name=cmd,proto3" json:"cmd,omitempty"`
	Args                 string   `protobuf:"bytes,3,opt,name=args,proto3" json:"args,omitempty"`
	Options              string   `protobuf:"bytes,4,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunLibCmdRequest) Reset()         { *m = RunLibCmdRequest{} }
func (m *RunLibCmdRequest) String() string { return proto.CompactTextString(m) }
func (*RunLibCmdRequest) ProtoMessage()    {}
func (*RunLibCmdRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{6}
}

func (m *RunLibCmdRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RunLibCmdRequest.Unmarshal(m, b)
}
func (m *RunLibCmdRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RunLibCmdRequest.Marshal(b, m, deterministic)
}
func (m *RunLibCmdRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunLibCmdRequest.Merge(m, src)
}
func (m *RunLibCmdRequest) XXX_Size() int {
	return xxx_messageInfo_RunLibCmdRequest.Size(m)
}
func (m *RunLibCmdRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunLibCmdRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunLibCmdRequest proto.InternalMessageInfo

func (m *RunLibCmdRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RunLibCmdRequest) GetCmd() string {
	if m != nil {
		return m.Cmd
	}
	return ""
}

func (m *RunLibCmdRequest) GetArgs() string {
	if m != nil {
		return m.Args
	}
	return ""
}

func (m *RunLibCmdRequest) GetOptions() string {
	if m != nil {
		return m.Options
	}
	return ""
}

type RunLibCmdResponse struct {
	// Types that are valid to be assigned to Outcome:
	//	*RunLibCmdResponse_Success
	//	*RunLibCmdResponse_Failure
	Outcome              isRunLibCmdResponse_Outcome `protobuf_oneof:"outcome"`
	Output               []byte                      `protobuf:"bytes,3,opt,name=output,proto3" json:"output,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *RunLibCmdResponse) Reset()         { *m = RunLibCmdResponse{} }
func (m *RunLibCmdResponse) String() string { return proto.CompactTextString(m) }
func (*RunLibCmdResponse) ProtoMessage()    {}
func (*RunLibCmdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{7}
}

func (m *RunLibCmdResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RunLibCmdResponse.Unmarshal(m, b)
}
func (m *RunLibCmdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RunLibCmdResponse.Marshal(b, m, deterministic)
}
func (m *RunLibCmdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunLibCmdResponse.Merge(m, src)
}
func (m *RunLibCmdResponse) XXX_Size() int {
	return xxx_messageInfo_RunLibCmdResponse.Size(m)
}
func (m *RunLibCmdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunLibCmdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunLibCmdResponse proto.InternalMessageInfo

type isRunLibCmdResponse_Outcome interface {
	isRunLibCmdResponse_Outcome()
}

type RunLibCmdResponse_Success struct {
	Success *RunLibCmdSuccess `protobuf:"bytes,1,opt,name=success,proto3,oneof"`
}

type RunLibCmdResponse_Failure struct {
	Failure *RunLibCmdFailure `protobuf:"bytes,2,opt,name=failure,proto3,oneof"`
}

func (*RunLibCmdResponse_Success) isRunLibCmdResponse_Outcome() {}

func (*RunLibCmdResponse_Failure) isRunLibCmdResponse_Outcome() {}

func (m *RunLibCmdResponse) GetOutcome() isRunLibCmdResponse_Outcome {
	if m != nil {
		return m.Outcome
	}
	return nil
}

func (m *RunLibCmdResponse) GetSuccess() *RunLibCmdSuccess {
	if x, ok := m.GetOutcome().(*RunLibCmdResponse_Success); ok {
		return x.Success
	}
	return nil
}

func (m *RunLibCmdResponse) GetFailure() *RunLibCmdFailure {
	if x, ok := m.GetOutcome().(*RunLibCmdResponse_Failure); ok {
		return x.Failure
	}
	return nil
}

func (m *RunLibCmdResponse) GetOutput() []byte {
	if m != nil {
		return m.Output
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RunLibCmdResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RunLibCmdResponse_Success)(nil),
		(*RunLibCmdResponse_Failure)(nil),
	}
}

// Kill Lib messages.
type KillLibRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Options              string   `protobuf:"bytes,2,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KillLibRequest) Reset()         { *m = KillLibRequest{} }
func (m *KillLibRequest) String() string { return proto.CompactTextString(m) }
func (*KillLibRequest) ProtoMessage()    {}
func (*KillLibRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{8}
}

func (m *KillLibRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KillLibRequest.Unmarshal(m, b)
}
func (m *KillLibRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KillLibRequest.Marshal(b, m, deterministic)
}
func (m *KillLibRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KillLibRequest.Merge(m, src)
}
func (m *KillLibRequest) XXX_Size() int {
	return xxx_messageInfo_KillLibRequest.Size(m)
}
func (m *KillLibRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KillLibRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KillLibRequest proto.InternalMessageInfo

func (m *KillLibRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *KillLibRequest) GetOptions() string {
	if m != nil {
		return m.Options
	}
	return ""
}

type KillLibResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KillLibResponse) Reset()         { *m = KillLibResponse{} }
func (m *KillLibResponse) String() string { return proto.CompactTextString(m) }
func (*KillLibResponse) ProtoMessage()    {}
func (*KillLibResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_413713bc60445121, []int{9}
}

func (m *KillLibResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KillLibResponse.Unmarshal(m, b)
}
func (m *KillLibResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KillLibResponse.Marshal(b, m, deterministic)
}
func (m *KillLibResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KillLibResponse.Merge(m, src)
}
func (m *KillLibResponse) XXX_Size() int {
	return xxx_messageInfo_KillLibResponse.Size(m)
}
func (m *KillLibResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KillLibResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KillLibResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("chromiumos.test.api.GetLibFailure_Reason", GetLibFailure_Reason_name, GetLibFailure_Reason_value)
	proto.RegisterEnum("chromiumos.test.api.RunLibCmdFailure_Reason", RunLibCmdFailure_Reason_name, RunLibCmdFailure_Reason_value)
	proto.RegisterType((*GetLibSuccess)(nil), "chromiumos.test.api.GetLibSuccess")
	proto.RegisterType((*GetLibFailure)(nil), "chromiumos.test.api.GetLibFailure")
	proto.RegisterType((*GetLibRequest)(nil), "chromiumos.test.api.GetLibRequest")
	proto.RegisterType((*GetLibResponse)(nil), "chromiumos.test.api.GetLibResponse")
	proto.RegisterType((*RunLibCmdSuccess)(nil), "chromiumos.test.api.RunLibCmdSuccess")
	proto.RegisterType((*RunLibCmdFailure)(nil), "chromiumos.test.api.RunLibCmdFailure")
	proto.RegisterType((*RunLibCmdRequest)(nil), "chromiumos.test.api.RunLibCmdRequest")
	proto.RegisterType((*RunLibCmdResponse)(nil), "chromiumos.test.api.RunLibCmdResponse")
	proto.RegisterType((*KillLibRequest)(nil), "chromiumos.test.api.KillLibRequest")
	proto.RegisterType((*KillLibResponse)(nil), "chromiumos.test.api.KillLibResponse")
}

func init() {
	proto.RegisterFile("chromiumos/test/api/test_libs_service.proto", fileDescriptor_413713bc60445121)
}

var fileDescriptor_413713bc60445121 = []byte{
	// 611 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xdd, 0x6e, 0x94, 0x40,
	0x14, 0xc7, 0x0b, 0xdb, 0xec, 0xda, 0xa3, 0x6e, 0xe9, 0x68, 0xea, 0xa6, 0x9a, 0xd8, 0xa0, 0x35,
	0x1a, 0x95, 0x4d, 0xea, 0x9d, 0x17, 0x26, 0xb4, 0xa5, 0x95, 0x74, 0x65, 0xe3, 0xc0, 0xda, 0x44,
	0x2f, 0x08, 0x1f, 0xd3, 0x75, 0x92, 0x85, 0x41, 0x06, 0xfa, 0x32, 0x3e, 0x84, 0x2f, 0xd0, 0x17,
	0xf2, 0x2d, 0x0c, 0x30, 0xac, 0x94, 0x10, 0xea, 0x85, 0x77, 0xf3, 0x71, 0xfe, 0x67, 0xce, 0xf9,
	0xff, 0x26, 0x07, 0x5e, 0x07, 0xdf, 0x53, 0x16, 0xd1, 0x3c, 0x62, 0x7c, 0x9a, 0x11, 0x9e, 0x4d,
	0xbd, 0x84, 0x96, 0x0b, 0x77, 0x45, 0x7d, 0xee, 0x72, 0x92, 0x5e, 0xd1, 0x80, 0x68, 0x49, 0xca,
	0x32, 0x86, 0x1e, 0xfc, 0x0d, 0xd6, 0x8a, 0x18, 0xcd, 0x4b, 0xa8, 0xfa, 0x14, 0xee, 0x9f, 0x91,
	0x6c, 0x46, 0x7d, 0x3b, 0x0f, 0x02, 0xc2, 0x39, 0x1a, 0x83, 0x4c, 0xc3, 0x89, 0xb4, 0x2f, 0xbd,
	0xdc, 0xc2, 0x32, 0x0d, 0xd5, 0x5f, 0x52, 0x1d, 0x71, 0xea, 0xd1, 0x55, 0x9e, 0x12, 0xa4, 0xc3,
	0x30, 0x25, 0x1e, 0x67, 0x71, 0x19, 0x35, 0x3e, 0x7c, 0xa5, 0x75, 0x24, 0xd6, 0x6e, 0x68, 0x34,
	0x5c, 0x0a, 0xb0, 0x10, 0xaa, 0xdf, 0x60, 0x58, 0x9d, 0xa0, 0xc7, 0xf0, 0x08, 0x1b, 0xba, 0x3d,
	0xb7, 0xdc, 0x85, 0x85, 0x8d, 0x33, 0xd3, 0x76, 0x0c, 0x6c, 0x9c, 0xb8, 0x33, 0xf3, 0x48, 0xd9,
	0x40, 0xfb, 0xf0, 0x44, 0x5c, 0x1e, 0xcf, 0x2d, 0x47, 0x37, 0x2d, 0x03, 0xbb, 0xb6, 0xa3, 0x63,
	0xc7, 0x35, 0x30, 0x9e, 0x63, 0x45, 0x42, 0x08, 0xc6, 0x6b, 0xf9, 0xb9, 0x35, 0xbf, 0xb0, 0x14,
	0x59, 0xbd, 0xa8, 0x0b, 0xc6, 0xe4, 0x47, 0x4e, 0x78, 0x86, 0x10, 0x6c, 0xc6, 0x5e, 0x44, 0x44,
	0x53, 0xe5, 0x1a, 0x4d, 0x60, 0x74, 0x45, 0x52, 0x4e, 0x59, 0x3c, 0x91, 0xcb, 0xe3, 0x7a, 0x5b,
	0xdc, 0xb0, 0x24, 0xa3, 0x2c, 0xe6, 0x93, 0xc1, 0xfe, 0xa0, 0xb8, 0x11, 0x5b, 0xf5, 0xa7, 0x04,
	0xe3, 0x3a, 0x33, 0x4f, 0x58, 0xcc, 0x09, 0xfa, 0x00, 0x23, 0x5e, 0x19, 0x57, 0x66, 0xbf, 0x7b,
	0xa8, 0xf6, 0x98, 0x21, 0x2c, 0xfe, 0xb8, 0x81, 0x6b, 0x51, 0xa1, 0xbf, 0xac, 0x2c, 0x2a, 0xcb,
	0xe8, 0xd7, 0x0b, 0x33, 0x0b, 0xbd, 0x10, 0x1d, 0x6d, 0xc1, 0x88, 0xe5, 0x59, 0xc0, 0x22, 0xa2,
	0x22, 0x50, 0x70, 0x1e, 0xcf, 0xa8, 0x7f, 0x1c, 0x85, 0xe2, 0x25, 0xf5, 0x5a, 0x6a, 0x1c, 0xd6,
	0xfc, 0x4e, 0x5a, 0xfc, 0xde, 0x74, 0x3e, 0xd9, 0x96, 0xb5, 0x11, 0xfa, 0x6b, 0x84, 0x7b, 0xb0,
	0x2b, 0x18, 0x98, 0xd6, 0x17, 0x7d, 0x66, 0x9e, 0xb8, 0xd8, 0xf8, 0xbc, 0x30, 0x6c, 0x47, 0xd9,
	0x40, 0x0f, 0x41, 0x11, 0x77, 0x78, 0x61, 0x75, 0x50, 0x73, 0xcc, 0x4f, 0xc6, 0x7c, 0xe1, 0x28,
	0x72, 0x07, 0xc9, 0x81, 0xea, 0x37, 0xaa, 0xaf, 0x61, 0xb6, 0xfe, 0x27, 0x52, 0x60, 0x10, 0x44,
	0xa1, 0x80, 0x58, 0x2c, 0x0b, 0xdc, 0x5e, 0xba, 0x2c, 0xe8, 0x95, 0xb8, 0x8b, 0x75, 0x13, 0xea,
	0x66, 0x85, 0xbb, 0x86, 0x7a, 0x2d, 0xc1, 0x4e, 0xe3, 0x11, 0xc1, 0x55, 0x6f, 0x73, 0x3d, 0xe8,
	0x37, 0xa9, 0x03, 0xad, 0xde, 0x46, 0x7b, 0xf0, 0x4f, 0x3e, 0x37, 0xe8, 0xa2, 0x5d, 0x18, 0xb2,
	0x3c, 0x4b, 0xf2, 0xac, 0xec, 0xe5, 0x1e, 0x16, 0xbb, 0x26, 0xf5, 0xf7, 0x30, 0x3e, 0xa7, 0xab,
	0x55, 0xe3, 0xb7, 0xb7, 0x0d, 0x6a, 0xb4, 0x2e, 0xdf, 0x6c, 0x7d, 0x07, 0xb6, 0xd7, 0xda, 0xaa,
	0xef, 0xc3, 0xdf, 0x32, 0x6c, 0x3b, 0x84, 0x17, 0xbf, 0x8d, 0xdb, 0xd5, 0xf4, 0x40, 0x36, 0xdc,
	0xb1, 0x33, 0x2f, 0x2d, 0xce, 0x50, 0xdf, 0xf7, 0x14, 0x05, 0xec, 0x3d, 0xeb, 0x8d, 0x11, 0x06,
	0x63, 0x18, 0x9d, 0xd2, 0x38, 0xfc, 0xaf, 0x39, 0x2f, 0x60, 0x88, 0xf3, 0xf8, 0x38, 0x0a, 0xd1,
	0x2d, 0x56, 0xd7, 0x59, 0x5f, 0xdc, 0x16, 0x26, 0x12, 0x3b, 0x30, 0x12, 0x46, 0xa1, 0xee, 0x42,
	0x6e, 0x22, 0xd8, 0x7b, 0xde, 0x1f, 0x54, 0x65, 0x3d, 0x9a, 0x7e, 0x7d, 0xbb, 0x64, 0xeb, 0x48,
	0x8d, 0xa5, 0xcb, 0x69, 0x63, 0x9c, 0x07, 0x2c, 0xbe, 0xa4, 0xcb, 0xe9, 0x92, 0xad, 0x07, 0xbb,
	0x3f, 0x2c, 0xe7, 0xf8, 0xbb, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x70, 0x94, 0xe9, 0xcf, 0xf6,
	0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TestLibsServiceClient is the client API for TestLibsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TestLibsServiceClient interface {
	// StartLib starts a new docker container running for the given library.
	StartLib(ctx context.Context, in *GetLibRequest, opts ...grpc.CallOption) (*GetLibResponse, error)
	// FindLib connects to an existing docker container (or starts one if no match
	// is found).
	FindLib(ctx context.Context, in *GetLibRequest, opts ...grpc.CallOption) (*GetLibResponse, error)
	// RunCmd executes a command on a running library's docker container.
	RunCmd(ctx context.Context, in *RunLibCmdRequest, opts ...grpc.CallOption) (*RunLibCmdResponse, error)
	// KillLib closes a running docker container.
	KillLib(ctx context.Context, in *KillLibRequest, opts ...grpc.CallOption) (*KillLibResponse, error)
}

type testLibsServiceClient struct {
	cc *grpc.ClientConn
}

func NewTestLibsServiceClient(cc *grpc.ClientConn) TestLibsServiceClient {
	return &testLibsServiceClient{cc}
}

func (c *testLibsServiceClient) StartLib(ctx context.Context, in *GetLibRequest, opts ...grpc.CallOption) (*GetLibResponse, error) {
	out := new(GetLibResponse)
	err := c.cc.Invoke(ctx, "/chromiumos.test.api.TestLibsService/StartLib", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testLibsServiceClient) FindLib(ctx context.Context, in *GetLibRequest, opts ...grpc.CallOption) (*GetLibResponse, error) {
	out := new(GetLibResponse)
	err := c.cc.Invoke(ctx, "/chromiumos.test.api.TestLibsService/FindLib", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testLibsServiceClient) RunCmd(ctx context.Context, in *RunLibCmdRequest, opts ...grpc.CallOption) (*RunLibCmdResponse, error) {
	out := new(RunLibCmdResponse)
	err := c.cc.Invoke(ctx, "/chromiumos.test.api.TestLibsService/RunCmd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *testLibsServiceClient) KillLib(ctx context.Context, in *KillLibRequest, opts ...grpc.CallOption) (*KillLibResponse, error) {
	out := new(KillLibResponse)
	err := c.cc.Invoke(ctx, "/chromiumos.test.api.TestLibsService/KillLib", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TestLibsServiceServer is the server API for TestLibsService service.
type TestLibsServiceServer interface {
	// StartLib starts a new docker container running for the given library.
	StartLib(context.Context, *GetLibRequest) (*GetLibResponse, error)
	// FindLib connects to an existing docker container (or starts one if no match
	// is found).
	FindLib(context.Context, *GetLibRequest) (*GetLibResponse, error)
	// RunCmd executes a command on a running library's docker container.
	RunCmd(context.Context, *RunLibCmdRequest) (*RunLibCmdResponse, error)
	// KillLib closes a running docker container.
	KillLib(context.Context, *KillLibRequest) (*KillLibResponse, error)
}

// UnimplementedTestLibsServiceServer can be embedded to have forward compatible implementations.
type UnimplementedTestLibsServiceServer struct {
}

func (*UnimplementedTestLibsServiceServer) StartLib(ctx context.Context, req *GetLibRequest) (*GetLibResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartLib not implemented")
}
func (*UnimplementedTestLibsServiceServer) FindLib(ctx context.Context, req *GetLibRequest) (*GetLibResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindLib not implemented")
}
func (*UnimplementedTestLibsServiceServer) RunCmd(ctx context.Context, req *RunLibCmdRequest) (*RunLibCmdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCmd not implemented")
}
func (*UnimplementedTestLibsServiceServer) KillLib(ctx context.Context, req *KillLibRequest) (*KillLibResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KillLib not implemented")
}

func RegisterTestLibsServiceServer(s *grpc.Server, srv TestLibsServiceServer) {
	s.RegisterService(&_TestLibsService_serviceDesc, srv)
}

func _TestLibsService_StartLib_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLibRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestLibsServiceServer).StartLib(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chromiumos.test.api.TestLibsService/StartLib",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestLibsServiceServer).StartLib(ctx, req.(*GetLibRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestLibsService_FindLib_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLibRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestLibsServiceServer).FindLib(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chromiumos.test.api.TestLibsService/FindLib",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestLibsServiceServer).FindLib(ctx, req.(*GetLibRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestLibsService_RunCmd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunLibCmdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestLibsServiceServer).RunCmd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chromiumos.test.api.TestLibsService/RunCmd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestLibsServiceServer).RunCmd(ctx, req.(*RunLibCmdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TestLibsService_KillLib_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KillLibRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TestLibsServiceServer).KillLib(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chromiumos.test.api.TestLibsService/KillLib",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TestLibsServiceServer).KillLib(ctx, req.(*KillLibRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TestLibsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chromiumos.test.api.TestLibsService",
	HandlerType: (*TestLibsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartLib",
			Handler:    _TestLibsService_StartLib_Handler,
		},
		{
			MethodName: "FindLib",
			Handler:    _TestLibsService_FindLib_Handler,
		},
		{
			MethodName: "RunCmd",
			Handler:    _TestLibsService_RunCmd_Handler,
		},
		{
			MethodName: "KillLib",
			Handler:    _TestLibsService_KillLib_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "chromiumos/test/api/test_libs_service.proto",
}
