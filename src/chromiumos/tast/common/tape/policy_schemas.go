// Copyright 2021 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Code generated by generate_policy_schemas.py. DO NOT EDIT.
// Edit the generator in gen/generate_policy_schemas.py instead.

package tape

import (
	"encoding/json"
	"fmt"

	"chromiumos/tast/errors"
)

///////////////////////////////////////////////////////////////////////////////
// AllowForUsers
///////////////////////////////////////////////////////////////////////////////

type AllowForUsers struct {
	allowForUsers bool
}

func (p *AllowForUsers) SetValues(allowForUsers bool) {
	p.allowForUsers = allowForUsers
}

func (p *AllowForUsers) Link() string { return "chrome.printers.AllowForUsers" }
func (p *AllowForUsers) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.allowForUsers)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.printers.AllowForUsers",
				"value":{
					"allowForUsers":%s
				}
			},
			"updateMask":{
				"paths":["allowForUsers"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AllowForDevices
///////////////////////////////////////////////////////////////////////////////

type AllowForDevices struct {
	allowForDevices bool
}

func (p *AllowForDevices) SetValues(allowForDevices bool) {
	p.allowForDevices = allowForDevices
}

func (p *AllowForDevices) Link() string { return "chrome.printers.AllowForDevices" }
func (p *AllowForDevices) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.allowForDevices)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.printers.AllowForDevices",
				"value":{
					"allowForDevices":%s
				}
			},
			"updateMask":{
				"paths":["allowForDevices"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AllowForManagedGuest
///////////////////////////////////////////////////////////////////////////////

type AllowForManagedGuest struct {
	allowForManagedGuest bool
}

func (p *AllowForManagedGuest) SetValues(allowForManagedGuest bool) {
	p.allowForManagedGuest = allowForManagedGuest
}

func (p *AllowForManagedGuest) Link() string { return "chrome.printers.AllowForManagedGuest" }
func (p *AllowForManagedGuest) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.allowForManagedGuest)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.printers.AllowForManagedGuest",
				"value":{
					"allowForManagedGuest":%s
				}
			},
			"updateMask":{
				"paths":["allowForManagedGuest"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SessionLength
///////////////////////////////////////////////////////////////////////////////

type SessionLength struct {
	sessionDurationLimit NullableDuration
}

func (p *SessionLength) SetValues(sessionDurationLimit NullableDuration) {
	p.sessionDurationLimit = sessionDurationLimit
}

type NullableDuration struct {
	duration Duration
}

func (p *NullableDuration) SetValues(duration Duration) {
	p.duration = duration
}

type Duration struct {
	seconds int64
	nanos   int
}

func (p *Duration) SetValues(seconds int64, nanos int) {
	p.seconds = seconds
	p.nanos = nanos
}

func (p *SessionLength) Link() string { return "chrome.users.SessionLength" }
func (p *SessionLength) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.sessionDurationLimit)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SessionLength",
				"value":{
					"sessionDurationLimit":%s
				}
			},
			"updateMask":{
				"paths":["sessionDurationLimit"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// Avatar
///////////////////////////////////////////////////////////////////////////////

type Avatar struct {
	userAvatarImage UploadedFile
}

func (p *Avatar) SetValues(userAvatarImage UploadedFile) {
	p.userAvatarImage = userAvatarImage
}

type UploadedFile struct {
	downloadUri string
}

func (p *UploadedFile) SetValues(downloadUri string) {
	p.downloadUri = downloadUri
}

func (p *Avatar) Link() string { return "chrome.users.Avatar" }
func (p *Avatar) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.userAvatarImage)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.Avatar",
				"value":{
					"userAvatarImage":%s
				}
			},
			"updateMask":{
				"paths":["userAvatarImage"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// Wallpaper
///////////////////////////////////////////////////////////////////////////////

type Wallpaper struct {
	wallpaperImage UploadedFile
}

func (p *Wallpaper) SetValues(wallpaperImage UploadedFile) {
	p.wallpaperImage = wallpaperImage
}

func (p *Wallpaper) Link() string { return "chrome.users.Wallpaper" }
func (p *Wallpaper) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.wallpaperImage)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.Wallpaper",
				"value":{
					"wallpaperImage":%s
				}
			},
			"updateMask":{
				"paths":["wallpaperImage"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// BrowserSignin
///////////////////////////////////////////////////////////////////////////////

type BrowserSignin struct {
	browserSignin BrowserSigninModeEnum
}

func (p *BrowserSignin) SetValues(browserSignin BrowserSigninModeEnum) {
	p.browserSignin = browserSignin
}

type BrowserSigninModeEnum int

const (
	BROWSER_SIGNIN_MODE_ENUM_UNSPECIFIED BrowserSigninModeEnum = iota // 0
	BROWSER_SIGNIN_MODE_ENUM_DISABLE                                  // 1
	BROWSER_SIGNIN_MODE_ENUM_ENABLE                                   // 2
	BROWSER_SIGNIN_MODE_ENUM_FORCE                                    // 3
)

func (p *BrowserSignin) Link() string { return "chrome.users.BrowserSignin" }
func (p *BrowserSignin) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.browserSignin)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.BrowserSignin",
				"value":{
					"browserSignin":%s
				}
			},
			"updateMask":{
				"paths":["browserSignin"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// RestrictSigninToPattern
///////////////////////////////////////////////////////////////////////////////

type RestrictSigninToPattern struct {
	restrictSigninToPattern string
}

func (p *RestrictSigninToPattern) SetValues(restrictSigninToPattern string) {
	p.restrictSigninToPattern = restrictSigninToPattern
}

func (p *RestrictSigninToPattern) Link() string { return "chrome.users.RestrictSigninToPattern" }
func (p *RestrictSigninToPattern) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.restrictSigninToPattern)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.RestrictSigninToPattern",
				"value":{
					"restrictSigninToPattern":%s
				}
			},
			"updateMask":{
				"paths":["restrictSigninToPattern"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SigninInterceptionEnabled
///////////////////////////////////////////////////////////////////////////////

type SigninInterceptionEnabled struct {
	signinInterceptionEnabled bool
}

func (p *SigninInterceptionEnabled) SetValues(signinInterceptionEnabled bool) {
	p.signinInterceptionEnabled = signinInterceptionEnabled
}

func (p *SigninInterceptionEnabled) Link() string { return "chrome.users.SigninInterceptionEnabled" }
func (p *SigninInterceptionEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.signinInterceptionEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SigninInterceptionEnabled",
				"value":{
					"signinInterceptionEnabled":%s
				}
			},
			"updateMask":{
				"paths":["signinInterceptionEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// LoginDisplayPasswordButtonEnabled
///////////////////////////////////////////////////////////////////////////////

type LoginDisplayPasswordButtonEnabled struct {
	loginDisplayPasswordButtonEnabled bool
}

func (p *LoginDisplayPasswordButtonEnabled) SetValues(loginDisplayPasswordButtonEnabled bool) {
	p.loginDisplayPasswordButtonEnabled = loginDisplayPasswordButtonEnabled
}

func (p *LoginDisplayPasswordButtonEnabled) Link() string {
	return "chrome.users.LoginDisplayPasswordButtonEnabled"
}
func (p *LoginDisplayPasswordButtonEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.loginDisplayPasswordButtonEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.LoginDisplayPasswordButtonEnabled",
				"value":{
					"loginDisplayPasswordButtonEnabled":%s
				}
			},
			"updateMask":{
				"paths":["loginDisplayPasswordButtonEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// MobileManagement
///////////////////////////////////////////////////////////////////////////////

type MobileManagement struct {
	enableMobileChromePolicies bool
}

func (p *MobileManagement) SetValues(enableMobileChromePolicies bool) {
	p.enableMobileChromePolicies = enableMobileChromePolicies
}

func (p *MobileManagement) Link() string { return "chrome.users.MobileManagement" }
func (p *MobileManagement) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.enableMobileChromePolicies)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.MobileManagement",
				"value":{
					"enableMobileChromePolicies":%s
				}
			},
			"updateMask":{
				"paths":["enableMobileChromePolicies"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// DeviceEnrollment
///////////////////////////////////////////////////////////////////////////////

type DeviceEnrollment struct {
	autoDevicePlacementEnabled bool
}

func (p *DeviceEnrollment) SetValues(autoDevicePlacementEnabled bool) {
	p.autoDevicePlacementEnabled = autoDevicePlacementEnabled
}

func (p *DeviceEnrollment) Link() string { return "chrome.users.DeviceEnrollment" }
func (p *DeviceEnrollment) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.autoDevicePlacementEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.DeviceEnrollment",
				"value":{
					"autoDevicePlacementEnabled":%s
				}
			},
			"updateMask":{
				"paths":["autoDevicePlacementEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AllowPopulateAssetIdentifier
///////////////////////////////////////////////////////////////////////////////

type AllowPopulateAssetIdentifier struct {
	allowToUpdateDeviceAttribute bool
}

func (p *AllowPopulateAssetIdentifier) SetValues(allowToUpdateDeviceAttribute bool) {
	p.allowToUpdateDeviceAttribute = allowToUpdateDeviceAttribute
}

func (p *AllowPopulateAssetIdentifier) Link() string {
	return "chrome.users.AllowPopulateAssetIdentifier"
}
func (p *AllowPopulateAssetIdentifier) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.allowToUpdateDeviceAttribute)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AllowPopulateAssetIdentifier",
				"value":{
					"allowToUpdateDeviceAttribute":%s
				}
			},
			"updateMask":{
				"paths":["allowToUpdateDeviceAttribute"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// EnrollPermission
///////////////////////////////////////////////////////////////////////////////

type EnrollPermission struct {
	deviceEnrollPermission AllowToEnrollDevicesEnum
}

func (p *EnrollPermission) SetValues(deviceEnrollPermission AllowToEnrollDevicesEnum) {
	p.deviceEnrollPermission = deviceEnrollPermission
}

type AllowToEnrollDevicesEnum int

const (
	ALLOW_TO_ENROLL_DEVICES_ENUM_UNSPECIFIED               AllowToEnrollDevicesEnum = iota // 0
	ALLOW_TO_ENROLL_DEVICES_ENUM_ALLOW_ENROLL_RE_ENROLL                                    // 1
	ALLOW_TO_ENROLL_DEVICES_ENUM_ALLOW_RE_ENROLL                                           // 2
	ALLOW_TO_ENROLL_DEVICES_ENUM_DISALLOW_ENROLL_RE_ENROLL                                 // 3
)

func (p *EnrollPermission) Link() string { return "chrome.users.EnrollPermission" }
func (p *EnrollPermission) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.deviceEnrollPermission)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.EnrollPermission",
				"value":{
					"deviceEnrollPermission":%s
				}
			},
			"updateMask":{
				"paths":["deviceEnrollPermission"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// TaskManager
///////////////////////////////////////////////////////////////////////////////

type TaskManager struct {
	taskManagerEndProcessEnabled bool
}

func (p *TaskManager) SetValues(taskManagerEndProcessEnabled bool) {
	p.taskManagerEndProcessEnabled = taskManagerEndProcessEnabled
}

func (p *TaskManager) Link() string { return "chrome.users.TaskManager" }
func (p *TaskManager) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.taskManagerEndProcessEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.TaskManager",
				"value":{
					"taskManagerEndProcessEnabled":%s
				}
			},
			"updateMask":{
				"paths":["taskManagerEndProcessEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SiteIsolationBrowser
///////////////////////////////////////////////////////////////////////////////

type SiteIsolationBrowser struct {
	isolateOrigins []string
	sitePerProcess bool
}

func (p *SiteIsolationBrowser) SetValues(isolateOrigins []string, sitePerProcess bool) {
	p.isolateOrigins = isolateOrigins
	p.sitePerProcess = sitePerProcess
}

func (p *SiteIsolationBrowser) Link() string { return "chrome.users.SiteIsolationBrowser" }
func (p *SiteIsolationBrowser) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.isolateOrigins)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.sitePerProcess)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SiteIsolationBrowser",
				"value":{
					"isolateOrigins":%s,
					"sitePerProcess":%s
				}
			},
			"updateMask":{
				"paths":["isolateOrigins", "sitePerProcess"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SiteIsolationAndroid
///////////////////////////////////////////////////////////////////////////////

type SiteIsolationAndroid struct {
	sitePerProcessAndroid NullableBoolean
	isolateOriginsAndroid []string
}

func (p *SiteIsolationAndroid) SetValues(sitePerProcessAndroid NullableBoolean, isolateOriginsAndroid []string) {
	p.sitePerProcessAndroid = sitePerProcessAndroid
	p.isolateOriginsAndroid = isolateOriginsAndroid
}

type NullableBoolean int

const (
	NULLABLE_BOOLEAN_UNSPECIFIED NullableBoolean = iota // 0
	UNSET                                               // 1
	FALSE                                               // 2
	TRUE                                                // 3
)

func (p *SiteIsolationAndroid) Link() string { return "chrome.users.SiteIsolationAndroid" }
func (p *SiteIsolationAndroid) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.sitePerProcessAndroid)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.isolateOriginsAndroid)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SiteIsolationAndroid",
				"value":{
					"sitePerProcessAndroid":%s,
					"isolateOriginsAndroid":%s
				}
			},
			"updateMask":{
				"paths":["sitePerProcessAndroid", "isolateOriginsAndroid"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// PasswordManager
///////////////////////////////////////////////////////////////////////////////

type PasswordManager struct {
	passwordManagerEnabled NullableBoolean
}

func (p *PasswordManager) SetValues(passwordManagerEnabled NullableBoolean) {
	p.passwordManagerEnabled = passwordManagerEnabled
}

func (p *PasswordManager) Link() string { return "chrome.users.PasswordManager" }
func (p *PasswordManager) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.passwordManagerEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.PasswordManager",
				"value":{
					"passwordManagerEnabled":%s
				}
			},
			"updateMask":{
				"paths":["passwordManagerEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// LockScreen
///////////////////////////////////////////////////////////////////////////////

type LockScreen struct {
	allowScreenLock bool
}

func (p *LockScreen) SetValues(allowScreenLock bool) {
	p.allowScreenLock = allowScreenLock
}

func (p *LockScreen) Link() string { return "chrome.users.LockScreen" }
func (p *LockScreen) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.allowScreenLock)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.LockScreen",
				"value":{
					"allowScreenLock":%s
				}
			},
			"updateMask":{
				"paths":["allowScreenLock"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// QuickUnlockModeAllowlist
///////////////////////////////////////////////////////////////////////////////

type QuickUnlockModeAllowlist struct {
	quickUnlockModeAllowlist []string
}

func (p *QuickUnlockModeAllowlist) SetValues(quickUnlockModeAllowlist []string) {
	p.quickUnlockModeAllowlist = quickUnlockModeAllowlist
}

func (p *QuickUnlockModeAllowlist) Link() string { return "chrome.users.QuickUnlockModeAllowlist" }
func (p *QuickUnlockModeAllowlist) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.quickUnlockModeAllowlist)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.QuickUnlockModeAllowlist",
				"value":{
					"quickUnlockModeAllowlist":%s
				}
			},
			"updateMask":{
				"paths":["quickUnlockModeAllowlist"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// PinUnlockAutosubmitEnabled
///////////////////////////////////////////////////////////////////////////////

type PinUnlockAutosubmitEnabled struct {
	pinUnlockAutosubmitEnabled bool
}

func (p *PinUnlockAutosubmitEnabled) SetValues(pinUnlockAutosubmitEnabled bool) {
	p.pinUnlockAutosubmitEnabled = pinUnlockAutosubmitEnabled
}

func (p *PinUnlockAutosubmitEnabled) Link() string { return "chrome.users.PinUnlockAutosubmitEnabled" }
func (p *PinUnlockAutosubmitEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.pinUnlockAutosubmitEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.PinUnlockAutosubmitEnabled",
				"value":{
					"pinUnlockAutosubmitEnabled":%s
				}
			},
			"updateMask":{
				"paths":["pinUnlockAutosubmitEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// LockScreenMediaPlaybackEnabled
///////////////////////////////////////////////////////////////////////////////

type LockScreenMediaPlaybackEnabled struct {
	lockScreenMediaPlaybackEnabled bool
}

func (p *LockScreenMediaPlaybackEnabled) SetValues(lockScreenMediaPlaybackEnabled bool) {
	p.lockScreenMediaPlaybackEnabled = lockScreenMediaPlaybackEnabled
}

func (p *LockScreenMediaPlaybackEnabled) Link() string {
	return "chrome.users.LockScreenMediaPlaybackEnabled"
}
func (p *LockScreenMediaPlaybackEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.lockScreenMediaPlaybackEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.LockScreenMediaPlaybackEnabled",
				"value":{
					"lockScreenMediaPlaybackEnabled":%s
				}
			},
			"updateMask":{
				"paths":["lockScreenMediaPlaybackEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// IncognitoMode
///////////////////////////////////////////////////////////////////////////////

type IncognitoMode struct {
	incognitoModeAvailability IncognitoModeAvailabilityEnum
}

func (p *IncognitoMode) SetValues(incognitoModeAvailability IncognitoModeAvailabilityEnum) {
	p.incognitoModeAvailability = incognitoModeAvailability
}

type IncognitoModeAvailabilityEnum int

const (
	INCOGNITO_MODE_AVAILABILITY_ENUM_UNSPECIFIED IncognitoModeAvailabilityEnum = iota // 0
	INCOGNITO_MODE_AVAILABILITY_ENUM_AVAILABLE                                        // 1
	INCOGNITO_MODE_AVAILABILITY_ENUM_UNAVAILABLE                                      // 2
)

func (p *IncognitoMode) Link() string { return "chrome.users.IncognitoMode" }
func (p *IncognitoMode) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.incognitoModeAvailability)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.IncognitoMode",
				"value":{
					"incognitoModeAvailability":%s
				}
			},
			"updateMask":{
				"paths":["incognitoModeAvailability"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// BrowserHistory
///////////////////////////////////////////////////////////////////////////////

type BrowserHistory struct {
	savingBrowserHistoryDisabled bool
}

func (p *BrowserHistory) SetValues(savingBrowserHistoryDisabled bool) {
	p.savingBrowserHistoryDisabled = savingBrowserHistoryDisabled
}

func (p *BrowserHistory) Link() string { return "chrome.users.BrowserHistory" }
func (p *BrowserHistory) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.savingBrowserHistoryDisabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.BrowserHistory",
				"value":{
					"savingBrowserHistoryDisabled":%s
				}
			},
			"updateMask":{
				"paths":["savingBrowserHistoryDisabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// ClearBrowserHistory
///////////////////////////////////////////////////////////////////////////////

type ClearBrowserHistory struct {
	allowDeletingBrowserHistory bool
}

func (p *ClearBrowserHistory) SetValues(allowDeletingBrowserHistory bool) {
	p.allowDeletingBrowserHistory = allowDeletingBrowserHistory
}

func (p *ClearBrowserHistory) Link() string { return "chrome.users.ClearBrowserHistory" }
func (p *ClearBrowserHistory) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.allowDeletingBrowserHistory)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.ClearBrowserHistory",
				"value":{
					"allowDeletingBrowserHistory":%s
				}
			},
			"updateMask":{
				"paths":["allowDeletingBrowserHistory"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// ForceEphemeralMode
///////////////////////////////////////////////////////////////////////////////

type ForceEphemeralMode struct {
	forceEphemeralProfiles bool
}

func (p *ForceEphemeralMode) SetValues(forceEphemeralProfiles bool) {
	p.forceEphemeralProfiles = forceEphemeralProfiles
}

func (p *ForceEphemeralMode) Link() string { return "chrome.users.ForceEphemeralMode" }
func (p *ForceEphemeralMode) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.forceEphemeralProfiles)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.ForceEphemeralMode",
				"value":{
					"forceEphemeralProfiles":%s
				}
			},
			"updateMask":{
				"paths":["forceEphemeralProfiles"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// OnlineRevocationChecks
///////////////////////////////////////////////////////////////////////////////

type OnlineRevocationChecks struct {
	enableOnlineRevocationChecks bool
}

func (p *OnlineRevocationChecks) SetValues(enableOnlineRevocationChecks bool) {
	p.enableOnlineRevocationChecks = enableOnlineRevocationChecks
}

func (p *OnlineRevocationChecks) Link() string { return "chrome.users.OnlineRevocationChecks" }
func (p *OnlineRevocationChecks) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.enableOnlineRevocationChecks)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.OnlineRevocationChecks",
				"value":{
					"enableOnlineRevocationChecks":%s
				}
			},
			"updateMask":{
				"paths":["enableOnlineRevocationChecks"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// Geolocation
///////////////////////////////////////////////////////////////////////////////

type Geolocation struct {
	defaultGeolocationSetting GeolocationSettingEnum
}

func (p *Geolocation) SetValues(defaultGeolocationSetting GeolocationSettingEnum) {
	p.defaultGeolocationSetting = defaultGeolocationSetting
}

type GeolocationSettingEnum int

const (
	GEOLOCATION_SETTING_ENUM_UNSPECIFIED       GeolocationSettingEnum = iota // 0
	GEOLOCATION_SETTING_ENUM_ALLOW_GEOLOCATION                               // 1
	GEOLOCATION_SETTING_ENUM_BLOCK_GEOLOCATION                               // 2
	GEOLOCATION_SETTING_ENUM_ASK_GEOLOCATION                                 // 3
	GEOLOCATION_SETTING_ENUM_USER_CHOICE                                     // 4
)

func (p *Geolocation) Link() string { return "chrome.users.Geolocation" }
func (p *Geolocation) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.defaultGeolocationSetting)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.Geolocation",
				"value":{
					"defaultGeolocationSetting":%s
				}
			},
			"updateMask":{
				"paths":["defaultGeolocationSetting"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SingleSignOn
///////////////////////////////////////////////////////////////////////////////

type SingleSignOn struct {
	idpRedirectEnabled bool
}

func (p *SingleSignOn) SetValues(idpRedirectEnabled bool) {
	p.idpRedirectEnabled = idpRedirectEnabled
}

func (p *SingleSignOn) Link() string { return "chrome.users.SingleSignOn" }
func (p *SingleSignOn) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.idpRedirectEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SingleSignOn",
				"value":{
					"idpRedirectEnabled":%s
				}
			},
			"updateMask":{
				"paths":["idpRedirectEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SingleSignOnLoginFrequency
///////////////////////////////////////////////////////////////////////////////

type SingleSignOnLoginFrequency struct {
	samlOfflineSigninTimeLimit SamlSigninTimeLimitEnum
}

func (p *SingleSignOnLoginFrequency) SetValues(samlOfflineSigninTimeLimit SamlSigninTimeLimitEnum) {
	p.samlOfflineSigninTimeLimit = samlOfflineSigninTimeLimit
}

type SamlSigninTimeLimitEnum int

const (
	SAML_SIGNIN_TIME_LIMIT_ENUM_UNSPECIFIED      SamlSigninTimeLimitEnum = iota // 0
	SAML_SIGNIN_TIME_LIMIT_ENUM_SAML_ONE_DAY                                    // 1
	SAML_SIGNIN_TIME_LIMIT_ENUM_SAML_THREE_DAYS                                 // 2
	SAML_SIGNIN_TIME_LIMIT_ENUM_SAML_ONE_WEEK                                   // 3
	SAML_SIGNIN_TIME_LIMIT_ENUM_SAML_TWO_WEEKS                                  // 4
	SAML_SIGNIN_TIME_LIMIT_ENUM_SAML_THREE_WEEKS                                // 5
	SAML_SIGNIN_TIME_LIMIT_ENUM_SAML_FOUR_WEEKS                                 // 6
	SAML_SIGNIN_TIME_LIMIT_ENUM_EVERY_TIME                                      // 7
	SAML_SIGNIN_TIME_LIMIT_ENUM_SAML_NEVER                                      // 8
)

func (p *SingleSignOnLoginFrequency) Link() string { return "chrome.users.SingleSignOnLoginFrequency" }
func (p *SingleSignOnLoginFrequency) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.samlOfflineSigninTimeLimit)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SingleSignOnLoginFrequency",
				"value":{
					"samlOfflineSigninTimeLimit":%s
				}
			},
			"updateMask":{
				"paths":["samlOfflineSigninTimeLimit"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// CertificateTransparencyEnforcementDisabledForUrls
///////////////////////////////////////////////////////////////////////////////

type CertificateTransparencyEnforcementDisabledForUrls struct {
	certificateTransparencyEnforcementDisabledForUrls []string
}

func (p *CertificateTransparencyEnforcementDisabledForUrls) SetValues(certificateTransparencyEnforcementDisabledForUrls []string) {
	p.certificateTransparencyEnforcementDisabledForUrls = certificateTransparencyEnforcementDisabledForUrls
}

func (p *CertificateTransparencyEnforcementDisabledForUrls) Link() string {
	return "chrome.users.CertificateTransparencyEnforcementDisabledForUrls"
}
func (p *CertificateTransparencyEnforcementDisabledForUrls) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.certificateTransparencyEnforcementDisabledForUrls)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.CertificateTransparencyEnforcementDisabledForUrls",
				"value":{
					"certificateTransparencyEnforcementDisabledForUrls":%s
				}
			},
			"updateMask":{
				"paths":["certificateTransparencyEnforcementDisabledForUrls"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// CertTransparencyCas
///////////////////////////////////////////////////////////////////////////////

type CertTransparencyCas struct {
	certificateTransparencyEnforcementDisabledForCas []string
}

func (p *CertTransparencyCas) SetValues(certificateTransparencyEnforcementDisabledForCas []string) {
	p.certificateTransparencyEnforcementDisabledForCas = certificateTransparencyEnforcementDisabledForCas
}

func (p *CertTransparencyCas) Link() string { return "chrome.users.CertTransparencyCas" }
func (p *CertTransparencyCas) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.certificateTransparencyEnforcementDisabledForCas)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.CertTransparencyCas",
				"value":{
					"certificateTransparencyEnforcementDisabledForCas":%s
				}
			},
			"updateMask":{
				"paths":["certificateTransparencyEnforcementDisabledForCas"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// CertTransparencyLegacyCas
///////////////////////////////////////////////////////////////////////////////

type CertTransparencyLegacyCas struct {
	certificateTransparencyEnforcementDisabledForLegacyCas []string
}

func (p *CertTransparencyLegacyCas) SetValues(certificateTransparencyEnforcementDisabledForLegacyCas []string) {
	p.certificateTransparencyEnforcementDisabledForLegacyCas = certificateTransparencyEnforcementDisabledForLegacyCas
}

func (p *CertTransparencyLegacyCas) Link() string { return "chrome.users.CertTransparencyLegacyCas" }
func (p *CertTransparencyLegacyCas) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.certificateTransparencyEnforcementDisabledForLegacyCas)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.CertTransparencyLegacyCas",
				"value":{
					"certificateTransparencyEnforcementDisabledForLegacyCas":%s
				}
			},
			"updateMask":{
				"paths":["certificateTransparencyEnforcementDisabledForLegacyCas"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// CaCertificateManagementAllowed
///////////////////////////////////////////////////////////////////////////////

type CaCertificateManagementAllowed struct {
	caCertificateManagementAllowed CACertificateManagementAllowedEnum
}

func (p *CaCertificateManagementAllowed) SetValues(caCertificateManagementAllowed CACertificateManagementAllowedEnum) {
	p.caCertificateManagementAllowed = caCertificateManagementAllowed
}

type CACertificateManagementAllowedEnum int

const (
	CA_CERTIFICATE_MANAGEMENT_ALLOWED_ENUM_UNSPECIFIED CACertificateManagementAllowedEnum = iota // 0
	CA_CERTIFICATE_MANAGEMENT_ALLOWED_ENUM_ALL                                                   // 1
	CA_CERTIFICATE_MANAGEMENT_ALLOWED_ENUM_USER_ONLY                                             // 2
	CA_CERTIFICATE_MANAGEMENT_ALLOWED_ENUM_NONE                                                  // 3
)

func (p *CaCertificateManagementAllowed) Link() string {
	return "chrome.users.CaCertificateManagementAllowed"
}
func (p *CaCertificateManagementAllowed) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.caCertificateManagementAllowed)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.CaCertificateManagementAllowed",
				"value":{
					"caCertificateManagementAllowed":%s
				}
			},
			"updateMask":{
				"paths":["caCertificateManagementAllowed"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// ClientCertificateManagementAllowed
///////////////////////////////////////////////////////////////////////////////

type ClientCertificateManagementAllowed struct {
	clientCertificateManagementAllowed ClientCertificateManagementAllowedEnum
}

func (p *ClientCertificateManagementAllowed) SetValues(clientCertificateManagementAllowed ClientCertificateManagementAllowedEnum) {
	p.clientCertificateManagementAllowed = clientCertificateManagementAllowed
}

type ClientCertificateManagementAllowedEnum int

const (
	CLIENT_CERTIFICATE_MANAGEMENT_ALLOWED_ENUM_UNSPECIFIED ClientCertificateManagementAllowedEnum = iota // 0
	CLIENT_CERTIFICATE_MANAGEMENT_ALLOWED_ENUM_ALL                                                       // 1
	CLIENT_CERTIFICATE_MANAGEMENT_ALLOWED_ENUM_USER_ONLY                                                 // 2
	CLIENT_CERTIFICATE_MANAGEMENT_ALLOWED_ENUM_NONE                                                      // 3
)

func (p *ClientCertificateManagementAllowed) Link() string {
	return "chrome.users.ClientCertificateManagementAllowed"
}
func (p *ClientCertificateManagementAllowed) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.clientCertificateManagementAllowed)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.ClientCertificateManagementAllowed",
				"value":{
					"clientCertificateManagementAllowed":%s
				}
			},
			"updateMask":{
				"paths":["clientCertificateManagementAllowed"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// CpuTaskScheduler
///////////////////////////////////////////////////////////////////////////////

type CpuTaskScheduler struct {
	schedulerConfiguration SchedulerConfigurationEnum
}

func (p *CpuTaskScheduler) SetValues(schedulerConfiguration SchedulerConfigurationEnum) {
	p.schedulerConfiguration = schedulerConfiguration
}

type SchedulerConfigurationEnum int

const (
	SCHEDULER_CONFIGURATION_ENUM_UNSPECIFIED  SchedulerConfigurationEnum = iota // 0
	SCHEDULER_CONFIGURATION_ENUM_USER_CHOICE                                    // 1
	SCHEDULER_CONFIGURATION_ENUM_CONSERVATIVE                                   // 2
	SCHEDULER_CONFIGURATION_ENUM_PERFORMANCE                                    // 3
)

func (p *CpuTaskScheduler) Link() string { return "chrome.users.CpuTaskScheduler" }
func (p *CpuTaskScheduler) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.schedulerConfiguration)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.CpuTaskScheduler",
				"value":{
					"schedulerConfiguration":%s
				}
			},
			"updateMask":{
				"paths":["schedulerConfiguration"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// RendererCodeIntegrityEnabled
///////////////////////////////////////////////////////////////////////////////

type RendererCodeIntegrityEnabled struct {
	rendererCodeIntegrityEnabled bool
}

func (p *RendererCodeIntegrityEnabled) SetValues(rendererCodeIntegrityEnabled bool) {
	p.rendererCodeIntegrityEnabled = rendererCodeIntegrityEnabled
}

func (p *RendererCodeIntegrityEnabled) Link() string {
	return "chrome.users.RendererCodeIntegrityEnabled"
}
func (p *RendererCodeIntegrityEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.rendererCodeIntegrityEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.RendererCodeIntegrityEnabled",
				"value":{
					"rendererCodeIntegrityEnabled":%s
				}
			},
			"updateMask":{
				"paths":["rendererCodeIntegrityEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// PasswordLeakDetection
///////////////////////////////////////////////////////////////////////////////

type PasswordLeakDetection struct {
	passwordLeakDetection NullableBoolean
}

func (p *PasswordLeakDetection) SetValues(passwordLeakDetection NullableBoolean) {
	p.passwordLeakDetection = passwordLeakDetection
}

func (p *PasswordLeakDetection) Link() string { return "chrome.users.PasswordLeakDetection" }
func (p *PasswordLeakDetection) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.passwordLeakDetection)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.PasswordLeakDetection",
				"value":{
					"passwordLeakDetection":%s
				}
			},
			"updateMask":{
				"paths":["passwordLeakDetection"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AmbientAuthenticationInPrivateModesEnabled
///////////////////////////////////////////////////////////////////////////////

type AmbientAuthenticationInPrivateModesEnabled struct {
	ambientAuthenticationInPrivateModesEnabled AmbientAuthenticationInPrivateModesEnabledEnum
}

func (p *AmbientAuthenticationInPrivateModesEnabled) SetValues(ambientAuthenticationInPrivateModesEnabled AmbientAuthenticationInPrivateModesEnabledEnum) {
	p.ambientAuthenticationInPrivateModesEnabled = ambientAuthenticationInPrivateModesEnabled
}

type AmbientAuthenticationInPrivateModesEnabledEnum int

const (
	AMBIENT_AUTHENTICATION_IN_PRIVATE_MODES_ENABLED_ENUM_UNSPECIFIED           AmbientAuthenticationInPrivateModesEnabledEnum = iota // 0
	AMBIENT_AUTHENTICATION_IN_PRIVATE_MODES_ENABLED_ENUM_UNSET                                                                       // 1
	AMBIENT_AUTHENTICATION_IN_PRIVATE_MODES_ENABLED_ENUM_REGULAR_ONLY                                                                // 2
	AMBIENT_AUTHENTICATION_IN_PRIVATE_MODES_ENABLED_ENUM_INCOGNITO_AND_REGULAR                                                       // 3
	AMBIENT_AUTHENTICATION_IN_PRIVATE_MODES_ENABLED_ENUM_GUEST_AND_REGULAR                                                           // 4
	AMBIENT_AUTHENTICATION_IN_PRIVATE_MODES_ENABLED_ENUM_ALL                                                                         // 5
)

func (p *AmbientAuthenticationInPrivateModesEnabled) Link() string {
	return "chrome.users.AmbientAuthenticationInPrivateModesEnabled"
}
func (p *AmbientAuthenticationInPrivateModesEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.ambientAuthenticationInPrivateModesEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AmbientAuthenticationInPrivateModesEnabled",
				"value":{
					"ambientAuthenticationInPrivateModesEnabled":%s
				}
			},
			"updateMask":{
				"paths":["ambientAuthenticationInPrivateModesEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// ChromeCleanupEnabled
///////////////////////////////////////////////////////////////////////////////

type ChromeCleanupEnabled struct {
	chromeCleanupEnabled          bool
	chromeCleanupReportingEnabled NullableBoolean
}

func (p *ChromeCleanupEnabled) SetValues(chromeCleanupEnabled bool, chromeCleanupReportingEnabled NullableBoolean) {
	p.chromeCleanupEnabled = chromeCleanupEnabled
	p.chromeCleanupReportingEnabled = chromeCleanupReportingEnabled
}

func (p *ChromeCleanupEnabled) Link() string { return "chrome.users.ChromeCleanupEnabled" }
func (p *ChromeCleanupEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.chromeCleanupEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.chromeCleanupReportingEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.ChromeCleanupEnabled",
				"value":{
					"chromeCleanupEnabled":%s,
					"chromeCleanupReportingEnabled":%s
				}
			},
			"updateMask":{
				"paths":["chromeCleanupEnabled", "chromeCleanupReportingEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// ThirdPartyBlockingEnabled
///////////////////////////////////////////////////////////////////////////////

type ThirdPartyBlockingEnabled struct {
	thirdPartyBlockingEnabled bool
}

func (p *ThirdPartyBlockingEnabled) SetValues(thirdPartyBlockingEnabled bool) {
	p.thirdPartyBlockingEnabled = thirdPartyBlockingEnabled
}

func (p *ThirdPartyBlockingEnabled) Link() string { return "chrome.users.ThirdPartyBlockingEnabled" }
func (p *ThirdPartyBlockingEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.thirdPartyBlockingEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.ThirdPartyBlockingEnabled",
				"value":{
					"thirdPartyBlockingEnabled":%s
				}
			},
			"updateMask":{
				"paths":["thirdPartyBlockingEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AudioSandboxEnabled
///////////////////////////////////////////////////////////////////////////////

type AudioSandboxEnabled struct {
	audioSandboxEnabled NullableBoolean
}

func (p *AudioSandboxEnabled) SetValues(audioSandboxEnabled NullableBoolean) {
	p.audioSandboxEnabled = audioSandboxEnabled
}

func (p *AudioSandboxEnabled) Link() string { return "chrome.users.AudioSandboxEnabled" }
func (p *AudioSandboxEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.audioSandboxEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AudioSandboxEnabled",
				"value":{
					"audioSandboxEnabled":%s
				}
			},
			"updateMask":{
				"paths":["audioSandboxEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SuppressUnsupportedOsWarning
///////////////////////////////////////////////////////////////////////////////

type SuppressUnsupportedOsWarning struct {
	suppressUnsupportedOsWarning bool
}

func (p *SuppressUnsupportedOsWarning) SetValues(suppressUnsupportedOsWarning bool) {
	p.suppressUnsupportedOsWarning = suppressUnsupportedOsWarning
}

func (p *SuppressUnsupportedOsWarning) Link() string {
	return "chrome.users.SuppressUnsupportedOsWarning"
}
func (p *SuppressUnsupportedOsWarning) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.suppressUnsupportedOsWarning)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SuppressUnsupportedOsWarning",
				"value":{
					"suppressUnsupportedOsWarning":%s
				}
			},
			"updateMask":{
				"paths":["suppressUnsupportedOsWarning"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AdvancedProtectionAllowed
///////////////////////////////////////////////////////////////////////////////

type AdvancedProtectionAllowed struct {
	advancedProtectionAllowed bool
}

func (p *AdvancedProtectionAllowed) SetValues(advancedProtectionAllowed bool) {
	p.advancedProtectionAllowed = advancedProtectionAllowed
}

func (p *AdvancedProtectionAllowed) Link() string { return "chrome.users.AdvancedProtectionAllowed" }
func (p *AdvancedProtectionAllowed) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.advancedProtectionAllowed)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AdvancedProtectionAllowed",
				"value":{
					"advancedProtectionAllowed":%s
				}
			},
			"updateMask":{
				"paths":["advancedProtectionAllowed"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// OverrideSecurityRestrictionsOnInsecureOrigin
///////////////////////////////////////////////////////////////////////////////

type OverrideSecurityRestrictionsOnInsecureOrigin struct {
	overrideSecurityRestrictionsOnInsecureOrigin []string
}

func (p *OverrideSecurityRestrictionsOnInsecureOrigin) SetValues(overrideSecurityRestrictionsOnInsecureOrigin []string) {
	p.overrideSecurityRestrictionsOnInsecureOrigin = overrideSecurityRestrictionsOnInsecureOrigin
}

func (p *OverrideSecurityRestrictionsOnInsecureOrigin) Link() string {
	return "chrome.users.OverrideSecurityRestrictionsOnInsecureOrigin"
}
func (p *OverrideSecurityRestrictionsOnInsecureOrigin) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.overrideSecurityRestrictionsOnInsecureOrigin)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.OverrideSecurityRestrictionsOnInsecureOrigin",
				"value":{
					"overrideSecurityRestrictionsOnInsecureOrigin":%s
				}
			},
			"updateMask":{
				"paths":["overrideSecurityRestrictionsOnInsecureOrigin"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// CommandLineFlagSecurityWarningsEnabled
///////////////////////////////////////////////////////////////////////////////

type CommandLineFlagSecurityWarningsEnabled struct {
	commandLineFlagSecurityWarningsEnabled bool
}

func (p *CommandLineFlagSecurityWarningsEnabled) SetValues(commandLineFlagSecurityWarningsEnabled bool) {
	p.commandLineFlagSecurityWarningsEnabled = commandLineFlagSecurityWarningsEnabled
}

func (p *CommandLineFlagSecurityWarningsEnabled) Link() string {
	return "chrome.users.CommandLineFlagSecurityWarningsEnabled"
}
func (p *CommandLineFlagSecurityWarningsEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.commandLineFlagSecurityWarningsEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.CommandLineFlagSecurityWarningsEnabled",
				"value":{
					"commandLineFlagSecurityWarningsEnabled":%s
				}
			},
			"updateMask":{
				"paths":["commandLineFlagSecurityWarningsEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// TargetBlankImpliesNoOpener
///////////////////////////////////////////////////////////////////////////////

type TargetBlankImpliesNoOpener struct {
	targetBlankImpliesNoOpener bool
}

func (p *TargetBlankImpliesNoOpener) SetValues(targetBlankImpliesNoOpener bool) {
	p.targetBlankImpliesNoOpener = targetBlankImpliesNoOpener
}

func (p *TargetBlankImpliesNoOpener) Link() string { return "chrome.users.TargetBlankImpliesNoOpener" }
func (p *TargetBlankImpliesNoOpener) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.targetBlankImpliesNoOpener)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.TargetBlankImpliesNoOpener",
				"value":{
					"targetBlankImpliesNoOpener":%s
				}
			},
			"updateMask":{
				"paths":["targetBlankImpliesNoOpener"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SecurityTokenSessionSettings
///////////////////////////////////////////////////////////////////////////////

type SecurityTokenSessionSettings struct {
	securityTokenSessionBehavior            SecurityTokenSessionBehaviorEnum
	securityTokenSessionNotificationSeconds NullableDuration
}

func (p *SecurityTokenSessionSettings) SetValues(securityTokenSessionBehavior SecurityTokenSessionBehaviorEnum, securityTokenSessionNotificationSeconds NullableDuration) {
	p.securityTokenSessionBehavior = securityTokenSessionBehavior
	p.securityTokenSessionNotificationSeconds = securityTokenSessionNotificationSeconds
}

type SecurityTokenSessionBehaviorEnum int

const (
	SECURITY_TOKEN_SESSION_BEHAVIOR_ENUM_UNSPECIFIED SecurityTokenSessionBehaviorEnum = iota // 0
	SECURITY_TOKEN_SESSION_BEHAVIOR_ENUM_IGNORE                                              // 1
	SECURITY_TOKEN_SESSION_BEHAVIOR_ENUM_LOGOUT                                              // 2
	SECURITY_TOKEN_SESSION_BEHAVIOR_ENUM_LOCK                                                // 3
)

func (p *SecurityTokenSessionSettings) Link() string {
	return "chrome.users.SecurityTokenSessionSettings"
}
func (p *SecurityTokenSessionSettings) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.securityTokenSessionBehavior)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.securityTokenSessionNotificationSeconds)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SecurityTokenSessionSettings",
				"value":{
					"securityTokenSessionBehavior":%s,
					"securityTokenSessionNotificationSeconds":%s
				}
			},
			"updateMask":{
				"paths":["securityTokenSessionBehavior", "securityTokenSessionNotificationSeconds"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// RemoteAccessHostClientDomainList
///////////////////////////////////////////////////////////////////////////////

type RemoteAccessHostClientDomainList struct {
	remoteAccessHostClientDomainList []string
}

func (p *RemoteAccessHostClientDomainList) SetValues(remoteAccessHostClientDomainList []string) {
	p.remoteAccessHostClientDomainList = remoteAccessHostClientDomainList
}

func (p *RemoteAccessHostClientDomainList) Link() string {
	return "chrome.users.RemoteAccessHostClientDomainList"
}
func (p *RemoteAccessHostClientDomainList) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.remoteAccessHostClientDomainList)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.RemoteAccessHostClientDomainList",
				"value":{
					"remoteAccessHostClientDomainList":%s
				}
			},
			"updateMask":{
				"paths":["remoteAccessHostClientDomainList"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// RemoteAccessHostDomainList
///////////////////////////////////////////////////////////////////////////////

type RemoteAccessHostDomainList struct {
	remoteAccessHostDomainList []string
}

func (p *RemoteAccessHostDomainList) SetValues(remoteAccessHostDomainList []string) {
	p.remoteAccessHostDomainList = remoteAccessHostDomainList
}

func (p *RemoteAccessHostDomainList) Link() string { return "chrome.users.RemoteAccessHostDomainList" }
func (p *RemoteAccessHostDomainList) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.remoteAccessHostDomainList)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.RemoteAccessHostDomainList",
				"value":{
					"remoteAccessHostDomainList":%s
				}
			},
			"updateMask":{
				"paths":["remoteAccessHostDomainList"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// RemoteAccessHostFirewallTraversal
///////////////////////////////////////////////////////////////////////////////

type RemoteAccessHostFirewallTraversal struct {
	remoteAccessHostFirewallTraversal      bool
	remoteAccessHostAllowRelayedConnection bool
	remoteAccessHostUdpPortRange           string
}

func (p *RemoteAccessHostFirewallTraversal) SetValues(remoteAccessHostFirewallTraversal, remoteAccessHostAllowRelayedConnection bool, remoteAccessHostUdpPortRange string) {
	p.remoteAccessHostFirewallTraversal = remoteAccessHostFirewallTraversal
	p.remoteAccessHostAllowRelayedConnection = remoteAccessHostAllowRelayedConnection
	p.remoteAccessHostUdpPortRange = remoteAccessHostUdpPortRange
}

func (p *RemoteAccessHostFirewallTraversal) Link() string {
	return "chrome.users.RemoteAccessHostFirewallTraversal"
}
func (p *RemoteAccessHostFirewallTraversal) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.remoteAccessHostFirewallTraversal)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.remoteAccessHostAllowRelayedConnection)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.remoteAccessHostUdpPortRange)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.RemoteAccessHostFirewallTraversal",
				"value":{
					"remoteAccessHostFirewallTraversal":%s,
					"remoteAccessHostAllowRelayedConnection":%s,
					"remoteAccessHostUdpPortRange":%s
				}
			},
			"updateMask":{
				"paths":["remoteAccessHostFirewallTraversal", "remoteAccessHostAllowRelayedConnection", "remoteAccessHostUdpPortRange"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// ShowLogoutButton
///////////////////////////////////////////////////////////////////////////////

type ShowLogoutButton struct {
	showLogoutButtonInTray bool
}

func (p *ShowLogoutButton) SetValues(showLogoutButtonInTray bool) {
	p.showLogoutButtonInTray = showLogoutButtonInTray
}

func (p *ShowLogoutButton) Link() string { return "chrome.users.ShowLogoutButton" }
func (p *ShowLogoutButton) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.showLogoutButtonInTray)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.ShowLogoutButton",
				"value":{
					"showLogoutButtonInTray":%s
				}
			},
			"updateMask":{
				"paths":["showLogoutButtonInTray"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// KerberosRememberPasswordEnabled
///////////////////////////////////////////////////////////////////////////////

type KerberosRememberPasswordEnabled struct {
	kerberosRememberPasswordEnabled bool
}

func (p *KerberosRememberPasswordEnabled) SetValues(kerberosRememberPasswordEnabled bool) {
	p.kerberosRememberPasswordEnabled = kerberosRememberPasswordEnabled
}

func (p *KerberosRememberPasswordEnabled) Link() string {
	return "chrome.users.KerberosRememberPasswordEnabled"
}
func (p *KerberosRememberPasswordEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.kerberosRememberPasswordEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.KerberosRememberPasswordEnabled",
				"value":{
					"kerberosRememberPasswordEnabled":%s
				}
			},
			"updateMask":{
				"paths":["kerberosRememberPasswordEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// KerberosAddAccountsAllowed
///////////////////////////////////////////////////////////////////////////////

type KerberosAddAccountsAllowed struct {
	kerberosAddAccountsAllowed bool
}

func (p *KerberosAddAccountsAllowed) SetValues(kerberosAddAccountsAllowed bool) {
	p.kerberosAddAccountsAllowed = kerberosAddAccountsAllowed
}

func (p *KerberosAddAccountsAllowed) Link() string { return "chrome.users.KerberosAddAccountsAllowed" }
func (p *KerberosAddAccountsAllowed) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.kerberosAddAccountsAllowed)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.KerberosAddAccountsAllowed",
				"value":{
					"kerberosAddAccountsAllowed":%s
				}
			},
			"updateMask":{
				"paths":["kerberosAddAccountsAllowed"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SimpleProxySettings
///////////////////////////////////////////////////////////////////////////////

type SimpleProxySettings struct {
	simpleProxyMode      ProxyModeEnum
	simpleProxyServerUrl string
	simpleProxyPacUrl    string
	proxyBypassList      []string
}

func (p *SimpleProxySettings) SetValues(simpleProxyMode ProxyModeEnum, simpleProxyServerUrl, simpleProxyPacUrl string, proxyBypassList []string) {
	p.simpleProxyMode = simpleProxyMode
	p.simpleProxyServerUrl = simpleProxyServerUrl
	p.simpleProxyPacUrl = simpleProxyPacUrl
	p.proxyBypassList = proxyBypassList
}

type ProxyModeEnum int

const (
	PROXY_MODE_ENUM_UNSPECIFIED     ProxyModeEnum = iota // 0
	PROXY_MODE_ENUM_USER_CONFIGURED                      // 1
	PROXY_MODE_ENUM_DIRECT                               // 2
	PROXY_MODE_ENUM_AUTO_DETECT                          // 3
	PROXY_MODE_ENUM_FIXED_SERVERS                        // 4
	PROXY_MODE_ENUM_PAC_SCRIPT                           // 5
)

func (p *SimpleProxySettings) Link() string { return "chrome.users.SimpleProxySettings" }
func (p *SimpleProxySettings) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.simpleProxyMode)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.simpleProxyServerUrl)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.simpleProxyPacUrl)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.proxyBypassList)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SimpleProxySettings",
				"value":{
					"simpleProxyMode":%s,
					"simpleProxyServerUrl":%s,
					"simpleProxyPacUrl":%s,
					"proxyBypassList":%s
				}
			},
			"updateMask":{
				"paths":["simpleProxyMode", "simpleProxyServerUrl", "simpleProxyPacUrl", "proxyBypassList"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// CaptivePortalAuthenticationIgnoresProxy
///////////////////////////////////////////////////////////////////////////////

type CaptivePortalAuthenticationIgnoresProxy struct {
	captivePortalAuthenticationIgnoresProxy bool
}

func (p *CaptivePortalAuthenticationIgnoresProxy) SetValues(captivePortalAuthenticationIgnoresProxy bool) {
	p.captivePortalAuthenticationIgnoresProxy = captivePortalAuthenticationIgnoresProxy
}

func (p *CaptivePortalAuthenticationIgnoresProxy) Link() string {
	return "chrome.users.CaptivePortalAuthenticationIgnoresProxy"
}
func (p *CaptivePortalAuthenticationIgnoresProxy) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.captivePortalAuthenticationIgnoresProxy)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.CaptivePortalAuthenticationIgnoresProxy",
				"value":{
					"captivePortalAuthenticationIgnoresProxy":%s
				}
			},
			"updateMask":{
				"paths":["captivePortalAuthenticationIgnoresProxy"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AuthSchemes
///////////////////////////////////////////////////////////////////////////////

type AuthSchemes struct {
	authSchemes []string
}

func (p *AuthSchemes) SetValues(authSchemes []string) {
	p.authSchemes = authSchemes
}

func (p *AuthSchemes) Link() string { return "chrome.users.AuthSchemes" }
func (p *AuthSchemes) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.authSchemes)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AuthSchemes",
				"value":{
					"authSchemes":%s
				}
			},
			"updateMask":{
				"paths":["authSchemes"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// BasicAuthOverHttpEnabled
///////////////////////////////////////////////////////////////////////////////

type BasicAuthOverHttpEnabled struct {
	basicAuthOverHttpEnabled bool
}

func (p *BasicAuthOverHttpEnabled) SetValues(basicAuthOverHttpEnabled bool) {
	p.basicAuthOverHttpEnabled = basicAuthOverHttpEnabled
}

func (p *BasicAuthOverHttpEnabled) Link() string { return "chrome.users.BasicAuthOverHttpEnabled" }
func (p *BasicAuthOverHttpEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.basicAuthOverHttpEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.BasicAuthOverHttpEnabled",
				"value":{
					"basicAuthOverHttpEnabled":%s
				}
			},
			"updateMask":{
				"paths":["basicAuthOverHttpEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// NtlmV2Enabled
///////////////////////////////////////////////////////////////////////////////

type NtlmV2Enabled struct {
	ntlmV2Enabled bool
}

func (p *NtlmV2Enabled) SetValues(ntlmV2Enabled bool) {
	p.ntlmV2Enabled = ntlmV2Enabled
}

func (p *NtlmV2Enabled) Link() string { return "chrome.users.NtlmV2Enabled" }
func (p *NtlmV2Enabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.ntlmV2Enabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.NtlmV2Enabled",
				"value":{
					"ntlmV2Enabled":%s
				}
			},
			"updateMask":{
				"paths":["ntlmV2Enabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SslVersionMin
///////////////////////////////////////////////////////////////////////////////

type SslVersionMin struct {
	sslVersionMin SSLVersionMinEnum
}

func (p *SslVersionMin) SetValues(sslVersionMin SSLVersionMinEnum) {
	p.sslVersionMin = sslVersionMin
}

type SSLVersionMinEnum int

const (
	SSL_VERSION_MIN_ENUM_UNSPECIFIED SSLVersionMinEnum = iota // 0
	SSL_VERSION_MIN_ENUM_TL_SV_1                              // 1
	SSL_VERSION_MIN_ENUM_TL_SV_1_1                            // 2
	SSL_VERSION_MIN_ENUM_TL_SV_1_2                            // 3
	SSL_VERSION_MIN_ENUM_SSL_V_3                              // 4
)

func (p *SslVersionMin) Link() string { return "chrome.users.SslVersionMin" }
func (p *SslVersionMin) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.sslVersionMin)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SslVersionMin",
				"value":{
					"sslVersionMin":%s
				}
			},
			"updateMask":{
				"paths":["sslVersionMin"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SslErrorOverrideAllowed
///////////////////////////////////////////////////////////////////////////////

type SslErrorOverrideAllowed struct {
	sslErrorOverrideAllowed bool
}

func (p *SslErrorOverrideAllowed) SetValues(sslErrorOverrideAllowed bool) {
	p.sslErrorOverrideAllowed = sslErrorOverrideAllowed
}

func (p *SslErrorOverrideAllowed) Link() string { return "chrome.users.SslErrorOverrideAllowed" }
func (p *SslErrorOverrideAllowed) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.sslErrorOverrideAllowed)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SslErrorOverrideAllowed",
				"value":{
					"sslErrorOverrideAllowed":%s
				}
			},
			"updateMask":{
				"paths":["sslErrorOverrideAllowed"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SslErrorOverrideAllowedForOrigins
///////////////////////////////////////////////////////////////////////////////

type SslErrorOverrideAllowedForOrigins struct {
	sslErrorOverrideAllowedForOrigins []string
}

func (p *SslErrorOverrideAllowedForOrigins) SetValues(sslErrorOverrideAllowedForOrigins []string) {
	p.sslErrorOverrideAllowedForOrigins = sslErrorOverrideAllowedForOrigins
}

func (p *SslErrorOverrideAllowedForOrigins) Link() string {
	return "chrome.users.SslErrorOverrideAllowedForOrigins"
}
func (p *SslErrorOverrideAllowedForOrigins) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.sslErrorOverrideAllowedForOrigins)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SslErrorOverrideAllowedForOrigins",
				"value":{
					"sslErrorOverrideAllowedForOrigins":%s
				}
			},
			"updateMask":{
				"paths":["sslErrorOverrideAllowedForOrigins"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// DataCompressionProxy
///////////////////////////////////////////////////////////////////////////////

type DataCompressionProxy struct {
	dataCompressionProxyEnabled NullableBoolean
}

func (p *DataCompressionProxy) SetValues(dataCompressionProxyEnabled NullableBoolean) {
	p.dataCompressionProxyEnabled = dataCompressionProxyEnabled
}

func (p *DataCompressionProxy) Link() string { return "chrome.users.DataCompressionProxy" }
func (p *DataCompressionProxy) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.dataCompressionProxyEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.DataCompressionProxy",
				"value":{
					"dataCompressionProxyEnabled":%s
				}
			},
			"updateMask":{
				"paths":["dataCompressionProxyEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// WebRtcUdpPortRange
///////////////////////////////////////////////////////////////////////////////

type WebRtcUdpPortRange struct {
	webRtcUdpPortsEnabled bool
	webRtcUdpPortsMin     int64
	webRtcUdpPortsMax     int64
}

func (p *WebRtcUdpPortRange) SetValues(webRtcUdpPortsEnabled bool, webRtcUdpPortsMin, webRtcUdpPortsMax int64) {
	p.webRtcUdpPortsEnabled = webRtcUdpPortsEnabled
	p.webRtcUdpPortsMin = webRtcUdpPortsMin
	p.webRtcUdpPortsMax = webRtcUdpPortsMax
}

func (p *WebRtcUdpPortRange) Link() string { return "chrome.users.WebRtcUdpPortRange" }
func (p *WebRtcUdpPortRange) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.webRtcUdpPortsEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.webRtcUdpPortsMin)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.webRtcUdpPortsMax)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.WebRtcUdpPortRange",
				"value":{
					"webRtcUdpPortsEnabled":%s,
					"webRtcUdpPortsMin":%s,
					"webRtcUdpPortsMax":%s
				}
			},
			"updateMask":{
				"paths":["webRtcUdpPortsEnabled", "webRtcUdpPortsMin", "webRtcUdpPortsMax"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// WebRtcLocalIpsAllowedUrls
///////////////////////////////////////////////////////////////////////////////

type WebRtcLocalIpsAllowedUrls struct {
	webRtcLocalIpsAllowedUrls []string
}

func (p *WebRtcLocalIpsAllowedUrls) SetValues(webRtcLocalIpsAllowedUrls []string) {
	p.webRtcLocalIpsAllowedUrls = webRtcLocalIpsAllowedUrls
}

func (p *WebRtcLocalIpsAllowedUrls) Link() string { return "chrome.users.WebRtcLocalIpsAllowedUrls" }
func (p *WebRtcLocalIpsAllowedUrls) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.webRtcLocalIpsAllowedUrls)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.WebRtcLocalIpsAllowedUrls",
				"value":{
					"webRtcLocalIpsAllowedUrls":%s
				}
			},
			"updateMask":{
				"paths":["webRtcLocalIpsAllowedUrls"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// QuicProtocol
///////////////////////////////////////////////////////////////////////////////

type QuicProtocol struct {
	quicAllowed bool
}

func (p *QuicProtocol) SetValues(quicAllowed bool) {
	p.quicAllowed = quicAllowed
}

func (p *QuicProtocol) Link() string { return "chrome.users.QuicProtocol" }
func (p *QuicProtocol) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.quicAllowed)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.QuicProtocol",
				"value":{
					"quicAllowed":%s
				}
			},
			"updateMask":{
				"paths":["quicAllowed"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// BuiltInDnsClientEnabled
///////////////////////////////////////////////////////////////////////////////

type BuiltInDnsClientEnabled struct {
	builtInDnsClientEnabled NullableBoolean
}

func (p *BuiltInDnsClientEnabled) SetValues(builtInDnsClientEnabled NullableBoolean) {
	p.builtInDnsClientEnabled = builtInDnsClientEnabled
}

func (p *BuiltInDnsClientEnabled) Link() string { return "chrome.users.BuiltInDnsClientEnabled" }
func (p *BuiltInDnsClientEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.builtInDnsClientEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.BuiltInDnsClientEnabled",
				"value":{
					"builtInDnsClientEnabled":%s
				}
			},
			"updateMask":{
				"paths":["builtInDnsClientEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AlwaysOnVpn
///////////////////////////////////////////////////////////////////////////////

type AlwaysOnVpn struct {
	alwaysOnVpnApp   string
	vpnConfigAllowed bool
}

func (p *AlwaysOnVpn) SetValues(alwaysOnVpnApp string, vpnConfigAllowed bool) {
	p.alwaysOnVpnApp = alwaysOnVpnApp
	p.vpnConfigAllowed = vpnConfigAllowed
}

func (p *AlwaysOnVpn) Link() string { return "chrome.users.AlwaysOnVpn" }
func (p *AlwaysOnVpn) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.alwaysOnVpnApp)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.vpnConfigAllowed)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AlwaysOnVpn",
				"value":{
					"alwaysOnVpnApp":%s,
					"vpnConfigAllowed":%s
				}
			},
			"updateMask":{
				"paths":["alwaysOnVpnApp", "vpnConfigAllowed"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AuthenticationServerAllowlist
///////////////////////////////////////////////////////////////////////////////

type AuthenticationServerAllowlist struct {
	authServerAllowlist []string
}

func (p *AuthenticationServerAllowlist) SetValues(authServerAllowlist []string) {
	p.authServerAllowlist = authServerAllowlist
}

func (p *AuthenticationServerAllowlist) Link() string {
	return "chrome.users.AuthenticationServerAllowlist"
}
func (p *AuthenticationServerAllowlist) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.authServerAllowlist)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AuthenticationServerAllowlist",
				"value":{
					"authServerAllowlist":%s
				}
			},
			"updateMask":{
				"paths":["authServerAllowlist"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AuthenticationServerDelegationAllowlist
///////////////////////////////////////////////////////////////////////////////

type AuthenticationServerDelegationAllowlist struct {
	authNegotiateDelegateAllowlist []string
}

func (p *AuthenticationServerDelegationAllowlist) SetValues(authNegotiateDelegateAllowlist []string) {
	p.authNegotiateDelegateAllowlist = authNegotiateDelegateAllowlist
}

func (p *AuthenticationServerDelegationAllowlist) Link() string {
	return "chrome.users.AuthenticationServerDelegationAllowlist"
}
func (p *AuthenticationServerDelegationAllowlist) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.authNegotiateDelegateAllowlist)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AuthenticationServerDelegationAllowlist",
				"value":{
					"authNegotiateDelegateAllowlist":%s
				}
			},
			"updateMask":{
				"paths":["authNegotiateDelegateAllowlist"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// KerberosTicketDelegation
///////////////////////////////////////////////////////////////////////////////

type KerberosTicketDelegation struct {
	authNegotiateDelegateByKdcPolicy bool
}

func (p *KerberosTicketDelegation) SetValues(authNegotiateDelegateByKdcPolicy bool) {
	p.authNegotiateDelegateByKdcPolicy = authNegotiateDelegateByKdcPolicy
}

func (p *KerberosTicketDelegation) Link() string { return "chrome.users.KerberosTicketDelegation" }
func (p *KerberosTicketDelegation) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.authNegotiateDelegateByKdcPolicy)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.KerberosTicketDelegation",
				"value":{
					"authNegotiateDelegateByKdcPolicy":%s
				}
			},
			"updateMask":{
				"paths":["authNegotiateDelegateByKdcPolicy"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// KerberosServicePrincipalName
///////////////////////////////////////////////////////////////////////////////

type KerberosServicePrincipalName struct {
	disableAuthNegotiateCnameLookup bool
}

func (p *KerberosServicePrincipalName) SetValues(disableAuthNegotiateCnameLookup bool) {
	p.disableAuthNegotiateCnameLookup = disableAuthNegotiateCnameLookup
}

func (p *KerberosServicePrincipalName) Link() string {
	return "chrome.users.KerberosServicePrincipalName"
}
func (p *KerberosServicePrincipalName) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.disableAuthNegotiateCnameLookup)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.KerberosServicePrincipalName",
				"value":{
					"disableAuthNegotiateCnameLookup":%s
				}
			},
			"updateMask":{
				"paths":["disableAuthNegotiateCnameLookup"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// KerberosSpnPort
///////////////////////////////////////////////////////////////////////////////

type KerberosSpnPort struct {
	enableAuthNegotiatePort bool
}

func (p *KerberosSpnPort) SetValues(enableAuthNegotiatePort bool) {
	p.enableAuthNegotiatePort = enableAuthNegotiatePort
}

func (p *KerberosSpnPort) Link() string { return "chrome.users.KerberosSpnPort" }
func (p *KerberosSpnPort) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.enableAuthNegotiatePort)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.KerberosSpnPort",
				"value":{
					"enableAuthNegotiatePort":%s
				}
			},
			"updateMask":{
				"paths":["enableAuthNegotiatePort"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// CrossOriginAuthentication
///////////////////////////////////////////////////////////////////////////////

type CrossOriginAuthentication struct {
	allowCrossOriginAuthPrompt bool
}

func (p *CrossOriginAuthentication) SetValues(allowCrossOriginAuthPrompt bool) {
	p.allowCrossOriginAuthPrompt = allowCrossOriginAuthPrompt
}

func (p *CrossOriginAuthentication) Link() string { return "chrome.users.CrossOriginAuthentication" }
func (p *CrossOriginAuthentication) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.allowCrossOriginAuthPrompt)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.CrossOriginAuthentication",
				"value":{
					"allowCrossOriginAuthPrompt":%s
				}
			},
			"updateMask":{
				"paths":["allowCrossOriginAuthPrompt"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// UserAgentClientHintsEnabled
///////////////////////////////////////////////////////////////////////////////

type UserAgentClientHintsEnabled struct {
	userAgentClientHintsEnabled bool
}

func (p *UserAgentClientHintsEnabled) SetValues(userAgentClientHintsEnabled bool) {
	p.userAgentClientHintsEnabled = userAgentClientHintsEnabled
}

func (p *UserAgentClientHintsEnabled) Link() string {
	return "chrome.users.UserAgentClientHintsEnabled"
}
func (p *UserAgentClientHintsEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.userAgentClientHintsEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.UserAgentClientHintsEnabled",
				"value":{
					"userAgentClientHintsEnabled":%s
				}
			},
			"updateMask":{
				"paths":["userAgentClientHintsEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// SignedHttpExchangeEnabled
///////////////////////////////////////////////////////////////////////////////

type SignedHttpExchangeEnabled struct {
	signedHttpExchangeEnabled bool
}

func (p *SignedHttpExchangeEnabled) SetValues(signedHttpExchangeEnabled bool) {
	p.signedHttpExchangeEnabled = signedHttpExchangeEnabled
}

func (p *SignedHttpExchangeEnabled) Link() string { return "chrome.users.SignedHttpExchangeEnabled" }
func (p *SignedHttpExchangeEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.signedHttpExchangeEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.SignedHttpExchangeEnabled",
				"value":{
					"signedHttpExchangeEnabled":%s
				}
			},
			"updateMask":{
				"paths":["signedHttpExchangeEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// GloballyScopeHttpAuthCacheEnabled
///////////////////////////////////////////////////////////////////////////////

type GloballyScopeHttpAuthCacheEnabled struct {
	globallyScopeHttpAuthCacheEnabled bool
}

func (p *GloballyScopeHttpAuthCacheEnabled) SetValues(globallyScopeHttpAuthCacheEnabled bool) {
	p.globallyScopeHttpAuthCacheEnabled = globallyScopeHttpAuthCacheEnabled
}

func (p *GloballyScopeHttpAuthCacheEnabled) Link() string {
	return "chrome.users.GloballyScopeHttpAuthCacheEnabled"
}
func (p *GloballyScopeHttpAuthCacheEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.globallyScopeHttpAuthCacheEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.GloballyScopeHttpAuthCacheEnabled",
				"value":{
					"globallyScopeHttpAuthCacheEnabled":%s
				}
			},
			"updateMask":{
				"paths":["globallyScopeHttpAuthCacheEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// RequireOnlineRevocationChecksForLocalAnchors
///////////////////////////////////////////////////////////////////////////////

type RequireOnlineRevocationChecksForLocalAnchors struct {
	requireOnlineRevocationChecksForLocalAnchors bool
}

func (p *RequireOnlineRevocationChecksForLocalAnchors) SetValues(requireOnlineRevocationChecksForLocalAnchors bool) {
	p.requireOnlineRevocationChecksForLocalAnchors = requireOnlineRevocationChecksForLocalAnchors
}

func (p *RequireOnlineRevocationChecksForLocalAnchors) Link() string {
	return "chrome.users.RequireOnlineRevocationChecksForLocalAnchors"
}
func (p *RequireOnlineRevocationChecksForLocalAnchors) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.requireOnlineRevocationChecksForLocalAnchors)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.RequireOnlineRevocationChecksForLocalAnchors",
				"value":{
					"requireOnlineRevocationChecksForLocalAnchors":%s
				}
			},
			"updateMask":{
				"paths":["requireOnlineRevocationChecksForLocalAnchors"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// MaxConnectionsPerProxy
///////////////////////////////////////////////////////////////////////////////

type MaxConnectionsPerProxy struct {
	maxConnectionsPerProxy int64
}

func (p *MaxConnectionsPerProxy) SetValues(maxConnectionsPerProxy int64) {
	p.maxConnectionsPerProxy = maxConnectionsPerProxy
}

func (p *MaxConnectionsPerProxy) Link() string { return "chrome.users.MaxConnectionsPerProxy" }
func (p *MaxConnectionsPerProxy) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.maxConnectionsPerProxy)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.MaxConnectionsPerProxy",
				"value":{
					"maxConnectionsPerProxy":%s
				}
			},
			"updateMask":{
				"paths":["maxConnectionsPerProxy"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// GssapiLibraryName
///////////////////////////////////////////////////////////////////////////////

type GssapiLibraryName struct {
	gssapiLibraryName string
}

func (p *GssapiLibraryName) SetValues(gssapiLibraryName string) {
	p.gssapiLibraryName = gssapiLibraryName
}

func (p *GssapiLibraryName) Link() string { return "chrome.users.GssapiLibraryName" }
func (p *GssapiLibraryName) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.gssapiLibraryName)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.GssapiLibraryName",
				"value":{
					"gssapiLibraryName":%s
				}
			},
			"updateMask":{
				"paths":["gssapiLibraryName"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// HstsPolicyBypassList
///////////////////////////////////////////////////////////////////////////////

type HstsPolicyBypassList struct {
	hstsPolicyBypassList []string
}

func (p *HstsPolicyBypassList) SetValues(hstsPolicyBypassList []string) {
	p.hstsPolicyBypassList = hstsPolicyBypassList
}

func (p *HstsPolicyBypassList) Link() string { return "chrome.users.HstsPolicyBypassList" }
func (p *HstsPolicyBypassList) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.hstsPolicyBypassList)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.HstsPolicyBypassList",
				"value":{
					"hstsPolicyBypassList":%s
				}
			},
			"updateMask":{
				"paths":["hstsPolicyBypassList"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AuthAndroidNegotiateAccountType
///////////////////////////////////////////////////////////////////////////////

type AuthAndroidNegotiateAccountType struct {
	authAndroidNegotiateAccountType string
}

func (p *AuthAndroidNegotiateAccountType) SetValues(authAndroidNegotiateAccountType string) {
	p.authAndroidNegotiateAccountType = authAndroidNegotiateAccountType
}

func (p *AuthAndroidNegotiateAccountType) Link() string {
	return "chrome.users.AuthAndroidNegotiateAccountType"
}
func (p *AuthAndroidNegotiateAccountType) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.authAndroidNegotiateAccountType)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AuthAndroidNegotiateAccountType",
				"value":{
					"authAndroidNegotiateAccountType":%s
				}
			},
			"updateMask":{
				"paths":["authAndroidNegotiateAccountType"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// DnsInterceptionChecksEnabled
///////////////////////////////////////////////////////////////////////////////

type DnsInterceptionChecksEnabled struct {
	dnsInterceptionChecksEnabled bool
}

func (p *DnsInterceptionChecksEnabled) SetValues(dnsInterceptionChecksEnabled bool) {
	p.dnsInterceptionChecksEnabled = dnsInterceptionChecksEnabled
}

func (p *DnsInterceptionChecksEnabled) Link() string {
	return "chrome.users.DnsInterceptionChecksEnabled"
}
func (p *DnsInterceptionChecksEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.dnsInterceptionChecksEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.DnsInterceptionChecksEnabled",
				"value":{
					"dnsInterceptionChecksEnabled":%s
				}
			},
			"updateMask":{
				"paths":["dnsInterceptionChecksEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// IntranetRedirectBehavior
///////////////////////////////////////////////////////////////////////////////

type IntranetRedirectBehavior struct {
	intranetRedirectBehavior IntranetRedirectBehaviorEnum
}

func (p *IntranetRedirectBehavior) SetValues(intranetRedirectBehavior IntranetRedirectBehaviorEnum) {
	p.intranetRedirectBehavior = intranetRedirectBehavior
}

type IntranetRedirectBehaviorEnum int

const (
	INTRANET_REDIRECT_BEHAVIOR_ENUM_UNSPECIFIED                                 IntranetRedirectBehaviorEnum = iota // 0
	INTRANET_REDIRECT_BEHAVIOR_ENUM_DEFAULT                                                                         // 1
	INTRANET_REDIRECT_BEHAVIOR_ENUM_DISABLE_INTERCEPTION_CHECKS_DISABLE_INFOBAR                                     // 2
	INTRANET_REDIRECT_BEHAVIOR_ENUM_DISABLE_INTERCEPTION_CHECKS_ENABLE_INFOBAR                                      // 3
	INTRANET_REDIRECT_BEHAVIOR_ENUM_ENABLE_INTERCEPTION_CHECKS_ENABLE_INFOBAR                                       // 4
)

func (p *IntranetRedirectBehavior) Link() string { return "chrome.users.IntranetRedirectBehavior" }
func (p *IntranetRedirectBehavior) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.intranetRedirectBehavior)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.IntranetRedirectBehavior",
				"value":{
					"intranetRedirectBehavior":%s
				}
			},
			"updateMask":{
				"paths":["intranetRedirectBehavior"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// WebRtcAllowLegacyTlsProtocolsCategoryItem
///////////////////////////////////////////////////////////////////////////////

type WebRtcAllowLegacyTlsProtocolsCategoryItem struct {
	webRtcAllowLegacyTlsProtocols bool
}

func (p *WebRtcAllowLegacyTlsProtocolsCategoryItem) SetValues(webRtcAllowLegacyTlsProtocols bool) {
	p.webRtcAllowLegacyTlsProtocols = webRtcAllowLegacyTlsProtocols
}

func (p *WebRtcAllowLegacyTlsProtocolsCategoryItem) Link() string {
	return "chrome.users.WebRtcAllowLegacyTlsProtocolsCategoryItem"
}
func (p *WebRtcAllowLegacyTlsProtocolsCategoryItem) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.webRtcAllowLegacyTlsProtocols)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.WebRtcAllowLegacyTlsProtocolsCategoryItem",
				"value":{
					"webRtcAllowLegacyTlsProtocols":%s
				}
			},
			"updateMask":{
				"paths":["webRtcAllowLegacyTlsProtocols"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// WpadQuickCheckEnabled
///////////////////////////////////////////////////////////////////////////////

type WpadQuickCheckEnabled struct {
	wpadQuickCheckEnabled bool
}

func (p *WpadQuickCheckEnabled) SetValues(wpadQuickCheckEnabled bool) {
	p.wpadQuickCheckEnabled = wpadQuickCheckEnabled
}

func (p *WpadQuickCheckEnabled) Link() string { return "chrome.users.WpadQuickCheckEnabled" }
func (p *WpadQuickCheckEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.wpadQuickCheckEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.WpadQuickCheckEnabled",
				"value":{
					"wpadQuickCheckEnabled":%s
				}
			},
			"updateMask":{
				"paths":["wpadQuickCheckEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// IntegratedWebAuthenticationAllowed
///////////////////////////////////////////////////////////////////////////////

type IntegratedWebAuthenticationAllowed struct {
	integratedWebAuthenticationAllowed bool
}

func (p *IntegratedWebAuthenticationAllowed) SetValues(integratedWebAuthenticationAllowed bool) {
	p.integratedWebAuthenticationAllowed = integratedWebAuthenticationAllowed
}

func (p *IntegratedWebAuthenticationAllowed) Link() string {
	return "chrome.users.IntegratedWebAuthenticationAllowed"
}
func (p *IntegratedWebAuthenticationAllowed) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.integratedWebAuthenticationAllowed)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.IntegratedWebAuthenticationAllowed",
				"value":{
					"integratedWebAuthenticationAllowed":%s
				}
			},
			"updateMask":{
				"paths":["integratedWebAuthenticationAllowed"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// Cecpq2Enabled
///////////////////////////////////////////////////////////////////////////////

type Cecpq2Enabled struct {
	cecpq2Enabled bool
}

func (p *Cecpq2Enabled) SetValues(cecpq2Enabled bool) {
	p.cecpq2Enabled = cecpq2Enabled
}

func (p *Cecpq2Enabled) Link() string { return "chrome.users.Cecpq2Enabled" }
func (p *Cecpq2Enabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.cecpq2Enabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.Cecpq2Enabled",
				"value":{
					"cecpq2Enabled":%s
				}
			},
			"updateMask":{
				"paths":["cecpq2Enabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AndroidBackupRestoreServiceEnabled
///////////////////////////////////////////////////////////////////////////////

type AndroidBackupRestoreServiceEnabled struct {
	arcBackupRestoreServiceEnabled ArcBackupRestoreServiceEnum
}

func (p *AndroidBackupRestoreServiceEnabled) SetValues(arcBackupRestoreServiceEnabled ArcBackupRestoreServiceEnum) {
	p.arcBackupRestoreServiceEnabled = arcBackupRestoreServiceEnabled
}

type ArcBackupRestoreServiceEnum int

const (
	ARC_BACKUP_RESTORE_SERVICE_ENUM_UNSPECIFIED                           ArcBackupRestoreServiceEnum = iota // 0
	ARC_BACKUP_RESTORE_SERVICE_ENUM_BACKUP_AND_RESTORE_DISABLED                                              // 1
	ARC_BACKUP_RESTORE_SERVICE_ENUM_BACKUP_AND_RESTORE_UNDER_USER_CONTROL                                    // 2
)

func (p *AndroidBackupRestoreServiceEnabled) Link() string {
	return "chrome.users.AndroidBackupRestoreServiceEnabled"
}
func (p *AndroidBackupRestoreServiceEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.arcBackupRestoreServiceEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AndroidBackupRestoreServiceEnabled",
				"value":{
					"arcBackupRestoreServiceEnabled":%s
				}
			},
			"updateMask":{
				"paths":["arcBackupRestoreServiceEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// AndroidGoogleLocationServicesEnabled
///////////////////////////////////////////////////////////////////////////////

type AndroidGoogleLocationServicesEnabled struct {
	arcGoogleLocationServicesEnabled ArcGoogleLocationServicesEnum
}

func (p *AndroidGoogleLocationServicesEnabled) SetValues(arcGoogleLocationServicesEnabled ArcGoogleLocationServicesEnum) {
	p.arcGoogleLocationServicesEnabled = arcGoogleLocationServicesEnabled
}

type ArcGoogleLocationServicesEnum int

const (
	ARC_GOOGLE_LOCATION_SERVICES_ENUM_UNSPECIFIED        ArcGoogleLocationServicesEnum = iota // 0
	ARC_GOOGLE_LOCATION_SERVICES_ENUM_DISABLED                                                // 1
	ARC_GOOGLE_LOCATION_SERVICES_ENUM_UNDER_USER_CONTROL                                      // 2
)

func (p *AndroidGoogleLocationServicesEnabled) Link() string {
	return "chrome.users.AndroidGoogleLocationServicesEnabled"
}
func (p *AndroidGoogleLocationServicesEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.arcGoogleLocationServicesEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.AndroidGoogleLocationServicesEnabled",
				"value":{
					"arcGoogleLocationServicesEnabled":%s
				}
			},
			"updateMask":{
				"paths":["arcGoogleLocationServicesEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// CertificateSynchronization
///////////////////////////////////////////////////////////////////////////////

type CertificateSynchronization struct {
	arcCertificatesSyncMode ArcCertificatesSyncModeEnum
}

func (p *CertificateSynchronization) SetValues(arcCertificatesSyncMode ArcCertificatesSyncModeEnum) {
	p.arcCertificatesSyncMode = arcCertificatesSyncMode
}

type ArcCertificatesSyncModeEnum int

const (
	ARC_CERTIFICATES_SYNC_MODE_ENUM_UNSPECIFIED   ArcCertificatesSyncModeEnum = iota // 0
	ARC_CERTIFICATES_SYNC_MODE_ENUM_SYNC_DISABLED                                    // 1
	ARC_CERTIFICATES_SYNC_MODE_ENUM_COPY_CA_CERTS                                    // 2
)

func (p *CertificateSynchronization) Link() string { return "chrome.users.CertificateSynchronization" }
func (p *CertificateSynchronization) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.arcCertificatesSyncMode)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.CertificateSynchronization",
				"value":{
					"arcCertificatesSyncMode":%s
				}
			},
			"updateMask":{
				"paths":["arcCertificatesSyncMode"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// HomeButton
///////////////////////////////////////////////////////////////////////////////

type HomeButton struct {
	showHomeButton NullableBoolean
}

func (p *HomeButton) SetValues(showHomeButton NullableBoolean) {
	p.showHomeButton = showHomeButton
}

func (p *HomeButton) Link() string { return "chrome.users.HomeButton" }
func (p *HomeButton) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.showHomeButton)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.HomeButton",
				"value":{
					"showHomeButton":%s
				}
			},
			"updateMask":{
				"paths":["showHomeButton"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// Homepage
///////////////////////////////////////////////////////////////////////////////

type Homepage struct {
	homepageIsNewTabPage NullableBoolean
	homepageLocation     string
}

func (p *Homepage) SetValues(homepageIsNewTabPage NullableBoolean, homepageLocation string) {
	p.homepageIsNewTabPage = homepageIsNewTabPage
	p.homepageLocation = homepageLocation
}

func (p *Homepage) Link() string { return "chrome.users.Homepage" }
func (p *Homepage) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.homepageIsNewTabPage)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	out, err = json.Marshal(p.homepageLocation)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.Homepage",
				"value":{
					"homepageIsNewTabPage":%s,
					"homepageLocation":%s
				}
			},
			"updateMask":{
				"paths":["homepageIsNewTabPage", "homepageLocation"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// NewTabPageLocation
///////////////////////////////////////////////////////////////////////////////

type NewTabPageLocation struct {
	newTabPageLocation string
}

func (p *NewTabPageLocation) SetValues(newTabPageLocation string) {
	p.newTabPageLocation = newTabPageLocation
}

func (p *NewTabPageLocation) Link() string { return "chrome.users.NewTabPageLocation" }
func (p *NewTabPageLocation) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.newTabPageLocation)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.NewTabPageLocation",
				"value":{
					"newTabPageLocation":%s
				}
			},
			"updateMask":{
				"paths":["newTabPageLocation"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// NtpContentSuggestionsEnabled
///////////////////////////////////////////////////////////////////////////////

type NtpContentSuggestionsEnabled struct {
	ntpContentSuggestionsEnabled bool
}

func (p *NtpContentSuggestionsEnabled) SetValues(ntpContentSuggestionsEnabled bool) {
	p.ntpContentSuggestionsEnabled = ntpContentSuggestionsEnabled
}

func (p *NtpContentSuggestionsEnabled) Link() string {
	return "chrome.users.NtpContentSuggestionsEnabled"
}
func (p *NtpContentSuggestionsEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.ntpContentSuggestionsEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.NtpContentSuggestionsEnabled",
				"value":{
					"ntpContentSuggestionsEnabled":%s
				}
			},
			"updateMask":{
				"paths":["ntpContentSuggestionsEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// NtpCustomBackgroundEnabled
///////////////////////////////////////////////////////////////////////////////

type NtpCustomBackgroundEnabled struct {
	ntpCustomBackgroundEnabled bool
}

func (p *NtpCustomBackgroundEnabled) SetValues(ntpCustomBackgroundEnabled bool) {
	p.ntpCustomBackgroundEnabled = ntpCustomBackgroundEnabled
}

func (p *NtpCustomBackgroundEnabled) Link() string { return "chrome.users.NtpCustomBackgroundEnabled" }
func (p *NtpCustomBackgroundEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.ntpCustomBackgroundEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.NtpCustomBackgroundEnabled",
				"value":{
					"ntpCustomBackgroundEnabled":%s
				}
			},
			"updateMask":{
				"paths":["ntpCustomBackgroundEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// StartupPages
///////////////////////////////////////////////////////////////////////////////

type StartupPages struct {
	restoreOnStartupUrls []string
}

func (p *StartupPages) SetValues(restoreOnStartupUrls []string) {
	p.restoreOnStartupUrls = restoreOnStartupUrls
}

func (p *StartupPages) Link() string { return "chrome.users.StartupPages" }
func (p *StartupPages) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.restoreOnStartupUrls)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.StartupPages",
				"value":{
					"restoreOnStartupUrls":%s
				}
			},
			"updateMask":{
				"paths":["restoreOnStartupUrls"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// DefaultBrowserSettingEnabled
///////////////////////////////////////////////////////////////////////////////

type DefaultBrowserSettingEnabled struct {
	defaultBrowserSettingEnabled NullableBoolean
}

func (p *DefaultBrowserSettingEnabled) SetValues(defaultBrowserSettingEnabled NullableBoolean) {
	p.defaultBrowserSettingEnabled = defaultBrowserSettingEnabled
}

func (p *DefaultBrowserSettingEnabled) Link() string {
	return "chrome.users.DefaultBrowserSettingEnabled"
}
func (p *DefaultBrowserSettingEnabled) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.defaultBrowserSettingEnabled)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.DefaultBrowserSettingEnabled",
				"value":{
					"defaultBrowserSettingEnabled":%s
				}
			},
			"updateMask":{
				"paths":["defaultBrowserSettingEnabled"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// ProfilePickerOnStartupAvailability
///////////////////////////////////////////////////////////////////////////////

type ProfilePickerOnStartupAvailability struct {
	profilePickerOnStartupAvailability ProfilePickerOnStartupAvailabilityEnum
}

func (p *ProfilePickerOnStartupAvailability) SetValues(profilePickerOnStartupAvailability ProfilePickerOnStartupAvailabilityEnum) {
	p.profilePickerOnStartupAvailability = profilePickerOnStartupAvailability
}

type ProfilePickerOnStartupAvailabilityEnum int

const (
	PROFILE_PICKER_ON_STARTUP_AVAILABILITY_ENUM_UNSPECIFIED ProfilePickerOnStartupAvailabilityEnum = iota // 0
	PROFILE_PICKER_ON_STARTUP_AVAILABILITY_ENUM_ENABLED                                                   // 1
	PROFILE_PICKER_ON_STARTUP_AVAILABILITY_ENUM_DISABLED                                                  // 2
	PROFILE_PICKER_ON_STARTUP_AVAILABILITY_ENUM_FORCED                                                    // 3
)

func (p *ProfilePickerOnStartupAvailability) Link() string {
	return "chrome.users.ProfilePickerOnStartupAvailability"
}
func (p *ProfilePickerOnStartupAvailability) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.profilePickerOnStartupAvailability)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.ProfilePickerOnStartupAvailability",
				"value":{
					"profilePickerOnStartupAvailability":%s
				}
			},
			"updateMask":{
				"paths":["profilePickerOnStartupAvailability"]
			}
		}
	}`, orgunit, valStrs...), nil
}

///////////////////////////////////////////////////////////////////////////////
// ImportAutofillFormData
///////////////////////////////////////////////////////////////////////////////

type ImportAutofillFormData struct {
	importAutofillFormData NullableBoolean
}

func (p *ImportAutofillFormData) SetValues(importAutofillFormData NullableBoolean) {
	p.importAutofillFormData = importAutofillFormData
}

func (p *ImportAutofillFormData) Link() string { return "chrome.users.ImportAutofillFormData" }
func (p *ImportAutofillFormData) UpdateString(orgunit string) (string, error) {
	var valStrs []interface{}

	out, err := json.Marshal(p.importAutofillFormData)
	if err != nil {
		return "", errors.Wrap(err, "failed to convert value to json")
	}
	valStrs = append(valStrs, string(out))

	return fmt.Sprintf(`{
		"requests":{
			"policyTargetKey":{
				"targetResource":"orgunits/%s"
			},
			"policyValue":{
				"policySchema":"chrome.users.ImportAutofillFormData",
				"value":{
					"importAutofillFormData":%s
				}
			},
			"updateMask":{
				"paths":["importAutofillFormData"]
			}
		}
	}`, orgunit, valStrs...), nil
}
