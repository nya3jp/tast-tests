#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2021 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Tool for creating go code from policy schemas.

Used to create policy_schemas.go for policy Tast tests using TAPE.

Generating a new policy_schemas.go file:
 Running the script requires the client secret of the default service account of TAPE.
 If you don't have access to it contact cros-engprod-muc@google.com to regenerate
 policy_schemas.go for you.

 Otherwise run the script and follow the prompts. You will be requested to follow a link
 to generate an authorization code and paste it for use in the script.
 > ./generate_policy_schemas.py --tape_client_secret <secret>
 Use a CL to checkin the updated file.
"""

import argparse
import json
import os
import requests
import subprocess

# Default output filename and path.
OUTPUT_FILENAME = 'policy_schemas.go'
OUTPUT_FILEPATH = os.path.join(os.path.dirname(__file__), "..", OUTPUT_FILENAME)

#URLS
OAUTH_AUTH_URL = 'https://accounts.google.com/o/oauth2/v2/auth'
OAUTH_TOKEN_URL = 'https://oauth2.googleapis.com/token'
POLICY_SCHEMAS_URL = 'https://test-dot-tape-307412.ey.r.appspot.com/getPolicySchemas'

#TAPE
TAPE_CLIENT_ID = '770216225211-4fnjia8bqvte0btelrb3c1fcm7i2m6o6.apps.googleusercontent.com'
TAPE_IAP_CLIENT_ID = '770216225211-ihjn20dlehf94m9l4l5h0b0iilvd1vhc.apps.googleusercontent.com'

# Header for the GO code.
HEADER = """// Copyright 2021 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Code generated by generate_policy_schemas.py. DO NOT EDIT.
// Edit the generator in gen/generate_policy_schemas.py instead.

package tape

import (
\t"encoding/json"
\t"fmt"

\t"chromiumos/tast/errors"
)
"""

# Note: A double "{{" is to produce a single "{" in the formatted Go code.

# Template for a single policy. Is formatted using a Policy object.
POLICY_SCHEMA_TEMPLATE = """
///////////////////////////////////////////////////////////////////////////////
// {self.name}
///////////////////////////////////////////////////////////////////////////////

{additional_structs_string}
func (p *{self.name}) Link() string      {{ return "{self.link}" }}
func (p *{self.name}) UpdateString(orgunit string) (string, error)      {{
\tvar valStrs []interface{{}}
\tvalStrs = append(valStrs, orgunit)

{values2String}

\treturn fmt.Sprintf(`{updateString}`, valStrs...), nil
}}
"""

VALUE_TO_JSON_TEMPLATE = """
\tout, err {assignement} json.Marshal(p.{value})
\t\tif err != nil {{
\t\t\treturn "", errors.Wrap(err, "failed to convert value to json")
\t\t}}
\t\tvalStrs = append(valStrs, string(out))
"""

#Template for the update string used by the DPanel API
UPDATE_STRING_TEMPLATE =  """{{
\t\t"requests":{{
\t\t\t"policyTargetKey":{{
\t\t\t\t"targetResource":"orgunits/%s"
\t\t\t}},
\t\t\t"policyValue":{{
\t\t\t\t"policySchema":"{self.link}",
\t\t\t\t"value":{{
{value_names}
\t\t\t\t}}
\t\t\t}},
\t\t\t"updateMask":{{
\t\t\t\t"paths":[{path_str}]
\t\t\t}}
\t\t}}
\t}}"""

# Conversion of policy schema types to Go types.
TYPES_SCHEMA_TO_GO = {
    'TYPE_STRING': 'string',
    'TYPE_INT32': 'int',
    'TYPE_INT64': 'int64',
    'TYPE_BOOL': 'bool'
}

class PolicySchema:
  """Class representing a single policy schema, used with POLICY_SCHEMA_TEMPLATE."""
  def __init__(self, name):
    # name: Name of this policy as defined in the policy schema.
    self.name = name

    # Set initial values for variables which may be overwritten during code
    # generation.
    # link: The link to update this policy schema.
    self.link = ""
    # types: Array of the value types for this policy schema.
    # additional_structs: All structs and enums needed for this policy schema.
    self.additional_structs = None
    # code: All code that is generated for the policy schema.
    self.code = None

  def generate_code(self):
    additional_structs_string = "".join(self.additional_structs)
    values2String = VALUE_TO_JSON_TEMPLATE.format(assignement=":=", value=self.types[0])
    value_names = "\t\t\t\t\t\"" + self.types[0] + "\":%s"
    path_str = "\"" + self.types[0] + "\""
    for value_type in self.types[1:]:
      values2String += VALUE_TO_JSON_TEMPLATE.format(assignement="=", value=value_type)
      value_names += ",\n\t\t\t\t\t\"" + value_type + "\":%s"
      path_str += ", \"" + value_type + "\""
    updateString = UPDATE_STRING_TEMPLATE.format(self=self, value_names=value_names, path_str=path_str)
    self.code = POLICY_SCHEMA_TEMPLATE.format(self=self, additional_structs_string=additional_structs_string,
      values2String=values2String, updateString=updateString)

def raise_response_error(key, response, source):
  """Raise an error that a given key was not found in a response."""
  raise KeyError('Could not find {} in response {} from {}'.format(key, response, source))

def write_code(output_path, policies_schemas):
  """Write Go code for the policy schemas to the given file."""
  with open(output_path, 'w') as fh:
    fh.write(HEADER)
    for policy_schema in policies_schemas:
      fh.write(policy_schema.code)

def parse_enum(field, enums):
  """Parse enums for all enum values belonging to field.

  Used during parse_values and returns a string representation
  of the enum in Go.
  """
  enumStr = "type "
  for enum in enums:
    if "value" not in enum:
      continue
    if "name" not in enum:
      continue
    if "typeName" not in field:
      continue
    if field["typeName"] == enum["name"]:
      enumStr += enum["name"] + " int\n\n const (\n"
      count = 0
      for enumEntry in enum["value"]:
        if "name" not in enumEntry:
          continue
        if count == 0:
          enumStr += "\t" + enumEntry["name"] + " " + enum["name"] + " = iota // " + str(count) + "\n"
        else:
          enumStr += "\t" + enumEntry["name"] + " // " + str(count) + "\n"
        count+=1
      enumStr += ")\n\n"
  return enumStr

def parse_values(definition, messages, types, additional_structs, duplication_set):
  """Parse the definition of a policy schema for all used types, structs and enums.

  Used during parse_schema. Fills types and additional_structs.
  Checks if we got duplicates with duplication_set
  """
  enumStrs = []
  firstMessage = True
  for message in messages:
    if "field" not in message:
      continue
    if "name" not in message:
      continue
    if message["name"] in duplication_set:
      continue
    duplication_set.add(message["name"])

    structStr = "type " + message["name"] + " struct {\n"
    setFuncStr1 = "func (p *" + message["name"] + ") SetValues("
    setFuncStr2 = "{\n\t"
    fields = message["field"]
    firstField = True
    for field in message["field"]:
      if "type" not in field:
        continue
      if "label" not in field:
        continue

      if firstMessage:
        types.append(field["name"])
      if not firstField:
        setFuncStr1 += ", "
      structStr += "\t" + field["name"] + " "
      setFuncStr1 += field["name"]
      setFuncStr2 += "p." + field["name"] + " = " + field["name"] + "\n"
      if field["label"] == "LABEL_REPEATED":
        structStr += "[]"
        setFuncStr1 += "[] "
      typeName = ""
      if field["type"] == "TYPE_ENUM":
        if "enumType" not in definition:
          continue
        typeName = field["typeName"]
        if field["typeName"] not in duplication_set:
          enumStrs.append(parse_enum(field, definition["enumType"]))
        duplication_set.add(field["typeName"])
      elif field["type"] == "TYPE_MESSAGE":
        typeName = field["typeName"]
      else:
        typeName = TYPES_SCHEMA_TO_GO[field["type"]]
      structStr += typeName + "\n"
      setFuncStr1 += " " + typeName
      firstField = False
    firstMessage = False
    structStr += "}\n" + setFuncStr1 + ")" + setFuncStr2 + "}\n\n"
    additional_structs.append(structStr)
    additional_structs.extend(enumStrs)

def parse_schema(policySchema, duplication_set):
  """Parse a policy schema and return PolicySchema() filled with the parsed data."""
  if "definition" not in policySchema:
    return PolicySchema("")
  definition = policySchema["definition"]
  if "messageType" not in definition:
    return PolicySchema("")
  messages = definition["messageType"]
  if "name" not in policySchema:
    return PolicySchema("")
  link = policySchema["name"].split("/")[-1]
  if "name" not in messages[0]:
    return PolicySchema("")

  name = messages[0]["name"] # The fist message struct holds the policy itself.
  types = []
  additional_structs = []
  parse_values(definition, messages, types, additional_structs, duplication_set)

  # Fill the PolicySchema and return it.
  ret = PolicySchema(name)
  ret.link = link
  ret.additional_structs = additional_structs
  ret.types = types
  ret.updateString = None
  return ret

def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('--out', dest='out', default=OUTPUT_FILEPATH, type=str,
                      help=('Optional filepath for the output. By default, '
                            'use the path where the output is checked in.'))
  parser.add_argument('--tape_client_secret', dest='tape_client_secret', type=str,
                      help=('Client secret for the TAPE default service account'))

  args = parser.parse_args()
  if not args.tape_client_secret:
    print('Please provide the client secret of the default TAPE service account. If you don\'t have access to it please contact cros-engprod-muc@google.com to regenerate the policy_schemas.go file for you.')
    return

  # We want to retrieve the latest policySchemas from TAPE.
  # First we need an authorization code.
  url = OAUTH_AUTH_URL + "?client_id=" + TAPE_CLIENT_ID
  url += "&response_type=code&scope=openid%20email&access_type=offline&redirect_uri=urn:ietf:wg:oauth:2.0:oob"

  print("Visit the following URL to get the authorization code and copy-paste it below.:\n" + url)
  authorization_code = input("Authorization code:")

  # Request a refresh_token with the authorization code.
  url = OAUTH_TOKEN_URL
  payload = [("client_id", TAPE_CLIENT_ID),
  ("client_secret", args.tape_client_secret), ("code",authorization_code),
  ("redirect_uri", "urn:ietf:wg:oauth:2.0:oob"), ("grant_type","authorization_code")]
  r = requests.post(url, data=payload)
  if "refresh_token" not in r.json():
    r.close()
    raise_response_error("refresh_token", r.json(), OAUTH_TOKEN_URL)
  refresh_token = r.json()["refresh_token"]
  r.close()

  # Use the refresh_token to retrieve the oauth2 token for identification against the IAP of TAPE.
  payload = [("client_id", TAPE_CLIENT_ID),
  ("client_secret", args.tape_client_secret), ("refresh_token", refresh_token),
  ("grant_type", "refresh_token"), ("audience", TAPE_IAP_CLIENT_ID)]
  r = requests.post(url, data=payload)
  if "id_token" not in r.json():
    r.close()
    raise_response_error("id_token", r.json(), OAUTH_TOKEN_URL)
  id_token=r.json()["id_token"]
  r.close()

  # Finally make a call to TAPE to retrieve all policy schemas.
  url = POLICY_SCHEMAS_URL
  token = "Bearer " + id_token
  headers = {'Authorization': token}
  r = requests.get(url, headers=headers)
  if "policySchemas" not in r.json():
    r.close()
    raise_response_error("policySchemas", r.json(), POLICY_SCHEMAS_URL)
  policySchemas = r.json()["policySchemas"]

  # Parse the policy schemas.
  policy_schema_objs = []
  duplication_set = set()
  for policySchema in policySchemas:
    policy_schema_obj = parse_schema(policySchema, duplication_set)
    policy_schema_obj.generate_code()
    policy_schema_objs.append(policy_schema_obj)

  # Generate and write the code to the file and check it with gofmt.
  write_code(args.out, policy_schema_objs)
  subprocess.run(["gofmt", "-w", args.out]).check_returncode()

if __name__ == '__main__':
  main()

