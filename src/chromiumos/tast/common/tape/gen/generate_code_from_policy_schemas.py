#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2021 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Tool for creating go code from policy schemas.

Used to create defs.go for policy Tast tests using TAPE.

Generating a new defs.go file:
 Run the script.
 > ./generate_code_from policy_schemas.py
 Use a CL to checkin the updated file.
"""

import argparse
import json
import os
import subprocess

# Default output filename and path.
OUTPUT_FILENAME = 'defs.go'
OUTPUT_FILEPATH = os.path.join(os.path.dirname(__file__), '..',
  OUTPUT_FILENAME)

# Default input filename and path.
INPUT_FILENAME = 'policy_schemas.json'
INPUT_FILEPATH = os.path.join(os.path.dirname(__file__), '..',
  INPUT_FILENAME)

# Header for the GO code.
HEADER = """// Copyright 2021 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Code generated by generate_policy_schemas.py. DO NOT EDIT.
// Run the generator in gen/generate_policy_schemas.py instead.

package tape
"""

# Note: A double '{{' is to produce a single '{' in the formatted Go code.

# Template for a single policy. Is formatted using a PolicySchema object.
POLICY_SCHEMA_TEMPLATE = """
///////////////////////////////////////////////////////////////////////////////
// {self.name}
///////////////////////////////////////////////////////////////////////////////

{additional_structs_string}
func (p *{self.name}) MarshalJSON(orgunit string) ([]byte, error) {{
\treturn marshalJSON(orgunit, "{self.uri}", p, []string{{{path_str}}})
}}
"""

# Conversion of policy schema types to Go types.
TYPES_SCHEMA_TO_GO = {
    'TYPE_STRING': 'string',
    'TYPE_INT32': 'int',
    'TYPE_INT64': 'int64',
    'TYPE_BOOL': 'bool'
}

class PolicySchema:
  """Class representing a single policy schema, used with
  POLICY_SCHEMA_TEMPLATE."""
  def __init__(self, name):
    # name: Name of this policy as defined in the policy schema.
    self.name = name

    # Set initial values for variables which may be overwritten during code
    # generation.
    # uri: The uri of this policy schema.
    self.uri = ''
    # additional_structs: All structs and enums needed for this policy schema.
    self.additional_structs = None
    # types: The names of all types used to update the policy schema.
    self.types = None
    # code: All code that is generated for the policy schema.
    self.code = None

  def generate_code(self):
    additional_structs_string = ''.join(self.additional_structs)
    path_str = ', '.join([f'"{type}"' for type in self.types])
    self.code = POLICY_SCHEMA_TEMPLATE.format(self=self, path_str=path_str,
      additional_structs_string=additional_structs_string)

def raise_schema_error(key, schema):
  """Raise an error that a given key was not found in a response."""
  raise KeyError(f'Could not find {key} in schema {schema}')

def write_code(output_path, policies_schemas):
  """Write Go code for the policy schemas to the given file."""
  with open(output_path, 'w') as fh:
    fh.write(HEADER)
    for policy_schema in policies_schemas:
      fh.write(policy_schema.code)

def parse_enum(field, enums):
  """Parse enums for all enum values belonging to field.

  Used during parse_values and returns a string representation
  of the enum in Go.
  """
  for enum in enums:
    if 'value' not in enum:
      continue
    if 'name' not in enum:
      continue
    if field['typeName'] != enum['name']:
      continue
    enum_prefix =  enum["name"].upper()
    enum_str = f'type {enum["name"]} int\n\n const (\n'
    count = 0
    for enum_entry in enum['value']:
      if 'name' not in enum_entry:
        continue
      enum_str += f'\t{enum_prefix}_{enum_entry["name"]}'
      if count == 0:
        enum_str += f' {enum["name"]} = iota // {count}\n'
      else:
        enum_str += f' // {count}\n'
      count+=1
    enum_str += ')\n\n'
  return enum_str

def parse_values(definition, messages, duplication_set):
  """Parse the definition of a policy schema for all used types, structs and
  enums.

  Used during parse_schema. Returns types and additional_structs arrays.
  Checks if we got duplicates with duplication_set
  """
  types = []  # Holds the types of the fields in the PolicySchema.
  additional_structs = []  # Holds all structs we need for the PolicySchema.
  enum_strs = []  # Array to store all enums found in the schema.
  first_message = True

  # Every message in the schema represents a proto with the first one being the
  # policy itself. Those will be converted to go structs.
  for message in messages:
    if 'field' not in message:
      continue
    if 'name' not in message:
      continue
    if message['name'] in duplication_set:
      continue
    duplication_set.add(message['name'])

    struct_str = f'type {message["name"]} struct {{\n'
    # The fields of the message are also the fields of the struct.
    for field in message['field']:
      if 'type' not in field:
        continue
      if 'label' not in field:
        continue
      # The updateMask field in ChromePolicy API call to set this policy schema
      # we need the types of the first message which represents the policy
      # itself.
      if first_message:
        types.append(field['name'])
      # Add the field to our struct with a capital letter so it gets exported.
      struct_str += f'\t{field["name"][:1].upper()}{field["name"][1:]} '
      # If the message has the label LABEL_REPEATED it is an array.
      if field['label'] == 'LABEL_REPEATED':
        struct_str += '[]'
      type_name = ''
      if field['type'] == 'TYPE_ENUM':
        if 'enumType' not in definition:
          continue
        if 'typeName' not in field:
          continue
        type_name = field['typeName']
        if field['typeName'] not in duplication_set:
          enum_strs.append(parse_enum(field, definition['enumType']))
        duplication_set.add(field['typeName'])
      elif field['type'] == 'TYPE_MESSAGE':
        type_name = field['typeName']
      else:
        type_name = TYPES_SCHEMA_TO_GO[field['type']]
      struct_str += f'{type_name} `json:"{field["name"]}"`\n'
    first_message = False
    struct_str += '}\n\n'
    additional_structs.append(struct_str)
    additional_structs.extend(enum_strs)

  return types, additional_structs

def parse_schema(policy_schema, duplication_set):
  """Parse a policy schema and return PolicySchema() filled with the parsed
  data."""
  if 'definition' not in policy_schema:
    raise_schema_error('definition', policy_schema)
  definition = policy_schema['definition']
  if 'messageType' not in definition:
    raise_schema_error('definition', definition)
  messages = definition['messageType']
  if 'name' not in policy_schema:
    raise_schema_error('name', policy_schema)
  uri = policy_schema['name'].split('/')[-1]
  if 'name' not in messages[0]:
    raise_schema_error('name', messages[0])

  name = messages[0]['name']  # The fist message struct holds the policy itself.
  types, additional_structs = parse_values(definition, messages, duplication_set)

  # Fill the PolicySchema and return it.
  ret = PolicySchema(name)
  ret.uri = uri
  ret.additional_structs = additional_structs
  ret.types = types
  return ret

def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('--out', dest='out', default=OUTPUT_FILEPATH, type=str,
    help=('Optional filepath for the output. By default, use the path where '
    'the output is checked in.'))
  parser.add_argument('--input', dest='input', default=INPUT_FILEPATH,
    type=str, help=('Optional filepath for the input. By default, use the path'
    ' where the input is checked in.'))

  args = parser.parse_args()

  with open(args.input, 'r') as fh:
    policy_schemas = json.load(fh)

  # Parse the policy schemas.
  policy_schema_objs = []
  # duplication_set is used to prevent us from having multiples of the same
  # structs and enums.
  duplication_set = set()
  for policy_schema in policy_schemas:
    policy_schema_obj = parse_schema(policy_schema, duplication_set)
    policy_schema_obj.generate_code()
    policy_schema_objs.append(policy_schema_obj)

  # Generate and write the code to the file and check it with gofmt.
  write_code(args.out, policy_schema_objs)
  subprocess.run(['gofmt', '-w', args.out]).check_returncode()

if __name__ == '__main__':
  main()
