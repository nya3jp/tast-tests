// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package eap

import (
	"reflect"
	"testing"

	"chromiumos/tast/common/wifi/security"
)

func TestEAPDefault(t *testing.T) {
	expectedConf := &Config{
		fileSuffix:     "suffix",
		identity:       "chromeos",
		serverCACert:   "CA",
		serverCert:     "Cert",
		serverKey:      "Key",
		serverEAPUsers: "* TLS",
		tpmID:          "0000000000000000",
	}
	// Calling without option to check default values.
	confInterface, err := NewConfigFactory("CA", "Cert", "Key", FileSuffix("suffix")).Gen()
	if err != nil {
		t.Fatal("failed to Gen with default values")
	}
	conf := confInterface.(*Config)
	if !reflect.DeepEqual(conf, expectedConf) {
		t.Errorf("got %v, want %v", conf, expectedConf)
	}
}

func TestTPMID(t *testing.T) {
	for testi, test := range []struct {
		fac        security.ConfigFactory
		shouldFail bool
	}{
		{NewConfigFactory("A", "B", "C", FileSuffix("D"), TPMID("00")), false},
		{NewConfigFactory("A", "B", "C", FileSuffix("D"), TPMID("aA")), false},
		{NewConfigFactory("A", "B", "C", FileSuffix("D"), TPMID("FF")), false},
		{NewConfigFactory("A", "B", "C", FileSuffix("D"), TPMID("Af")), false},
		{NewConfigFactory("A", "B", "C", FileSuffix("D"), TPMID("0123456789abcdefABCDEF")), false},

		{NewConfigFactory("A", "B", "C", FileSuffix("D"), TPMID("1")), true},
		{NewConfigFactory("A", "B", "C", FileSuffix("D"), TPMID("123")), true},
		{NewConfigFactory("A", "B", "C", FileSuffix("D"), TPMID("zz")), true},
	} {
		if _, err := test.fac.Gen(); err != nil {
			if !test.shouldFail {
				t.Errorf("Test %d failed to Gen Config", testi)
			}
		} else {
			if test.shouldFail {
				t.Errorf("Test %d should not pass Config.validate", testi)
			}
		}
	}
}

func TestEAP(t *testing.T) {
	fac := NewConfigFactory(
		"ServerCACert", "ServerCert", "ServerKey",
		FileSuffix("FileSuffix"),
		Identity("testing"),
		ServerEAPUsers(`"example user" TLS`),
		ClientCACert("ClientCACert"),
		ClientCert("ClientCert"),
		ClientKey("ClientKey"),
		TPMID("8888"),
	)
	expectedConf := &Config{
		fileSuffix:     "FileSuffix",
		identity:       "testing",
		serverCACert:   "ServerCACert",
		serverCert:     "ServerCert",
		serverKey:      "ServerKey",
		serverEAPUsers: `"example user" TLS`,
		clientCACert:   "ClientCACert",
		clientCert:     "ClientCert",
		clientKey:      "ClientKey",
		tpmID:          "8888",
	}
	expectedHostapdConfig := map[string]string{
		"ieee8021x":     "1",
		"eap_server":    "1",
		"ca_cert":       "/tmp/server_ca_cert_file",
		"server_cert":   "/tmp/server_cert_file",
		"private_key":   "/tmp/server_key_file",
		"eap_user_file": "/tmp/server_eap_user_cert_file",
	}
	expectedShillProperties := map[string]interface{}{
		"EAP.Identity":  "testing",
		"EAP.PIN":       "77777",
		"EAP.CACertPEM": []string{"ClientCACert"},
		"EAP.CertID":    "2:8888",
		"EAP.KeyID":     "2:8888",
	}

	confInterface, err := fac.Gen()
	if err != nil {
		t.Fatal("failed to Gen Config")
	}
	conf := confInterface.(*Config)
	if !reflect.DeepEqual(conf, expectedConf) {
		t.Errorf("got %v, want %v", conf, expectedConf)
	}

	// Calling HostapdConfig before InstallRouterCredentials should failed.
	if _, err := conf.HostapdConfig(); err == nil {
		t.Error("expect failure due to calling HostapdConfig without InstallRouterCredentials")
	}

	// Normally, these should be generated by conf.InstallRouterCredentials().
	conf.ServerCACertFile = "/tmp/server_ca_cert_file"
	conf.ServerCertFile = "/tmp/server_cert_file"
	conf.ServerKeyFile = "/tmp/server_key_file"
	conf.ServerEAPUsersFile = "/tmp/server_eap_user_cert_file"

	// Check hostapd config.
	hostapdConfig, err := conf.HostapdConfig()
	if err != nil {
		t.Error("failed to generate hostapd config")
	}
	if !reflect.DeepEqual(hostapdConfig, expectedHostapdConfig) {
		t.Errorf("got %v, want %v", hostapdConfig, expectedHostapdConfig)
	}

	// Calling ShillServiceProperties before InstallClientCredentials should failed.
	if _, err := conf.ShillServiceProperties(); err == nil {
		t.Error("expect failure due to calling ShillServiceProperties without InstallClientCredentials")
	}

	// Normally, these should be generated by conf.InstallClientCredentials().
	conf.Pin = "77777"
	conf.ClientSlotID = 2

	// Check shill properties.
	shillProperties, err := conf.ShillServiceProperties()
	if err != nil {
		t.Error("failed to generate shill properties")
	}
	if !reflect.DeepEqual(shillProperties, expectedShillProperties) {
		t.Errorf("got %v, want %v", shillProperties, expectedShillProperties)
	}
}
