// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package eap

import (
	"fmt"
	"reflect"
	"testing"

	"chromiumos/tast/common/crypto/certificate"
)

func serverCred() certificate.Credential {
	return certificate.Credential{Cert: "ServerCert", PrivateKey: "ServerKey"}
}

func clientCred() certificate.Credential {
	return certificate.Credential{Cert: "ClientCert", PrivateKey: "ClientKey"}
}

func TestEAPDefault(t *testing.T) {
	expectedConf := &Config{
		fileSuffix:     "suffix",
		identity:       "chromeos",
		serverCACert:   "CA",
		serverCred:     serverCred(),
		serverEAPUsers: "* TLS",
	}
	// Calling without option to check default values.
	confInterface, err := NewConfigFactory("CA", serverCred(), FileSuffix("suffix")).Gen()
	if err != nil {
		t.Fatal("failed to Gen with default values")
	}
	conf := confInterface.(*Config)
	if !reflect.DeepEqual(conf, expectedConf) {
		t.Errorf("got %v, want %v", conf, expectedConf)
	}
}

func TestEAP(t *testing.T) {
	const (
		serverCA   = "serverCACert"
		fileSuffix = "FileSuffix"
		identity   = "testing"
		eapUsers   = `"example user" TLS`
		clientCA   = "clientCACert"
	)
	fac := NewConfigFactory(
		serverCA, serverCred(),
		FileSuffix(fileSuffix),
		Identity(identity),
		ServerEAPUsers(eapUsers),
		ClientCACert(clientCA),
		ClientCred(clientCred()),
	)
	expectedConf := &Config{
		fileSuffix:     fileSuffix,
		identity:       identity,
		serverCACert:   serverCA,
		serverCred:     serverCred(),
		serverEAPUsers: eapUsers,
		clientCACert:   clientCA,
		clientCred:     clientCred(),
	}

	confInterface, err := fac.Gen()
	if err != nil {
		t.Fatal("failed to Gen Config")
	}
	conf := confInterface.(*Config)
	if !reflect.DeepEqual(conf, expectedConf) {
		t.Errorf("got %v, want %v", conf, expectedConf)
	}

	const (
		caPath      = "/tmp/server_ca_cert_file"
		certPath    = "/tmp/server_cert_file"
		keyPath     = "/tmp/server_key_file"
		eapUserPath = "/tmp/server_eap_user_cert_file"
	)
	expectedHostapdConfig := map[string]string{
		"ieee8021x":     "1",
		"eap_server":    "1",
		"ca_cert":       caPath,
		"server_cert":   certPath,
		"private_key":   keyPath,
		"eap_user_file": eapUserPath,
	}
	// Calling HostapdConfig before InstallRouterCredentials should failed.
	if _, err := conf.HostapdConfig(); err == nil {
		t.Error("expect failure due to calling HostapdConfig without InstallRouterCredentials")
	}

	// Normally, these should be generated by conf.InstallRouterCredentials().
	conf.ServerCACertFile = caPath
	conf.ServerCertFile = certPath
	conf.ServerKeyFile = keyPath
	conf.ServerEAPUsersFile = eapUserPath

	// Check hostapd config.
	hostapdConfig, err := conf.HostapdConfig()
	if err != nil {
		t.Error("failed to generate hostapd config")
	}
	if !reflect.DeepEqual(hostapdConfig, expectedHostapdConfig) {
		t.Errorf("got %v, want %v", hostapdConfig, expectedHostapdConfig)
	}

	const (
		slotID    = 2
		pin       = "77777"
		netCertID = "8888"
	)
	expectedShillProperties := map[string]interface{}{
		"EAP.Identity":  identity,
		"EAP.PIN":       pin,
		"EAP.CACertPEM": []string{clientCA},
		"EAP.CertID":    fmt.Sprintf("%d:%s", slotID, netCertID),
		"EAP.KeyID":     fmt.Sprintf("%d:%s", slotID, netCertID),
	}
	// Calling ShillServiceProperties before InstallClientCredentials should failed.
	if _, err := conf.ShillServiceProperties(); err == nil {
		t.Error("expect failure due to calling ShillServiceProperties without InstallClientCredentials")
	}

	// Normally, these should be generated by conf.InstallClientCredentials().
	conf.ClientSlotID = slotID
	conf.Pin = pin
	conf.NetCertID = netCertID

	// Check shill properties.
	shillProperties, err := conf.ShillServiceProperties()
	if err != nil {
		t.Error("failed to generate shill properties")
	}
	if !reflect.DeepEqual(shillProperties, expectedShillProperties) {
		t.Errorf("got %v, want %v", shillProperties, expectedShillProperties)
	}
}
