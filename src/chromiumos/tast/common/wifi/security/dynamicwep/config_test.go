// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package dynamicwep

import (
	"fmt"
	"reflect"
	"testing"

	"chromiumos/tast/common/crypto/certificate"
	"chromiumos/tast/common/wifi/security/eap"
)

func serverCred() certificate.Credential {
	return certificate.Credential{Cert: "ServerCert", PrivateKey: "ServerKey"}
}

func clientCred() certificate.Credential {
	return certificate.Credential{Cert: "ClientCert", PrivateKey: "ClientKey"}
}

// Common settings for the tests below.
const (
	caCert = "ServerCACert"

	fileSuffix    = "FileSuffix"
	rekeyPeriod20 = 20
	rekeyPeriod10 = 10

	caCertPath  = "/tmp/server_ca_cert_file"
	certPath    = "/tmp/server_cert_file"
	keyPath     = "/tmp/server_key_file"
	eapUserPath = "/tmp/server_eap_user_cert_file"

	slotID    = 2
	pin       = "77777"
	netCertID = "8888"
)

// TestDynamicWEPDefault tests the default behavior of NewConfigFactory.
func TestDynamicWEPDefault(t *testing.T) {
	// Calling without option to check default values.
	confInterface, err := NewConfigFactory(caCert, serverCred()).Gen()
	if err != nil {
		t.Fatal("failed to Gen with default values")
	}

	conf := confInterface.(*Config)
	// eap.Config should be tested in eap package.
	conf.Config = nil

	expectedConf := &Config{
		useShortKey: false,
		rekeyPeriod: rekeyPeriod20,
	}

	if !reflect.DeepEqual(conf, expectedConf) {
		t.Fatalf("got %v, want %v", conf, expectedConf)
	}
}

// TestGen tests the result of ConfigFactory.Gen.
func TestGen(t *testing.T) {
	// Build an expected Config.
	// We need to go through eap.NewConfigFactory and eap.ConfigFactory.Gen, then assign
	// the result to Config, because the fields of eap.Config are not exported.
	expectedEAPConfInterface, err := eap.NewConfigFactory(
		caCert, serverCred(),
		eap.FileSuffix(fileSuffix),
		eap.ClientCACert(caCert),
		eap.ClientCred(clientCred()),
	).Gen()
	if err != nil {
		t.Fatal("failed to Gen eap.Config, there should be a bug in eap package")
	}
	expectedConf := &Config{
		Config:      expectedEAPConfInterface.(*eap.Config),
		useShortKey: true,
		rekeyPeriod: rekeyPeriod10,
	}

	confInterface, err := NewConfigFactory(
		caCert, serverCred(),
		RekeyPeriod(rekeyPeriod10),
		UseShortKey(),
		FileSuffix(fileSuffix),
		ClientCACert(caCert),
		ClientCred(clientCred()),
	).Gen()
	if err != nil {
		t.Fatal("failed to Gen Config")
	}
	conf := confInterface.(*Config)

	if !reflect.DeepEqual(conf, expectedConf) {
		t.Errorf("got %v, want %v", conf, expectedConf)
	}
}

// TestHostapdConfig tests the result of Config.HostapdConfig.
func TestHostapdConfig(t *testing.T) {
	expectedHostapdConfig := map[string]string{
		"wep_key_len_broadcast": "5",
		"wep_key_len_unicast":   "5",
		"wep_rekey_period":      "10",

		// Generated by eap.Config.
		"ieee8021x":     "1",
		"eap_server":    "1",
		"ca_cert":       caCertPath,
		"server_cert":   certPath,
		"private_key":   keyPath,
		"eap_user_file": eapUserPath,
	}

	confInterface, err := NewConfigFactory(
		caCert, serverCred(),
		RekeyPeriod(rekeyPeriod10),
		UseShortKey(),
		FileSuffix(fileSuffix),
		ClientCACert(caCert),
		ClientCred(clientCred()),
	).Gen()
	if err != nil {
		t.Fatal("failed to Gen Config")
	}
	conf := confInterface.(*Config)

	// Calling HostapdConfig before InstallRouterCredentials should failed.
	if _, err := conf.HostapdConfig(); err == nil {
		t.Error("expect failure due to calling HostapdConfig without InstallRouterCredentials")
	}

	// Normally, these should be generated by conf.InstallRouterCredentials().
	conf.ServerCACertFile = caCertPath
	conf.ServerCertFile = certPath
	conf.ServerKeyFile = keyPath
	conf.ServerEAPUsersFile = eapUserPath

	// Check hostapd config.
	hostapdConfig, err := conf.HostapdConfig()
	if err != nil {
		t.Error("failed to generate hostapd config")
	}
	if !reflect.DeepEqual(hostapdConfig, expectedHostapdConfig) {
		t.Errorf("got %v, want %v", hostapdConfig, expectedHostapdConfig)
	}
}

// TestShillServiceProperties tests the result of Config.ShillServiceProperties.
func TestShillServiceProperties(t *testing.T) {
	expectedShillProperties := map[string]interface{}{
		"EAP.KeyMgmt": "IEEE8021X",

		// Generated by eap.Config.
		"EAP.Identity":  "chromeos",
		"EAP.PIN":       pin,
		"EAP.CACertPEM": []string{caCert},
		"EAP.CertID":    fmt.Sprintf("%d:%s", slotID, netCertID),
		"EAP.KeyID":     fmt.Sprintf("%d:%s", slotID, netCertID),
	}

	confInterface, err := NewConfigFactory(
		caCert, serverCred(),
		RekeyPeriod(rekeyPeriod10),
		UseShortKey(),
		FileSuffix(fileSuffix),
		ClientCACert(caCert),
		ClientCred(clientCred()),
	).Gen()
	if err != nil {
		t.Fatal("failed to Gen Config")
	}
	conf := confInterface.(*Config)

	// Calling ShillServiceProperties before InstallClientCredentials should failed.
	if _, err := conf.ShillServiceProperties(); err == nil {
		t.Error("expect failure due to calling ShillServiceProperties without InstallClientCredentials")
	}

	// Normally, these should be generated by conf.InstallClientCredentials().
	conf.ClientSlotID = slotID
	conf.Pin = pin
	conf.NetCertID = netCertID

	// Check shill properties.
	shillProperties, err := conf.ShillServiceProperties()
	if err != nil {
		t.Error("failed to generate shill properties")
	}
	if !reflect.DeepEqual(shillProperties, expectedShillProperties) {
		t.Errorf("got %v, want %v", shillProperties, expectedShillProperties)
	}
}
