// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package tunneled1x

import (
	"reflect"
	"testing"

	"chromiumos/tast/common/crypto/certificate"
	"chromiumos/tast/common/wifi/security/wpaeap"
)

func serverCred() certificate.Credential {
	return certificate.Credential{Cert: "ServerCert", PrivateKey: "ServerKey"}
}

const (
	serverCACert   = "ServerCACert"
	clientCACert   = "ClientCACert"
	identity       = "testing"
	serverPassword = "ServerPassword"
	clientPassword = "ClientPassword"

	fileSuffix      = "FileSuffix"
	altSubjectMatch = `{"Type":"DNS","Value":"wrong_dns.com"}`
	tpmID           = "8888"

	pin    = "77777"
	slotID = 2
)

// TestGen tests the result of ConfigFactory.Gen.
func TestGen(t *testing.T) {
	for testi, testcase := range []struct {
		expectedWPAEAPFac *wpaeap.ConfigFactory
		expectedConf      *Config
		fac               *ConfigFactory
	}{
		{
			fac: NewConfigFactory(
				serverCACert, serverCred(), clientCACert, identity, serverPassword,
				FileSuffix(fileSuffix),
			),
			expectedWPAEAPFac: wpaeap.NewConfigFactory(
				serverCACert, serverCred(),
				wpaeap.FileSuffix(fileSuffix),
				wpaeap.Identity(identity),
				wpaeap.ClientCACert(clientCACert),
				wpaeap.TPMID(tpmID),
				wpaeap.ServerEAPUsers("* PEAP\n"+`"testing" MD5 "ServerPassword" [2]`),
			),
			expectedConf: &Config{
				clientPassword: serverPassword,
				innerProtocol:  Layer2TypeMD5,
			},
		},
		{
			fac: NewConfigFactory(
				serverCACert, serverCred(), clientCACert, identity, serverPassword,
				OuterProtocol(Layer1TypeTTLS), InnerProtocol(Layer2TypeGTC),
				ClientPassword(clientPassword), FileSuffix(fileSuffix),
				AltSubjectMatch([]string{altSubjectMatch}),
			),
			expectedWPAEAPFac: wpaeap.NewConfigFactory(
				serverCACert, serverCred(),
				wpaeap.AltSubjectMatch([]string{altSubjectMatch}),
				wpaeap.FileSuffix(fileSuffix),
				wpaeap.Identity(identity),
				wpaeap.ClientCACert(clientCACert),
				wpaeap.TPMID(tpmID),
				wpaeap.ServerEAPUsers("* TTLS\n"+`"testing" GTC "ServerPassword" [2]`),
			),
			expectedConf: &Config{
				clientPassword: clientPassword,
				innerProtocol:  Layer2TypeGTC,
			},
		},
	} {
		// Build a expected Config.
		// We need to go through wpaeap.NewConfigFactory and wpaeap.ConfigFactory.Gen, then
		// assign the result to Config, because the fields of wpaeap.Config are not exported.
		expectedWPAEAPConfInterface, err := testcase.expectedWPAEAPFac.Gen()
		if err != nil {
			t.Fatalf("test %d: falied to Gen wpaeap.Config, there should be a bug in wpaeap package: ", testi)
		}
		testcase.expectedConf.Config = expectedWPAEAPConfInterface.(*wpaeap.Config)

		// Append the TPMID option manually because TPMID is not re-wrapped in this package.
		// However, we don't want the auto generating during unitest.
		testcase.fac.wpaeapOps = append(testcase.fac.wpaeapOps, wpaeap.TPMID(tpmID))
		confInterface, err := testcase.fac.Gen()
		if err != nil {
			t.Fatalf("test %d: failed to Gen Config", testi)
		}
		conf := confInterface.(*Config)

		if !reflect.DeepEqual(conf, testcase.expectedConf) {
			t.Errorf("test %d: got %v, want %v", testi, conf, testcase.expectedConf)
		}
	}
}

// TestShillServiceProperties tests the result of Config.ShillServiceProperties.
func TestShillServiceProperties(t *testing.T) {
	expectedShillProperties := map[string]interface{}{
		"EAP.Password": clientPassword,
		"EAP.InnerEAP": "auth=PAP",

		// Generated by wpaeap.Config.
		"EAP.UseSystemCAs":                true,
		"EAP.SubjectAlternativeNameMatch": []string{altSubjectMatch},

		// Generated by eap.Config.
		"EAP.Identity":  identity,
		"EAP.CACertPEM": []string{clientCACert},
	}

	fac := NewConfigFactory(
		serverCACert, serverCred(), clientCACert, identity, serverPassword,
		OuterProtocol(Layer1TypeTTLS), InnerProtocol(Layer2TypeTTLSPAP),
		ClientPassword(clientPassword), FileSuffix(fileSuffix),
		AltSubjectMatch([]string{altSubjectMatch}),
	)
	fac.wpaeapOps = append(fac.wpaeapOps, wpaeap.TPMID(tpmID))
	confInterface, err := fac.Gen()
	if err != nil {
		t.Fatal("failed to Gen Config")
	}
	conf := confInterface.(*Config)

	// Check shill properties.
	shillProperties, err := conf.ShillServiceProperties()
	if err != nil {
		t.Error("failed to generate shill properties")
	}
	if !reflect.DeepEqual(shillProperties, expectedShillProperties) {
		t.Errorf("got %v, want %v", shillProperties, expectedShillProperties)
	}
}
