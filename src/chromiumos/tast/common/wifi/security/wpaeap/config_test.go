// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package wpaeap

import (
	"reflect"
	"testing"

	"chromiumos/tast/common/wifi/security/eap"
)

func TestWPAEAP(t *testing.T) {
	// Calling without option to check default values.
	if _, err := NewConfigFactory("CA", "Cert", "Key").Gen(); err != nil {
		t.Fatal("failed to Gen with default values")
	}

	fac := NewConfigFactory(
		"ServerCACert", "ServerCert", "ServerKey",
		Mode(ModePureWPA2),
		FTMode(FTModeMixed),
		NotUseSystemCAs(),
		AltSubjectMatch([]string{`{"Type":"DNS","Value":"wrong_dns.com"}`}),
		FileSuffix("FileSuffix"),
		Identity("testing"),
		ServerEAPUsers(`"example user" TLS`),
		ClientCACert("ClientCACert"),
		ClientCert("ClientCert"),
		ClientKey("ClientKey"),
		TPMID("8888"),
	)
	eapFac := eap.NewConfigFactory(
		"ServerCACert", "ServerCert", "ServerKey",
		eap.FileSuffix("FileSuffix"),
		eap.Identity("testing"),
		eap.ServerEAPUsers(`"example user" TLS`),
		eap.ClientCACert("ClientCACert"),
		eap.ClientCert("ClientCert"),
		eap.ClientKey("ClientKey"),
		eap.TPMID("8888"),
	)
	expectedConf := &Config{
		mode:            ModePureWPA2,
		ftMode:          FTModeMixed,
		useSystemCAs:    false,
		altSubjectMatch: []string{`{"Type":"DNS","Value":"wrong_dns.com"}`},
	}
	expectedHostapdConfig := map[string]string{
		"wpa":          "2",
		"wpa_pairwise": "CCMP",
		"wpa_key_mgmt": "WPA-EAP FT-EAP",

		// Generated by eap.Config.
		"ieee8021x":     "1",
		"eap_server":    "1",
		"ca_cert":       "/tmp/server_ca_cert_file",
		"server_cert":   "/tmp/server_cert_file",
		"private_key":   "/tmp/server_key_file",
		"eap_user_file": "/tmp/server_eap_user_cert_file",
	}
	expectedShillProperties := map[string]interface{}{
		"EAP.UseSystemCAs":                false,
		"WiFi.FTEnabled":                  true,
		"EAP.SubjectAlternativeNameMatch": []string{`{"Type":"DNS","Value":"wrong_dns.com"}`},

		// Generated by eap.Config.
		"EAP.Identity":  "testing",
		"EAP.PIN":       "77777",
		"EAP.CACertPEM": []string{"ClientCACert"},
		"EAP.CertID":    "2:8888",
		"EAP.KeyID":     "2:8888",
	}

	confInterface, err := fac.Gen()
	if err != nil {
		t.Fatal("failed to Gen Config")
	}
	eapConfInterface, err := eapFac.Gen()
	if err != nil {
		t.Fatal("falied to Gen eap.Config, there should be a bug in eap package")
	}
	conf := confInterface.(*Config)
	expectedConf.Config = eapConfInterface.(*eap.Config)
	if !reflect.DeepEqual(conf, expectedConf) {
		t.Errorf("got %v, want %v", conf, expectedConf)
	}

	// Calling HostapdConfig before InstallRouterCredentials should failed.
	if _, err := conf.HostapdConfig(); err == nil {
		t.Error("expect failure due to calling HostapdConfig without InstallRouterCredentials")
	}

	// Normally, these should be generated by conf.InstallRouterCredentials().
	conf.ServerCACertFile = "/tmp/server_ca_cert_file"
	conf.ServerCertFile = "/tmp/server_cert_file"
	conf.ServerKeyFile = "/tmp/server_key_file"
	conf.ServerEAPUsersFile = "/tmp/server_eap_user_cert_file"

	// Check hostapd config.
	hostapdConfig, err := conf.HostapdConfig()
	if err != nil {
		t.Error("failed to generate hostapd config")
	}
	if !reflect.DeepEqual(hostapdConfig, expectedHostapdConfig) {
		t.Errorf("got %v, want %v", hostapdConfig, expectedHostapdConfig)
	}

	// Calling ShillServiceProperties before InstallClientCredentials should failed.
	if _, err := conf.ShillServiceProperties(); err == nil {
		t.Error("expect failure due to calling ShillServiceProperties without InstallClientCredentials")
	}

	// Normally, these should be generated by conf.InstallClientCredentials().
	conf.Pin = "77777"
	conf.ClientSlotID = 2

	// Check shill properties.
	shillProperties, err := conf.ShillServiceProperties()
	if err != nil {
		t.Error("failed to generate shill properties")
	}
	if !reflect.DeepEqual(shillProperties, expectedShillProperties) {
		t.Errorf("got %v, want %v", shillProperties, expectedShillProperties)
	}
}
