#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2019 The ChromiumOS Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Tool for creating go code from policy_templates.json.

Used to create defs.go for policy Tast tests.
Notes for adding a new policy:
    - policies with sensitive values will need to add a non-default Equal()
      function here and maybe a non-default UnmarshalAs().
    - policies with hard-to-parse values (e.g. those described by url or
      partial description only) will have to overwrite the schema parsing here.
    - device policies which have unique field setups may need to be handled
      here.

Generating a new defs.go file:
 Use policy_templates.json from chromium to generate the file.
 Use a CL to checkin the updated file.

 Assuming chromiumos and chromium are checkouts for their respective
 projects you need to run:
  > PT=chromium/src/components/policy/resources/policy_templates.json
  > cd chromiumos/src/platform/tast-tests/src/chromiumos/tast/common/policy/gen
  > ./policy_tast_struct_creator.py --policy_templates ${PT}
"""

import argparse
import ast
import os
import subprocess

# Default output filename and path.
OUTPUT_FILENAME = 'defs.go'
OUTPUT_FILEPATH = os.path.join(os.path.dirname(__file__), "..", OUTPUT_FILENAME)

# Header for the GO code.
HEADER = """// Copyright 2019 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Code generated by policy_tast_struct_creator.py. DO NOT EDIT.
// Edit the generator in policy/gen/ instead.

package policy

import (
\t"encoding/json"

\t"github.com/google/go-cmp/cmp"
\t"github.com/google/go-cmp/cmp/cmpopts"
\t"google.golang.org/protobuf/reflect/protoreflect"

\t"chromiumos/tast/errors"
)
"""

# Note: A double "{{" is to produce a single "{" in the formatted Go code.

# Template for a single policy. Is formatted using a Policy object.
POLICY_TEMPLATE = """
// ****************************************************************************
// {self.id}. {self.name}{self.additional_info}
// ****************************************************************************
type {self.name} struct {{
\tStat Status
\tVal {self.type}
}}
{self.additional_structs}
func (p *{self.name}) Name() string      {{ return "{self.name}" }}
func (p *{self.name}) Scope() Scope      {{ return {self.scope} }}
func (p *{self.name}) Status() Status    {{ return p.Stat }}
func (p *{self.name}) UntypedV() interface{{}} {{ return p.Val }}
func (p *{self.name}) UnmarshalAs(m json.RawMessage) (interface{{}}, error) {{
{self.unmarshal}
}}
func (p *{self.name}) SetProto(m *protoreflect.Message) {{
{self.proto_setter}
}}
func (p *{self.name}) Equal(iface interface{{}}) bool {{
{self.eq}
}}
"""

# Header for the section containing definitions of Reference values.
REFERENCE_HEADER = """
// ****************************************************************************
// Reference values (used via '$ref' in JSON Schema).
// ****************************************************************************
"""

# Common part for Open Network Configuration.
ONC_SCHEMA = """
// ****************************************************************************
// Open Network Configuration(ONC) schema.
// Used in OpenNetworkConfiguration and DeviceOpenNetworkConfiguration.
// This is a subset of the full schema. Only the parts that tast tests use are defined here.
// See https://chromium.googlesource.com/chromium/src/+/HEAD/components/onc/docs/onc_spec.md for full schema.
// ****************************************************************************
type ONCEap struct {
\tOuter\tstring\t`json:"Outer"`
\tInner\tstring\t`json:"Inner,omitempty"`
\tIdentity\tstring\t`json:"Identity,omitempty"`
\tPassword\tstring\t`json:"Password,omitempty"`
\tUseSystemCAs\tbool\t`json:"UseSystemCAs"`
}

type ONCWifi struct {
\tAutoConnect\tbool\t`json:"AutoConnect"`
\tEAP\t*ONCEap\t`json:"EAP,omitempty"`
\tSecurity\tstring\t`json:"Security"`
\tSSID\tstring\t`json:"SSID"`
\tPassphrase\tstring\t`json:"Passphrase,omitempty"`
}

type ONCVPN struct {
\tAutoConnect\tbool\t`json:"AutoConnect"`
\tHost\tstring\t`json:"Host"`
\tIPsec\t*ONCIPsec\t`json:"IPsec,omitempty"`
\tL2TP\t*ONCL2TP\t`json:"L2TP,omitempty"`
\tType\tstring\t`json:"Type"`
}

type ONCL2TP struct {
\tUsername\tstring\t`json:"Username"`
\tPassword\tstring\t`json:"Password"`
}

type ONCIPsec struct {
\tAuthenticationType\tstring\t`json:"AuthenticationType"`
\tIKEVersion\tint\t`json:"IKEVersion"`
\tPSK\tstring\t`json:"PSK,omitempty"`
}

type ONCCellular struct {
\tICCID\tstring\t`json:"ICCID"`
\tSMDPAddress\tstring\t`json:"SMDPAddress"`
}

type ONCNetworkConfiguration struct {
\tGUID\tstring\t`json:"GUID"`
\tName\tstring\t`json:"Name"`
\tType\tstring\t`json:"Type"`
\tCellular\t*ONCCellular\t`json:"Cellular,omitempty"`
\tVPN\t*ONCVPN\t`json:"VPN,omitempty"`
\tWiFi\t*ONCWifi\t`json:"WiFi,omitempty"`
}

type ONCGlobalNetworkConfiguration struct {
\tAllowOnlyPolicyNetworksToAutoconnect\tbool\t`json:"AllowOnlyPolicyNetworksToAutoconnect"`
\tAllowOnlyPolicyNetworksToConnect\tbool\t`json:"AllowOnlyPolicyNetworksToConnect"`
\tAllowOnlyPolicyCellularNetworks\tbool\t`json:"AllowOnlyPolicyCellularNetworks"`
\tAllowCellularSimLock\tbool\t`json:"AllowCellularSimLock"`
}

type ONC struct {
\tGlobalNetworkConfiguration\t*ONCGlobalNetworkConfiguration\t`json:"GlobalNetworkConfiguration,omitempty"`
\tNetworkConfigurations\t[]*ONCNetworkConfiguration\t`json:"NetworkConfigurations,omitempty"`
}
"""

# Default values for the contents of function code in POLICY_TEMPLATE.
# Can be overwritten for policies with different behavior.
UNMARSHAL_DEFAULT = """\tvar v {self.type}
\tif err := json.Unmarshal(m, &v); err != nil {{
\t\treturn nil, errors.Wrapf(err, "could not read %s as {self.type}", m)
\t}}
\treturn v, nil"""
EQ_DEFAULT = """\tv, ok := iface.({self.type})
\tif !ok {{
\t\treturn ok
\t}}
\treturn cmp.Equal(p.Val, v, cmpopts.EquateEmpty())"""

# Templates to create additional structs discovered during schema parsing.
VALUE_TEMPLATE = """
type {name} struct {{{members}
}}
"""
PROPERTY_TEMPLATE = """\n\t{go_name} {go_type} `json:"{json_name}{json_options}"`"""
STRING_PROPERTY_TEMPLATE = (
    """\n\t{go_name} {go_type} `json:"{json_name},string"`""")
EMBEDDED_TEMPLATE = """\n\t{go_type}"""


def new_struct(name, members):
  """Return Go code for a new struct with the given name and members.

  To be used when adding a new struct inside a policy value.
  """
  return VALUE_TEMPLATE.format(name=name, members=members)

def new_property(name, go_type):
  """Return Go code for a new named property of a struct of the given type.

  See members input in new_struct().
  """
  json_options = ''
  if go_type.startswith('[]'):
    # Omit a property if its value is the nil slice, instead of converting it to
    # null. (Note that this also applies to an empty slice.)
    json_options = ',omitempty'
  return PROPERTY_TEMPLATE.format(
      go_type=go_type, json_name=name, go_name=go_var_format(name),
      json_options=json_options)

def new_embedded(go_type):
  """Return Go code for an embedded (unnamed) new property of a struct.

  See members input in new_struct().
  """
  return EMBEDDED_TEMPLATE.format(go_type=go_type)

# Converstion of JSONSchema types to Go types.
TYPES_JSON_TO_GO = {
    'string': 'string',
    'integer': 'int',
    'boolean': 'bool'
}

def go_var_format(s):
  """Format given string for use as a Go variable name.

  Exported struct methods must start with an uppercase letter and '-' is not
  a valid character.  Also change snake_case into CamelCase.
  """
  for rm in ['_', '-']:
    if rm in s:
      s = ''.join([upper_first(elt) for elt in s.split(rm)])
  return upper_first(s)

def upper_first(s):
  """Return the given string with the first element capitalized."""
  if s == '':
    return s
  return s[0].upper() + s[1:]

def raise_key_error(key, schema):
  """Raise an error that a given key/keys was/were not found in the schema."""
  raise KeyError('Could not find {} in {}'.format(key, schema))

def raise_type_error(t, schema):
  """Raise an error that the schema contained an unrecognized type."""
  raise KeyError('Unknown type {} in {}.'.format(t, schema))

class SchemaIdError(Exception):
  """Exception class for when policies refer to an unknown JSON schema id."""
  def __init__(self, name):
    Exception.__init__(self, 'Unknown JSON schema reference ' + name)

def parse_schema(name, schema, refs, references_only=False):
  """Return a Go type for the given JSONSchema plus any supporting code.

  Args:
    name: string of name to be used when naming structs
    schema: dict of the JSON schema to be parsed
    refs: dict of all references found by name (id -> Reference Class). Will
        be used to resolve any '$ref' types found.
    references_only: whether this pass is to resolve references.
        True when adding to the refs dict.
        False when generating full code with a populated refs dict.

  Returns:
    Go type and additional Go code (if any)

  Raises:
    KeyError if the schema has an unrecognized format
  """
  # The type which should be used for this value in Go (e.g. 'int', *Struct).
  go_type = ''
  # Any additional code (structs definitions, etc.) needed for this schema.
  code = ''

  if 'id' in schema:
    # This is a named schema that could be used elsewhere.
    # If we're resolving references, continue to parse. Otherwise return
    # the already found value and mark it as used.
    if not references_only:
      if schema['id'] not in refs:
        raise SchemaIdError(schema['id'])
      refs[schema['id']].in_use = True
      return refs[schema['id']].type, ''
    else:
      # Temporarily save the reference as a struct pointer, to handle the case
      # where a struct is referenced within itself.
      name = 'Ref' + schema['id']
      refs[schema['id']] = Reference(name, '*'+name, '')

  # Create a go_type and code for this schema, either from a described type or
  # from a reference to another type.
  if 'type' in schema:
    if schema['type'] == 'object':
      go_type, code = parse_object(name, schema, refs, references_only)
    elif schema['type'] == 'array':
      go_type, code = parse_array(name, schema, refs, references_only)
    elif schema['type'] in TYPES_JSON_TO_GO:
      go_type = TYPES_JSON_TO_GO[schema['type']]
    else:
      raise_type_error(schema['type'], schema)
  elif '$ref' in schema:
    # If this is a known reference, use it. If it is unknown, either skip or
    # raise an error depending on whether this is a references pass.
    if schema['$ref'] in refs:
      go_type = refs[schema['$ref']].type
      if not references_only:
        refs[schema['$ref']].in_use = True
    elif not references_only:
      raise SchemaIdError(schema['$ref'])
  else:
    raise_key_error('type or $ref', schema)

  # If a reference value, update the type in case it is not actually a struct
  # pointer. Return without any code, since additional code for refs is added
  # separately.
  if 'id' in schema and references_only:
    refs[schema['id']].update(go_type, code)
    return go_type, ''

  return go_type, code

def parse_array(name, schema, refs, references_only):
  """Parse an array's schema by returning a slice to the type value.

  Used during parse_schema.  The 'items' element will describe the type of
  the items in the array.  Return a slice to whatever that type is.

  Returns the Go type of this array and any supporting code needed.
  """
  if 'items' not in schema:
    raise_key_error('items', schema)
  item_type, code = parse_schema(name, schema['items'], refs, references_only)
  return '[]'+item_type, code

def parse_object(name, schema, refs, references_only):
  """Parse an object's schema by returning a new struct.

  Used during parse_schema.  The 'properties' or 'additionalProperties' element
  will describe the type of the items in the object (it is a map of
  string -> property).

  Returns the Go type of this object and any supporting code needed.
  """
  # First handle the case where there are no named properties. If only
  # additionalProperties is defined, this object is best represented as a
  # map of string -> additionalProperty, not a struct.
  # If neither field is there, raise an error.
  if 'properties' not in schema:
    if not 'additionalProperties' in schema:
      raise_key_error('properties or additionalProperties', schema)
    add_type, code = parse_schema(name, schema['additionalProperties'], refs,
                                  references_only)
    return 'map[string]' + add_type, code

  # Represent an object with named properties as a struct. Recursively find
  # the Go type for each member of this struct, keeping track of any
  # additional code needed (including this struct definition).
  # The Go type returned here will be a pointer to the struct type.
  go_type = '*' + name
  code = ''
  members = []
  props = schema['properties']
  for key in props:
    # Name each key as a subset of the parent name to avoid name duplication
    # if its a struct.
    key_name = name + go_var_format(key)
    key_type, key_code = parse_schema(key_name, props[key], refs,
                                      references_only)
    members.append(new_property(key, key_type))
    code += key_code

  # If there are still addtionalProperties, add an embedded struct member.
  if 'additionalProperties' in schema:
    add_type, add_code = parse_schema(
        name+'Add', schema['additionalProperties'], refs, references_only)
    members.append(new_embedded(add_type))
    code += add_code

  # paternProperties can contain reference values. If we're evaluating
  # references, continue parsing this.
  if 'patternProperties' in schema and references_only:
    pattern_props = schema['patternProperties']
    for key in pattern_props:
      parse_schema('refs', pattern_props[key], refs, references_only)

  # Create new struct given all the previously found members and their code.
  code = new_struct(name, ''.join(sorted(members))) + code

  return go_type, code

class Reference(object):
  """Class representing a reference type (labeled schema values)."""
  def __init__(self, name, ref_type, code):
    # name: Name used in the JSON schema to refer to this type.
    self.name = name
    # type: Go type used for this value.
    self.type = ref_type
    # code: Any additional code needed to use this value in Go.
    self.code = code
    # in_use: Whether this reference was used in the examined schema.
    self.in_use = ref_type is not None

  def update(self, ref_type, code):
    self.type = ref_type
    self.code = code

class Policy(object):
  """Class representing a single policy, used with POLICY_TEMPLATE."""
  def __init__(self, p, device_field_lookup, one_to_many):
    # name: Name of this policy as defined in policy_templates.
    self.name = p['name']
    # id: Id number of this policy as defined in policy_templates.
    self.id = p['id']
    # one_to_many: Indicates whether this is a legacy one_to_many policy.
    self.one_to_many = one_to_many
    # cros_supported: Whether the policy is currently supported on ChromeOS.
    self.cros_supported = False
    if 'supported_on' in p:
      for elt in p['supported_on']:
      # Search for 'chrome_os:##-', insead of 'chrome_os:##-##', which
      # indicates an end date. This may cause problems for generating this file
      # for non-ToT branches.
        if elt.startswith('chrome_os') and elt.endswith('-'):
          self.cros_supported = True

    # cros_future: Whether the policy is planned to be supported on ChromeOS.
    self.cros_future = False
    if 'future_on' in p:
      if 'chrome_os' in p['future_on']:
       self.cros_future = True

    # additional_info: Documentation to add as a comment to the generated code.
    self.additional_info = self.get_additional_info(p)

    # scope: Whether this policy is a Device or User policy.
    # device_field: If this is a device policy, what is the field name.
    self.scope, self.device_field = self.get_scope_and_field(
        self.name, p, device_field_lookup)

    self.proto_setter = self.get_proto_setter(self.name, p, self.device_field)

    # schema: The JSON schema for this policy's value.
    if 'schema' not in p:
      raise_key_error('schema', p)
    self.schema = p['schema']

    # Set initial values for variables which may be overwritten during code
    # generation.
    # type: Go type used to represent this policy's value.
    self.type = None
    # additional_structs: Any additional code needed for this policy.
    self.additional_structs = None
    # eq: The contents of the Equal() function (can be custom).
    self.eq = None
    # unmarshal: The contents of the UnmarshalAs() function (can be custom).
    self.unmarshal = None
    # code: All code (other than reference value code) that needs to be added.
    self.code = None

  @staticmethod
  def get_proto_setter(name, p, device_field):
    """Return the proto value of the policy given its name."""
    if p.get('device_only', False):
      policy_name, _, field_name = device_field.partition('.')
      return 'SetDeviceProto(m, "%s", "%s", p.Val)' % (policy_name, field_name)
    else:
      return 'SetUserProto(m, p.Name(), p.Val)'

  @staticmethod
  def get_scope_and_field(name, p, lookup):
    """Return scope and field values for this policy.

    Scope should be a Go Scope type string, as defined for the Policy interface.
    """
    if p.get('device_only', False):
      if name in lookup:
        return 'ScopeDevice', lookup[name]
      else:
        raise_key_error(name, 'device fieldnames')
    else:
      return 'ScopeUser', ''

  @staticmethod
  def get_additional_info(p):
    """Generate additional comments for the generated code."""
    additional_info = ''
    if 'default_for_enterprise_users' in p:
      additional_info += (
          '\n// This policy has a default value of {}.'.format(
              p['default_for_enterprise_users'])
      )
    if 'features' in p:
      if p['features'].get('dynamic_refresh', False):
        additional_info += (
            '\n// This policy can be modified without rebooting.')
    if 'url_schema' in p:
      additional_info += (
          '\n// See {} for full schema.'.format(p['url_schema'])
      )
    if 'chrome_os' in p.get('future_on', []):
      additional_info += (
          '\n// This is a future policy, it is not present in stable builds.')
    return additional_info

  def generate_code(self, refs):
    """Generate Go code for this policy. Use overrides if defined.

    Sets the end result as self.code.
    """
    if self.name in PARSE_OVERRIDES:
      self.type, self.additional_structs = PARSE_OVERRIDES[self.name](
          self, refs)
    else:
      value_name = self.name + 'Value'
      self.type, self.additional_structs = parse_schema(
          value_name, self.schema, refs, references_only=False)

    self.eq = EQ_DEFAULT.format(self=self)
    if self.name in EQ_OVERRIDES:
      self.eq = EQ_OVERRIDES[self.name]
    self.unmarshal = UNMARSHAL_DEFAULT.format(self=self)
    if self.name in UNMARSHAL_OVERRIDES:
      self.unmarshal = UNMARSHAL_OVERRIDES[self.name]

    self.code = POLICY_TEMPLATE.format(self=self)

  def find_references(self, refs):
    """For this policy, find and record any references in its schema."""
    if self.name in REF_PARSE_OVERRIDES:
      REF_PARSE_OVERRIDES[self.name](self.schema, refs)
    else:
      parse_schema('refs', self.schema, refs, references_only=True)

def parse_override_extension_settings(p, refs):
  # The top level setting is best stored as a map.
  value_name = p.name + 'Value'
  attr_type, additional_structs = parse_schema(
      value_name, p.schema['properties']['*'], refs)
  return 'map[string]' + attr_type, additional_structs

def parse_override_arc_policy(p, refs):
  value_name = p.name + 'Value'
  attr_type, attr_structs =  parse_schema(
      value_name, p.schema, refs, references_only=False)
  attr_type = '*' + value_name
  attr_structs = """
type Application struct {
\tPackageName\tstring\t`json:"packageName"`
\tInstallType\tstring\t`json:"installType"`
\tDefaultPermissionPolicy\tstring\t`json:"defaultPermissionPolicy"`
\tManagedConfiguration\tmap[string]interface{}\t`json:"managedConfiguration"`
}

type ArcPolicyValue struct {
\tApplications\t[]Application\t`json:"applications"`
\tPlayLocalPolicyEnabled\tbool\t`json:"playLocalPolicyEnabled"`
\tPlayEmmApiInstallDisabled\tbool\t`json:"playEmmApiInstallDisabled"`
}
""" + attr_structs
  return attr_type, attr_structs

def parse_override_device_local_accounts(p, refs):
  value_name = 'DeviceLocalAccountInfo'
  attr_type = '[]' + value_name
  attr_structs = """
type AccountType int

const (
\tAccountTypePublicSession AccountType = iota // 0
\tAccountTypeKioskApp // 1
\tAccountTypeKioskAndroidApp // 2
\tAccountTypeSAMLPublicSession // 3
\tAccountTypeKioskWebApp // 4
)

type AndroidKioskAppInfo struct {
\tPackageName\t*string `json:"package_name,omitempty"`
\tClassName\t*string `json:"class_name,omitempty"`
\tAction\t*string\t`json:"action,omitempty"`
\tDisplayName\t*string\t`json:"display_name,omitempty"`
}

type KioskAppInfo struct {
\tAppId\t*string\t`json:"app_id,omitempty"`
\tUpdateUrl\t*string\t`json:"update_url,omitempty"`
}

type WebKioskAppInfo struct {
\tUrl\t*string\t`json:"url,omitempty"`
\tTitle\t*string\t`json:"title,omitempty"`
\tIconUrl\t*string\t`json:"icon_url,omitempty"`
}
type DeviceLocalAccountInfo struct {
\tAccountID\t*string\t`json:"account_id,omitempty"`
\tAccountType\t*AccountType\t`json:"type,omitempty"`
\tAndroidKioskAppInfo *AndroidKioskAppInfo `json:"android_kiosk_app,omitempty"`
\tKioskAppInfo\t*KioskAppInfo\t`json:"kiosk_app,omitempty"`
\tWebKioskAppInfo\t*WebKioskAppInfo\t`json:"web_kiosk_app,omitempty"`
}
"""
  return attr_type, attr_structs

# Override url_schema in OpenNetworkConfiguration and DeviceOpenNetworkConfiguration.
# See https://chromium.googlesource.com/chromium/src/+/HEAD/components/onc/docs/onc_spec.md for full schema.
def parse_override_onc(p, refs):
  value_name = 'ONC'
  attr_type = '*' + value_name
  attr_structs = ''
  return attr_type, attr_structs

# Override Krb5conf to enable omitting the parameter as omitting it is treated
# differently from passing an empty array.
def parse_override_kerberos_accounts(p, refs):
  value_name = 'KerberosAccountsValueIf'
  attr_type = '[]' + value_name
  attr_structs = """
type KerberosAccountsValueIf interface {
\tSetPassword(string)
}

type KerberosAccountsValue struct {
\tKrb5conf\t[]string\t`json:"krb5conf"`
\tPassword\tstring\t`json:"password"`
\tPrincipal\tstring\t`json:"principal"`
\tRememberPassword\tbool\t`json:"remember_password"`
}

func (v *KerberosAccountsValue) SetPassword(password string) { v.Password = password }

// The KerberosAccounts policy behaves differently when the Krb5conf field is
// omitted compared to just passing an empty array. Therefore we need an
// additional struct in which the field is omitted to cover that case.
type KerberosAccountsValueOmitKrb5conf struct {
\tPassword\tstring\t`json:"password"`
\tPrincipal\tstring\t`json:"principal"`
\tRememberPassword\tbool\t`json:"remember_password"`
}

func (v *KerberosAccountsValueOmitKrb5conf) SetPassword(password string) { v.Password = password }
"""
  return attr_type, attr_structs

def parse_override_web_app_install_force_list(p, refs):
  value_name = 'WebAppInstallForceListValue'
  attr_type = '[]*' + value_name
  attr_structs = """
type WebAppInstallForceListValue struct {
\tCreateDesktopShortcut\tbool\t`json:"create_desktop_shortcut,omitempty"`
\tCustomIcon\t*WebAppInstallForceListValueCustomIcon\t`json:"custom_icon,omitempty"`
\tCustomName\tstring\t`json:"custom_name,omitempty"`
\tDefaultLaunchContainer\tstring                                 `json:"default_launch_container,omitempty"`
\tFallbackAppName\tstring                                 `json:"fallback_app_name,omitempty"`
\tUrl\tstring\t`json:"url"`
}

type WebAppInstallForceListValueCustomIcon struct {
\tHash\tstring\t`json:"hash"`
\tUrl\tstring\t`json:"url"`
}

"""
  return attr_type, attr_structs

def ref_parse_override_managed_bookmarks(schema, refs):
  name = 'Ref' + schema['items']['id']
  refs[schema['items']['id']] = Reference(name, '*'+name, '')
  ref_type = '*' + 'Ref' +schema['items']['id']
  ref_code = """
type RefBookmarkType struct {
\tChildren\t[]*RefBookmarkType\t`json:"children,omitempty"`
\tName\tstring\t`json:"name"`
\tToplevelName string\t`json:"toplevel_name"`
\tUrl\tstring\t`json:"url"`
}
"""
  refs[schema['items']['id']].update(ref_type, ref_code)

# Functions to use instead of parse_schema() if the default way won't work.
PARSE_OVERRIDES = {
    'ExtensionSettings': parse_override_extension_settings,
    'ArcPolicy': parse_override_arc_policy,
    'DeviceLocalAccounts': parse_override_device_local_accounts,
    'OpenNetworkConfiguration': parse_override_onc,
    'DeviceOpenNetworkConfiguration': parse_override_onc,
    'KerberosAccounts': parse_override_kerberos_accounts,
    'WebAppInstallForceList': parse_override_web_app_install_force_list,
}

# Functions to use for reference objects when the default way won't work.
REF_PARSE_OVERRIDES = {
    'ManagedBookmarks': ref_parse_override_managed_bookmarks
}

# Go code to replace the contents of Equal() for the named policy.
# TODO(kathrelkeld): handle OpenNetworkConfiguration case.
EQ_OVERRIDES = {
    'DeviceUserWhitelist': """\tv, ok := iface.([]string)
\tif !ok {
\t\treturn ok
\t}
\tsensitive := p.Val
\tfor i := range sensitive { sensitive[i] = "********" }
\treturn cmp.Equal(sensitive, v)""",
    'PluginVmLicenseKey': """\tv, ok := iface.(string)
\tif !ok {
\t\treturn ok
\t}
\tsensitive := "********"
\treturn cmp.Equal(sensitive, v)""",
    'ParentAccessCodeConfig': """\tv, ok := iface.(string)
\tif !ok {
\t\treturn ok
\t}
\tsensitive := "********"
\treturn cmp.Equal(sensitive, v)""",
    'KerberosAccounts': """\tv, ok := iface.([]KerberosAccountsValueIf)
\tif !ok {
\t\treturn ok
\t}
\tvar sensitive []KerberosAccountsValueIf
\tfor i := range p.Val {
\t\tcpy := p.Val[i]
\t\tcpy.SetPassword("********")
\t\tsensitive = append(sensitive, cpy)
\t}
\treturn cmp.Equal(sensitive, v)"""
}

# Go code to replace the contents of UnmarshalAs() for the named policy.
UNMARSHAL_OVERRIDES = {
    'ParentAccessCodeConfig': """\tvar v string
\tif err := json.Unmarshal(m, &v); err != nil {
\t\treturn nil, errors.Wrapf(err, "could not read %s as sensitive string", m)
\t}
\treturn v, nil""",
    'ArcPolicy': """\tvar v string
\tif err := json.Unmarshal(m, &v); err != nil {
\t\treturn nil, errors.Wrapf(err, "could not read %s as string", m)
\t}
\tvar value ArcPolicyValue
\tif err := json.Unmarshal([]byte(v), &value); err != nil {
\t\treturn nil, errors.Wrapf(err, "could not read %s as ArcPolicyValue", m)
\t}
\treturn value, nil""",
    'KerberosAccounts': """\t//First unmarshal into []*KerberosAccountsValue as KerberosAccountsValue has all fields.
\tvar v []*KerberosAccountsValue
\tif err := json.Unmarshal(m, &v); err != nil {
\t\treturn nil, errors.Wrapf(err, "could not read %s as []*KerberosAccountsValue", m)
\t}
\t// Next store the elements in a KerberosAccountsValueIf slice and convert all elements without Krb5conf to *KerberosAccountsValueOmitKrb5conf
\t// as otherwise the Equal function will fail.
\tvar value []KerberosAccountsValueIf
\tfor i := range v {
\t\tif v[i].Krb5conf == nil {
\t\t\ttmp := KerberosAccountsValueOmitKrb5conf{Password: v[i].Password, Principal: v[i].Principal, RememberPassword: v[i].RememberPassword}
\t\t\tvalue = append(value, &tmp)
\t\t} else {
\t\t\tvalue = append(value, v[i])
\t\t}
\t}
\treturn value, nil"""
}

def write_code(output_path, policies_by_id, schema_ids):
  """Write Go code to the given file."""
  with open(output_path, 'w') as fh:
    # Write ChromeOS policy structs.
    fh.write(HEADER)
    for i in sorted(policies_by_id.keys()):
      fh.write(policies_by_id[i].code)

    # Append code for any reference values being used by ChromeOS policies.
    fh.write(REFERENCE_HEADER)
    for name in schema_ids:
      ref = schema_ids[name]
      if ref.in_use:
        fh.write(ref.code)

    # Append code for Open Network Configuration.
    fh.write(ONC_SCHEMA)

def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('--policy_templates', dest='policy_path',
                      help='Location of policy_templates.json file to parse.')
  parser.add_argument('--name', dest='name', default=None, type=str,
                      help='Optional name of a single policy to print out.')
  parser.add_argument('--out', dest='out', default=OUTPUT_FILEPATH, type=str,
                      help=('Optional filepath for the output. By default, '
                            'use the path where the output is checked in.'))
  args = parser.parse_args()

  if not args.policy_path:
    print('Please point to policy_templates.json')
    return

  with open(args.policy_path) as f:
    pt_contents = ast.literal_eval(f.read())

  device_field_lookup = pt_contents['device_policy_proto_map']
  # Save legacy field values. Note: this implementation won't work with any
  # "one-to-many" legacy device policy field names. Only the last is used.
  # one_to_many_policies is used to ignore unsupported policies.
  one_to_many_policies = set()
  one_to_many_count = set()
  no_proto_policies = set()
  for [legacy, val] in pt_contents['legacy_device_policy_proto_map']:
    if not legacy:
      # Discard unknown legacy policies which are noted as '' in this list.
      continue
    if not val:
      # Remember legacy policies with no proto field (we don't generate code for
      # them).
      no_proto_policies.add(legacy)
      continue
    if legacy in one_to_many_count:
      one_to_many_policies.add(legacy)
      continue

    one_to_many_count.add(legacy)
    device_field_lookup[legacy] = val
  schema_ids = {}

  # Create class representation for all policies.
  policies = []
  errors = []
  for pt in pt_contents['policy_definitions']:
    if pt.get('type') == 'group':
      continue
    if pt['name'] in no_proto_policies:
      # Silently ignoring legacy policies with no known proto.
      continue
    try:
      one_to_many = pt['name'] in one_to_many_policies
      policies.append(Policy(pt, device_field_lookup, one_to_many))
    except KeyError as e:
      errors.append('{}: {}'.format(pt['name'], e))

  # Do a pass over all schema to find reference values.
  for p in policies:
    try:
      p.find_references(schema_ids)
    except KeyError as e:
      errors.append('{}: {}'.format(p.name, e))

  # Generate code for all valid ChromeOS policies, recording any errors.
  supported_policies_by_id = {}
  for p in policies:
    if not (p.cros_supported or p.cros_future):
      continue
    if p.one_to_many:
      continue
    try:
      p.generate_code(schema_ids)
      supported_policies_by_id[p.id] = p
    except SchemaIdError as e:
      errors.append('{}: {}'.format(p.name, e))
    except KeyError as e:
      errors.append('{}: {}'.format(p.name, e))

  # Print out any errors.
  for err in errors:
    print(err)

  # Print out a single policy or write all valid policies to file.
  if args.name:
    for i in supported_policies_by_id:
      if args.name == supported_policies_by_id[i].name:
        print(supported_policies_by_id[i].code)
        break
    else:
      print('Not a known supported policy: {}'.format(args.name))
  else:
    write_code(args.out, supported_policies_by_id, schema_ids)
    # Format output
    subprocess.run(["gofmt", "-w", args.out]).check_returncode()

if __name__ == '__main__':
  main()
