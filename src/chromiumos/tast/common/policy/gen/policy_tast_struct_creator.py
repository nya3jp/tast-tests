#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2019 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""Tool for creating go code from policy_templates.json.

Used to create defs.go for policy Tast tests.
Notes for adding a new policy:
    - policies with sensitive values will need to add a non-default Equal()
      function here and maybe a non-default UnmarshalAs().
    - policies with hard-to-parse values (e.g. those described by url or
      partial description only) will have to overwrite the schema parsing here.
    - device policies which have unique field setups may need to be handled
      here.
"""

import argparse
import ast
import os

# Default output filename and path.
OUTPUT_FILENAME = 'defs.go'
OUTPUT_FILEPATH = os.path.join(os.path.dirname(__file__), "..", OUTPUT_FILENAME)

# Header for the GO code.
HEADER = """// Copyright 2019 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Code generated by policy_tast_struct_creator.py. DO NOT EDIT.
// Edit the generator in policy/gen/ instead.

package policy

import (
\t"encoding/json"

\t"github.com/google/go-cmp/cmp"

\t"chromiumos/tast/errors"
)
"""

# Note: A double "{{" is to produce a single "{" in the formatted Go code.

# Template for a single policy. Is formatted using a Policy object.
POLICY_TEMPLATE = """
///////////////////////////////////////////////////////////////////////////////
// {self.id}. {self.name}{self.additional_info}
///////////////////////////////////////////////////////////////////////////////
type {self.name} struct {{
\tStat Status
\tVal {self.type}
}}
{self.additional_structs}
func (p *{self.name}) Name() string      {{ return "{self.name}" }}
func (p *{self.name}) Field() string     {{ return "{self.device_field}" }}
func (p *{self.name}) Scope() Scope      {{ return {self.scope} }}
func (p *{self.name}) Status() Status    {{ return p.Stat }}
func (p *{self.name}) UntypedV() interface{{}} {{ return p.Val }}
func (p *{self.name}) UnmarshalAs(m json.RawMessage) (interface{{}}, error) {{
{self.unmarshal}
}}
func (p *{self.name}) Equal(iface interface{{}}) bool {{
{self.eq}
}}
"""

# Header for the section containing definitions of Reference values.
REFERENCE_HEADER = """
///////////////////////////////////////////////////////////////////////////////
// Reference values (used via '$ref' in JSON Schema).
///////////////////////////////////////////////////////////////////////////////
"""

# Default values for the contents of function code in POLICY_TEMPLATE.
# Can be overwritten for policies with different behavior.
UNMARSHAL_DEFAULT = """\tvar v {self.type}
\tif err := json.Unmarshal(m, &v); err != nil {{
\t\treturn nil, errors.Wrapf(err, "could not read %s as {self.type}", m)
\t}}
\treturn v, nil"""
EQ_DEFAULT = """\tv, ok := iface.({self.type})
\tif !ok {{
\t\treturn ok
\t}}
\treturn cmp.Equal(p.Val, v)"""

# Templates to create additional structs discovered during schema parsing.
VALUE_TEMPLATE = """
type {name} struct {{{members}
}}
"""
PROPERTY_TEMPLATE = """\n\t{go_name} {go_type} `json:"{json_name}"`"""
STRING_PROPERTY_TEMPLATE = (
    """\n\t{go_name} {go_type} `json:"{json_name},string"`""")
EMBEDDED_TEMPLATE = """\n\t{go_type}"""


def new_struct(name, members):
  """Return Go code for a new struct with the given name and members.

  To be used when adding a new struct inside a policy value.
  """
  return VALUE_TEMPLATE.format(name=name, members=members)

def new_property(name, go_type):
  """Return Go code for a new named property of a struct of the given type.

  See members input in new_struct().
  """
  return PROPERTY_TEMPLATE.format(
      go_type=go_type, json_name=name, go_name=go_var_format(name))

def new_embedded(go_type):
  """Return Go code for an embedded (unnamed) new property of a struct.

  See members input in new_struct().
  """
  return EMBEDDED_TEMPLATE.format(go_type=go_type)

# Converstion of JSONSchema types to Go types.
TYPES_JSON_TO_GO = {
    'string': 'string',
    'integer': 'int',
    'boolean': 'bool'
}

def go_var_format(s):
  """Format given string for use as a Go variable name.

  Exported struct methods must start with an uppercase letter and '-' is not
  a valid character.  Also change snake_case into CamelCase.
  """
  for rm in ['_', '-']:
    if rm in s:
      s = ''.join([upper_first(elt) for elt in s.split(rm)])
  return upper_first(s)

def upper_first(s):
  """Return the given string with the first element capitalized."""
  if s == '':
    return s
  return s[0].upper() + s[1:]

def raise_key_error(key, schema):
  """Raise an error that a given key/keys was/were not found in the schema."""
  raise KeyError('Could not find {} in {}'.format(key, schema))

def raise_type_error(t, schema):
  """Raise an error that the schema contained an unrecognized type."""
  raise KeyError('Unknown type {} in {}.'.format(t, schema))

class SchemaIdError(Exception):
  """Exception class for when policies refer to an unknown JSON schema id."""
  def __init__(self, name):
    Exception.__init__(self, 'Unknown JSON schema reference ' + name)

def parse_schema(name, schema, refs, references_only=False):
  """Return a Go type for the given JSONSchema plus any supporting code.

  Args:
    name: string of name to be used when naming structs
    schema: dict of the JSON schema to be parsed
    refs: dict of all references found by name (id -> Reference Class). Will
        be used to resolve any '$ref' types found.
    references_only: whether this pass is to resolve references.
        True when adding to the refs dict.
        False when generating full code with a populated refs dict.

  Returns:
    Go type and additional Go code (if any)

  Raises:
    KeyError if the schema has an unrecognized format
  """
  # The type which should be used for this value in Go (e.g. 'int', *Struct).
  go_type = ''
  # Any additional code (structs definitions, etc.) needed for this schema.
  code = ''

  if 'id' in schema:
    # This is a named schema that could be used elsewhere.
    # If we're resolving references, continue to parse. Otherwise return
    # the already found value and mark it as used.
    if not references_only:
      if schema['id'] not in refs:
        raise SchemaIdError(schema['id'])
      refs[schema['id']].in_use = True
      return refs[schema['id']].type, ''
    else:
      # Temporarily save the reference as a struct pointer, to handle the case
      # where a struct is referenced within itself.
      name = 'Ref' + schema['id']
      refs[schema['id']] = Reference(name, '*'+name, '')

  # Create a go_type and code for this schema, either from a described type or
  # from a reference to another type.
  if 'type' in schema:
    if schema['type'] == 'object':
      go_type, code = parse_object(name, schema, refs, references_only)
    elif schema['type'] == 'array':
      go_type, code = parse_array(name, schema, refs, references_only)
    elif schema['type'] in TYPES_JSON_TO_GO:
      go_type = TYPES_JSON_TO_GO[schema['type']]
    else:
      raise_type_error(schema['type'], schema)
  elif '$ref' in schema:
    # If this is a known reference, use it. If it is unknown, either skip or
    # raise an error depending on whether this is a references pass.
    if schema['$ref'] in refs:
      go_type = refs[schema['$ref']].type
      if not references_only:
        refs[schema['$ref']].in_use = True
    elif not references_only:
      raise SchemaIdError(schema['$ref'])
  else:
    raise_key_error('type or $ref', schema)

  # If a reference value, update the type in case it is not actually a struct
  # pointer. Return without any code, since additional code for refs is added
  # separately.
  if 'id' in schema and references_only:
    refs[schema['id']].update(go_type, code)
    return go_type, ''

  return go_type, code

def parse_array(name, schema, refs, references_only):
  """Parse an array's schema by returning a slice to the type value.

  Used during parse_schema.  The 'items' element will describe the type of
  the items in the array.  Return a slice to whatever that type is.

  Returns the Go type of this array and any supporting code needed.
  """
  if 'items' not in schema:
    raise_key_error('items', schema)
  item_type, code = parse_schema(name, schema['items'], refs, references_only)
  return '[]'+item_type, code

def parse_object(name, schema, refs, references_only):
  """Parse an object's schema by returning a new struct.

  Used during parse_schema.  The 'properties' or 'additionalProperties' element
  will describe the type of the items in the object (it is a map of
  string -> property).

  Returns the Go type of this object and any supporting code needed.
  """
  # First handle the case where there are no named properties. If only
  # additionalProperties is defined, this object is best represented as a
  # map of string -> additionalProperty, not a struct.
  # If neither field is there, raise an error.
  if 'properties' not in schema:
    if not 'additionalProperties' in schema:
      raise_key_error('properties or additionalProperties', schema)
    add_type, code = parse_schema(name, schema['additionalProperties'], refs,
                                  references_only)
    return 'map[string]' + add_type, code

  # Represent an object with named properties as a struct. Recursively find
  # the Go type for each member of this struct, keeping track of any
  # additional code needed (including this struct definition).
  # The Go type returned here will be a pointer to the struct type.
  go_type = '*' + name
  code = ''
  members = []
  props = schema['properties']
  for key in props:
    # Name each key as a subset of the parent name to avoid name duplication
    # if its a struct.
    key_name = name + go_var_format(key)
    key_type, key_code = parse_schema(key_name, props[key], refs,
                                      references_only)
    members.append(new_property(key, key_type))
    code += key_code

  # If there are still addtionalProperties, add an embedded struct member.
  if 'additionalProperties' in schema:
    add_type, add_code = parse_schema(
        name+'Add', schema['additionalProperties'], refs, references_only)
    members.append(new_embedded(add_type))
    code += add_code

  # paternProperties can contain reference values. If we're evaluating
  # references, continue parsing this.
  if 'patternProperties' in schema and references_only:
    pattern_props = schema['patternProperties']
    for key in pattern_props:
      parse_schema('refs', pattern_props[key], refs, references_only)

  # Create new struct given all the previously found members and their code.
  code = new_struct(name, ''.join(sorted(members))) + code

  return go_type, code

class Reference(object):
  """Class representing a reference type (labeled schema values)."""
  def __init__(self, name, ref_type, code):
    # name: Name used in the JSON schema to refer to this type.
    self.name = name
    # type: Go type used for this value.
    self.type = ref_type
    # code: Any additional code needed to use this value in Go.
    self.code = code
    # in_use: Whether this reference was used in the examined schema.
    self.in_use = ref_type is not None

  def update(self, ref_type, code):
    self.type = ref_type
    self.code = code

class Policy(object):
  """Class representing a single policy, used with POLICY_TEMPLATE."""
  def __init__(self, p, device_field_lookup):
    # name: Name of this policy as defined in policy_templates.
    self.name = p['name']
    # id: Id number of this policy as defined in policy_templates.
    self.id = p['id']
    # cros_supported: Whether the policy is currently supported on Chrome OS.
    self.cros_supported = False
    for elt in p['supported_on']:
      # Search for 'chrome_os:##-', insead of 'chrome_os:##-##', which
      # indicates an end date. This may cause problems for generating this file
      # for non-ToT branches.
      if elt.startswith('chrome_os') and elt.endswith('-'):
        self.cros_supported = True

    # additional_info: Documentation to add as a comment to the generated code.
    self.additional_info = self.get_additional_info(p)

    # scope: Whether this policy is a Device or User policy.
    # device_field: If this is a device policy, what is the field name.
    self.scope, self.device_field = self.get_scope_and_field(
        self.name, p, device_field_lookup)

    # schema: The JSON schema for this policy's value.
    if 'schema' not in p:
      raise_key_error('schema', p)
    self.schema = p['schema']

    # Set initial values for variables which may be overwritten during code
    # generation.
    # type: Go type used to represent this policy's value.
    self.type = None
    # additional_structs: Any additional code needed for this policy.
    self.additional_structs = None
    # eq: The contents of the Equal() function (can be custom).
    self.eq = None
    # unmarshal: The contents of the UnmarshalAs() function (can be custom).
    self.unmarshal = None
    # code: All code (other than reference value code) that needs to be added.
    self.code = None

  @staticmethod
  def get_scope_and_field(name, p, lookup):
    """Return scope and field values for this policy.

    Scope should be a Go Scope type string, as defined for the Policy interface.
    """
    if p.get('device_only', False):
      if name in lookup:
        return 'ScopeDevice', lookup[name]
      else:
        raise_key_error(name, 'device fieldnames')
    else:
      return 'ScopeUser', ''

  @staticmethod
  def get_additional_info(p):
    """Generate additional comments for the generated code."""
    additional_info = ''
    if 'default_for_enterprise_users' in p:
      additional_info += (
          '\n// This policy has a default value of {}.'.format(
              p['default_for_enterprise_users'])
      )
    if 'features' in p:
      if p['features'].get('dynamic_refresh', False):
        additional_info += (
            '\n// This policy can be modified without rebooting.')
    if 'url_schema' in p:
      additional_info += (
          '\n// See {} for full schema.'.format(p['url_schema'])
      )
    return additional_info

  def generate_code(self, refs):
    """Generate Go code for this policy. Use overrides if defined.

    Sets the end result as self.code.
    """
    if self.name in PARSE_OVERRIDES:
      self.type, self.additional_structs = PARSE_OVERRIDES[self.name](
          self, refs)
    else:
      value_name = self.name + 'Value'
      self.type, self.additional_structs = parse_schema(
          value_name, self.schema, refs, references_only=False)

    self.eq = EQ_DEFAULT.format(self=self)
    if self.name in EQ_OVERRIDES:
      self.eq = EQ_OVERRIDES[self.name]
    self.unmarshal = UNMARSHAL_DEFAULT.format(self=self)
    if self.name in UNMARSHAL_OVERRIDES:
      self.unmarshal = UNMARSHAL_OVERRIDES[self.name]

    self.code = POLICY_TEMPLATE.format(self=self)

  def find_references(self, refs):
    """For this policy, find and record any references in its schema."""
    parse_schema('refs', self.schema, refs, references_only=True)

def parse_override_extension_settings(p, refs):
  # The top level setting is best stored as a map.
  value_name = p.name + 'Value'
  attr_type, additional_structs = parse_schema(
      value_name, p.schema['properties']['*'], refs)
  return 'map[string]' + attr_type, additional_structs

# Functions to use instead of parse_schema() if the default way won't work.
PARSE_OVERRIDES = {
    'ExtensionSettings': parse_override_extension_settings
}

# Go code to replace the contents of Equal() for the named policy.
# TODO(kathrelkeld): handle OpenNetworkConfiguration case.
EQ_OVERRIDES = {
    'DeviceUserWhitelist': """\tv, ok := iface.([]string)
\tif !ok {
\t\treturn ok
\t}
\tsensitive := p.Val
\tfor i := range sensitive { sensitive[i] = "********" }
\treturn cmp.Equal(sensitive, v)""",
    'PluginVmLicenseKey': """\tv, ok := iface.(string)
\tif !ok {
\t\treturn ok
\t}
\tsensitive := "********"
\treturn cmp.Equal(sensitive, v)""",
    'ParentAccessCodeConfig': """\tv, ok := iface.(string)
\tif !ok {
\t\treturn ok
\t}
\tsensitive := "********"
\treturn cmp.Equal(sensitive, v)""",
    'KerberosAccounts': """\tv, ok := iface.([]*KerberosAccountsValue)
\tif !ok {
\t\treturn ok
\t}
\tvar sensitive []*KerberosAccountsValue
\tfor i := range p.Val {
\t\tcpy := p.Val[i]
\t\tcpy.Password = "********"
\t\tsensitive = append(sensitive, cpy)
\t}
\treturn cmp.Equal(sensitive, v)"""
}

# Go code to replace the contents of UnmarshalAs() for the named policy.
UNMARSHAL_OVERRIDES = {
    'ParentAccessCodeConfig': """\tvar v string
\tif err := json.Unmarshal(m, &v); err != nil {
\t\treturn nil, errors.Wrapf(err, "could not read %s as sensitive string", m)
\t}
\treturn v, nil"""
}

def write_code(output_path, policies_by_id, schema_ids):
  """Write Go code to the given file."""
  with open(output_path, 'w') as fh:
    # Write Chrome OS policy structs.
    fh.write(HEADER)
    for i in sorted(policies_by_id.keys()):
      fh.write(policies_by_id[i].code)

    # Append code for any reference values being used by Chrome OS policies.
    fh.write(REFERENCE_HEADER)
    for name in schema_ids:
      ref = schema_ids[name]
      if ref.in_use:
        fh.write(ref.code)

def main():
  parser = argparse.ArgumentParser()
  parser.add_argument('--policy_templates', dest='policy_path',
                      help='Location of policy_templates.json file to parse.')
  parser.add_argument('--name', dest='name', default=None, type=str,
                      help='Optional name of a single policy to print out.')
  parser.add_argument('--out', dest='out', default=OUTPUT_FILEPATH, type=str,
                      help=('Optional filepath for the output. By default, '
                            'use the path where the output is checked in.'))
  args = parser.parse_args()

  if not args.policy_path:
    print('Please point to policy_templates.json')
    return

  with open(args.policy_path) as f:
    pt_contents = ast.literal_eval(f.read())

  device_field_lookup = pt_contents['device_policy_proto_map']
  # Save legacy field values. Note: this implementation won't work with any
  # "one-to-many" legacy device policy field names. Only the last is used.
  for [legacy, val] in pt_contents['legacy_device_policy_proto_map']:
    if not legacy:
      # Discard unknown/invalid fields which are noted as '' in this list.
      continue
    device_field_lookup[legacy] = val
  schema_ids = {}

  # Create class representation for all policies.
  policies = []
  errors = []
  for pt in pt_contents['policy_definitions']:
    if pt.get('type') == 'group':
      continue
    try:
      policies.append(Policy(pt, device_field_lookup))
    except KeyError as e:
      errors.append('{}: {}'.format(pt['name'], e))

  # Do a pass over all schema to find reference values.
  for p in policies:
    try:
      p.find_references(schema_ids)
    except KeyError as e:
      errors.append('{}: {}'.format(p.name, e))

  # Generate code for all valid Chrome OS policies, recording any errors.
  supported_policies_by_id = {}
  for p in policies:
    if not p.cros_supported:
      continue
    try:
      p.generate_code(schema_ids)
      supported_policies_by_id[p.id] = p
    except SchemaIdError as e:
      errors.append('{}: {}'.format(p.name, e))
    except KeyError as e:
      errors.append('{}: {}'.format(p.name, e))

  # Print out any errors.
  for err in errors:
    print(err)

  # Print out a single policy or write all valid policies to file.
  if args.name:
    for i in supported_policies_by_id:
      if args.name == supported_policies_by_id[i].name:
        print(supported_policies_by_id[i].code)
        break
    else:
      print('Not a known supported policy: {}'.format(args.name))
  else:
    write_code(args.out, supported_policies_by_id, schema_ids)

if __name__ == '__main__':
  main()
