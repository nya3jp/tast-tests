// Copyright 2022 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package wifi

import (
	"bytes"
	"context"
	"fmt"
	"regexp"
	// "strings"
	"time"

	// "chromiumos/tast/common/crypto/certificate"
	// "chromiumos/tast/common/network/ping"
	"chromiumos/tast/common/perf"
	"chromiumos/tast/common/wifi/security"
	// "chromiumos/tast/common/wifi/security/dynamicwep"
	// "chromiumos/tast/common/wifi/security/tunneled1x"
	// "chromiumos/tast/common/wifi/security/wep"
	"chromiumos/tast/common/wifi/security/wpa"
	// "chromiumos/tast/common/wifi/security/wpaeap"
	"chromiumos/tast/errors"
	"chromiumos/tast/remote/network/ip"
	"chromiumos/tast/remote/wificell"
	ap "chromiumos/tast/remote/wificell/hostapd"
	"chromiumos/tast/remote/wificell/router/common/support"
	// "chromiumos/tast/remote/wificell/wifiutil"
	"chromiumos/tast/services/cros/wifi"
	"chromiumos/tast/testing"
	// "chromiumos/tast/testing/hwdep"
)

type tdlsTestcase struct {
	apOpts []ap.Option
	// If unassigned, use default security config: open network.
	secConfFac security.ConfigFactory
}

// EAP certs/keys for EAP tests.
// var (
// 	eapCert1             = certificate.TestCert1()
// )

const (
	managedIfName        = "managed0"
	supplicantConfigPath = "/tmp/supplicant.cfg"
	tearDown             = true
)

func init() {
	testing.AddTest(&testing.Test{
		Func: Tdls,
		Desc: "TBD",
		Contacts: []string{
			"jck@semihalf.com",
			"chromeos-wifi-champs@google.com", // WiFi oncall rotation; or http://b/new?component=893827
		},
		Attr:        []string{"group:wificell", "wificell_func", "wificell_unstable"},
		ServiceDeps: []string{wificell.TFServiceName},
		Fixture:     "wificellFixtWithCapture",
		Params: []testing.Param{
			// Parameters generated by simple_connect_test.go. DO NOT EDIT.
			{
				// Verifies that DUT can connect to an open 802.11a network on channels 48, 64.
				// Name: "basic",
				Val: []tdlsTestcase{{
					apOpts: []ap.Option{ap.Mode(ap.Mode80211a), ap.Channel(48)},
					secConfFac: wpa.NewConfigFactory(
						"chromeos", wpa.Mode(wpa.ModePureWPA),
						wpa.Ciphers(wpa.CipherCCMP),
					)}, //{
				// apOpts: []ap.Option{ap.Mode(ap.Mode80211a), ap.Channel(64)},
				//}
				},
			},
		}})
}

func Tdls(ctx context.Context, s *testing.State) {
	tf := s.FixtValue().(*wificell.TestFixture)

	pv := perf.NewValues()
	defer func() {
		if err := pv.Save(s.OutDir()); err != nil {
			s.Log("Failed to save perf data, err: ", err)
		}
	}()

	testOnce := func(ctx context.Context, s *testing.State, options []ap.Option, fac security.ConfigFactory) {
		apIface, err := tf.ConfigureAP(ctx, options, fac)
		if err != nil {
			s.Fatal("Failed to configure ap, err: ", err)
		}

		// Validate required router functionality.
		type supportedRouter interface {
			support.Logs
			support.Hostapd
			support.DHCP
			support.Capture
		}
		if _, ok := apIface.Router().(supportedRouter); !ok {
			s.Fatalf("Router type %q does not have sufficient support for this test: ", apIface.Router().RouterTypeName())
		}

		defer func(ctx context.Context) {
			if err := tf.DeconfigAP(ctx, apIface); err != nil {
				s.Error("Failed to deconfig ap, err: ", err)
			}
		}(ctx)
		ctx, cancel := tf.ReserveForDeconfigAP(ctx, apIface)
		defer cancel()
		s.Log("AP setup done")

		// Some tests may fail as expected at following ConnectWifiAP(). In that case entries should still be deleted properly.
		defer func(ctx context.Context) {
			req := &wifi.DeleteEntriesForSSIDRequest{Ssid: []byte(apIface.Config().SSID)}
			if _, err := tf.WifiClient().DeleteEntriesForSSID(ctx, req); err != nil {
				s.Errorf("Failed to remove entries for ssid=%s, err: %v", apIface.Config().SSID, err)
			}
		}(ctx)

		_, err = tf.ConnectWifiAP(ctx, apIface)
		if err != nil {
			s.Fatal("Failed to connect to WiFi, err: ", err)
		}
		defer func(ctx context.Context) {
			if err := tf.CleanDisconnectWifi(ctx); err != nil {
				s.Error("Failed to disconnect WiFi, err: ", err)
			}
		}(ctx)
		ctx, cancel = tf.ReserveForDisconnect(ctx)
		defer cancel()
		s.Log("Connected DUT")

		// We want control over capturer start/stop so we don't use fixture with
		// pcap but spawn it here and use manually.
		peerDevice, ok := tf.Pcap().(support.SSHConn)
		if !ok {
			s.Fatal("Device without ssh support - device type: ", tf.Pcap().RouterType())
		}
		peerConn := peerDevice.Conn()

		runnerCtx, cancel := context.WithTimeout(ctx, 20*time.Second)
		defer cancel()
		ret, err := peerConn.CommandContext(runnerCtx, "iw", "phy", "phy0", "interface", "add",
			managedIfName, "type", "managed").Output()
		if err != nil {
			// Maight laready exist.
			s.Error("Failed to create managed0 device, err: ", err)
		}
		testing.ContextLogf(ctx, "Add: Ret: %v", ret)
		defer func(ctx context.Context) {
			if tearDown {
				ret, _ := peerConn.CommandContext(ctx, "iw", "dev", managedIfName, "del").Output()
				testing.ContextLogf(ctx, "Del: Ret: %s", ret)
			}
		}(ctx)

		cfg, err := apIface.Config().SecurityConfig.HostapdConfig()
		ret, err = peerConn.CommandContext(runnerCtx, "wpa_passphrase", apIface.Config().SSID,
			cfg["wpa_passphrase"]).Output()
		if err != nil {
			s.Fatal("Failed to call wpa_passphrase, err: ", err)
		}
		testing.ContextLogf(ctx, "Passphr: Ret: %s", ret)

		cmd := peerConn.CommandContext(ctx, "tee", supplicantConfigPath)
		cmd.Stdin = bytes.NewBuffer([]byte("ctrl_interface=DIR=/var/run/wpa_supplicant\n"))
		if err := cmd.Run(); err != nil {
			s.Fatal("Failed to execute the command: ", err)
			return
		}

		cmd = peerConn.CommandContext(ctx, "tee", "-a", supplicantConfigPath)
		cmd.Stdin = bytes.NewBuffer(ret)
		if err := cmd.Run(); err != nil {
			s.Error("Failed to execute the command: ", err)
			return
		}
		defer func(ctx context.Context) {
			if tearDown {
				ret, _ := peerConn.CommandContext(ctx, "wpa_cli", "terminate").Output()
				testing.ContextLogf(ctx, "Rm: Ret: %s", ret)
				ret, _ = peerConn.CommandContext(ctx, "rm", supplicantConfigPath).Output()
				testing.ContextLogf(ctx, "Rm: Ret: %s", ret)
			}
		}(ctx)

		ret, err = peerConn.CommandContext(runnerCtx, "wpa_supplicant", "-B", "-i", managedIfName,
			"-c", supplicantConfigPath).Output()
		if err != nil {
			s.Fatal("Failed to call wpa_supplicant, err: ", err)
		}
		var re = regexp.MustCompile("OK")

		runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		defer cancel()
		if err = testing.Poll(ctx, func(ctx context.Context) error {
			ret, err = peerConn.CommandContext(runnerCtx, "wpa_cli", "scan").Output()
			if err != nil {
				testing.PollBreak(errors.Wrap(err, "Failed to call wpa_cli, err: "))
			}
			if !re.MatchString(string(ret)) {
				testing.ContextLogf(ctx, "Ret: [%s]. Waiting for Scan...", string(ret))
				testing.Sleep(ctx, 5*time.Second)
				return errors.Errorf("Scan result: %s", ret)
			}
			return nil
		}, &testing.PollOptions{Timeout: 120 * time.Second}); err != nil {
			s.Fatal("Failed to scan: ", err)
		}
		testing.Sleep(ctx, 20*time.Second)
		runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		defer cancel()
		ret, err = peerConn.CommandContext(runnerCtx, "wpa_cli", "scan_results").Output()
		if err != nil {
			s.Fatal("Failed to call wpa_cli, err: ", err)
		}
		testing.ContextLogf(ctx, "Scan results: Ret: %s", ret)

		// Get the MAC address of WiFi interface.
		iface, err := tf.ClientInterface(ctx)
		if err != nil {
			s.Fatal("Failed to get WiFi interface of DUT: ", err)
		}
		ipr := ip.NewRemoteRunner(s.DUT().Conn())
		hwMAC, err := ipr.MAC(ctx, iface)
		if err != nil {
			s.Fatal("Failed to get MAC of WiFi interface: ", err)
		}

		runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		defer cancel()
		ret, err = peerConn.CommandContext(runnerCtx, "wpa_cli", "tdls_discover",
			hwMAC.String()).Output()
		if err != nil {
			s.Fatal("Failed to call wpa_cli, err: ", err)
		}
		testing.ContextLogf(ctx, "TDLS Discover results: Ret: %s", ret)

		// desc := apIface.Config().PerfDesc()

		// pv.Set(perf.Metric{
		// 	Name:      desc,
		// 	Variant:   "Discovery",
		// 	Unit:      "seconds",
		// 	Direction: perf.SmallerIsBetter,
		// }, float64(resp.DiscoveryTime)/1e9)
		// pv.Set(perf.Metric{
		// 	Name:      desc,
		// 	Variant:   "Association",
		// 	Unit:      "seconds",
		// 	Direction: perf.SmallerIsBetter,
		// }, float64(resp.AssociationTime)/1e9)
		// pv.Set(perf.Metric{
		// 	Name:      desc,
		// 	Variant:   "Configuration",
		// 	Unit:      "seconds",
		// 	Direction: perf.SmallerIsBetter,
		// }, float64(resp.ConfigurationTime)/1e9)
		// ping := func(ctx context.Context) error {
		// 	return tf.PingFromDUT(ctx, apIface.ServerIP().String(), pingOps...)
		// }

		// if err := tf.AssertNoDisconnect(ctx, ping); err != nil {
		// 	s.Fatal("Failed to ping from DUT, err: ", err)
		// }

		// s.Log("Checking the status of the SSID in the DUT")
		// serInfo, err := tf.WifiClient().QueryService(ctx)
		// if err != nil {
		// 	s.Fatal("Failed to get the WiFi service information from DUT, err: ", err)
		// }

		// if serInfo.Wifi.HiddenSsid != apIface.Config().Hidden {
		// 	s.Fatalf("Unexpected hidden SSID status: got %t, want %t ", serInfo.Wifi.HiddenSsid, apIface.Config().Hidden)
		// }

		// TODO(crbug.com/1034875): Assert no deauth detected from the server side.
		// TODO(crbug.com/1034875): Maybe some more check on the WiFi capabilities to
		// verify we really have the settings as expected. (ref: crrev.com/c/1995105)
		s.Log("Deconfiguring")
	}

	testcases := s.Param().([]tdlsTestcase)
	for i, tc := range testcases {
		subtest := func(ctx context.Context, s *testing.State) {
			testOnce(ctx, s, tc.apOpts, tc.secConfFac)
		}
		if !s.Run(ctx, fmt.Sprintf("Testcase #%d", i), subtest) {
			// Stop if any sub-test failed.
			return
		}
	}
	s.Log("Tearing down")
}
