// Copyright 2022 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package wifi

import (
	"bytes"
	"context"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	// "chromiumos/tast/common/crypto/certificate"
	// "chromiumos/tast/common/network/ping"
	"chromiumos/tast/common/perf"
	"chromiumos/tast/common/wifi/security"
	// "chromiumos/tast/common/wifi/security/dynamicwep"
	// "chromiumos/tast/common/wifi/security/tunneled1x"
	// "chromiumos/tast/common/wifi/security/wep"
	"chromiumos/tast/common/wifi/security/wpa"
	// "chromiumos/tast/common/wifi/security/wpaeap"
	"chromiumos/tast/errors"
	"chromiumos/tast/remote/network/ip"
	"chromiumos/tast/remote/wificell"
	ap "chromiumos/tast/remote/wificell/hostapd"
	"chromiumos/tast/remote/wificell/router/common/support"
	// "chromiumos/tast/remote/wificell/wifiutil"
	"chromiumos/tast/services/cros/wifi"
	"chromiumos/tast/ssh"
	"chromiumos/tast/testing"
	// "chromiumos/tast/testing/hwdep"
)

type tdlsTestcase struct {
	apOpts []ap.Option
	// If unassigned, use default security config: open network.
	secConfFac security.ConfigFactory
}

// EAP certs/keys for EAP tests.
// var (
// 	eapCert1             = certificate.TestCert1()
// )

const (
	ifName        = "wlan0" // Needed for DUT/Peer symmetric calls.
	supplicantConfigPath = "/tmp/supplicant.cfg"
	tearDown             = true
)

func init() {
	testing.AddTest(&testing.Test{
		Func: Tdls,
		Desc: "TBD",
		Contacts: []string{
			"jck@semihalf.com",
			"chromeos-wifi-champs@google.com", // WiFi oncall rotation; or http://b/new?component=893827
		},
		Attr:        []string{"group:wificell", "wificell_func", "wificell_unstable"},
		ServiceDeps: []string{wificell.TFServiceName},
		Fixture:     "wificellFixt",
		Vars: []string{"peer"},
		Params: []testing.Param{
			// Parameters generated by simple_connect_test.go. DO NOT EDIT.
			{
				// Verifies that DUT can connect to an open 802.11a network on channels 48, 64.
				// Name: "basic",
				Val: []tdlsTestcase{{
					apOpts: []ap.Option{ap.Mode(ap.Mode80211g), ap.Channel(1)},
					secConfFac: wpa.NewConfigFactory(
						"chromeos", wpa.Mode(wpa.ModePureWPA),
						wpa.Ciphers(wpa.CipherCCMP),
					)}, //{
				// apOpts: []ap.Option{ap.Mode(ap.Mode80211a), ap.Channel(64)},
				//}
				},
			},
		}})
}

var apID int

func uniqueAPName() string {
	id := strconv.Itoa(apID)
	apID++
	return id
}

func Tdls(ctx context.Context, s *testing.State) {
	tf := s.FixtValue().(*wificell.TestFixture)

	pv := perf.NewValues()
	defer func() {
		if err := pv.Save(s.OutDir()); err != nil {
			s.Log("Failed to save perf data, err: ", err)
		}
	}()

	testOnce := func(ctx context.Context, s *testing.State, options []ap.Option, fac security.ConfigFactory) {
		peer, _ := s.Var("peer")
		if peer == "" {
			s.Fatalf("Peer device address not declared")
		}

		apIface, err := tf.ConfigureAP(ctx, options, fac)
		if err != nil {
			s.Fatal("Failed to configure ap, err: ", err)
		}

		// Validate required router functionality.
		type supportedRouter interface {
			support.Logs
			support.Hostapd
			support.DHCP
			support.Capture
		}

		r, ok := apIface.Router().(supportedRouter)
		if !ok {
			s.Fatalf("Router type %q does not have sufficient support for this test: ", apIface.Router().RouterTypeName())
		}

		defer func(ctx context.Context) {
			if err := tf.DeconfigAP(ctx, apIface); err != nil {
				s.Error("Failed to deconfig ap, err: ", err)
			}
		}(ctx)
		ctx, cancel := tf.ReserveForDeconfigAP(ctx, apIface)
		defer cancel()
		s.Log("AP setup done")

		// Some tests may fail as expected at following ConnectWifiAP(). In that case entries should still be deleted properly.
		defer func(ctx context.Context) {
			req := &wifi.DeleteEntriesForSSIDRequest{Ssid: []byte(apIface.Config().SSID)}
			if _, err := tf.WifiClient().DeleteEntriesForSSID(ctx, req); err != nil {
				s.Errorf("Failed to remove entries for ssid=%s, err: %v", apIface.Config().SSID, err)
			}
		}(ctx)

		_, err = tf.ConnectWifiAP(ctx, apIface)
		if err != nil {
			s.Fatal("Failed to connect to WiFi, err: ", err)
		}
		defer func(ctx context.Context) {
			if err := tf.CleanDisconnectWifi(ctx); err != nil {
				s.Error("Failed to disconnect WiFi, err: ", err)
			}
		}(ctx)
		ctx, cancel = tf.ReserveForDisconnect(ctx)
		defer cancel()
		s.Log("Connected DUT")

		var peerOpts ssh.Options
		if err := ssh.ParseTarget(peer, &peerOpts); err != nil {
			s.Fatal("Failed to parse peer data, err: ", err)
		}
		peerOpts.KeyDir = s.DUT().KeyDir()
		peerOpts.KeyFile = s.DUT().KeyFile()
			peerConn, err := ssh.New(ctx, &peerOpts)
		if err != nil {
			s.Fatal("Failed to connect peer device, err: ", err)
		}

		cmd := peerConn.CommandContext(ctx, "tee", "/dev/kmsg")
		cmd.Stdin = bytes.NewBuffer([]byte("FUBAR"))
		if err := cmd.Run(); err != nil {
			s.Error("Failed to execute the command: ", err)
			return
		}

		runnerCtx, cancel := context.WithTimeout(ctx, 20*time.Second)
		defer cancel()
		// ret, err := peerConn.CommandContext(runnerCtx, "iw", "phy", "phy0", "interface", "add",
		// 	ifName, "type", "managed").Output()
		// if err != nil {
		// 	// Maight laready exist.
		// 	s.Error("Failed to create managed0 device, err: ", err)
		// }
		// testing.ContextLogf(ctx, "Add: Ret: %v", ret)
		// defer func(ctx context.Context) {
		// 	if tearDown {
		// 		ret, _ := peerConn.CommandContext(ctx, "iw", "dev", ifName, "del").Output()
		// 		testing.ContextLogf(ctx, "Del: Ret: %s", ret)
		// 	}
		// }(ctx)

		// runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		// defer cancel()rfkill unblock wlan


		ret, err := peerConn.CommandContext(runnerCtx, "rfkill", "unblock ", "wlan").Output()
		if err != nil {
			// Maight already exist.
			s.Log("Failed to bring up the device, err: ", err)
		}
		testing.ContextLogf(ctx, "Add: Ret: %v", ret)
		defer func(ctx context.Context) {
			if tearDown {
				ret, _ := peerConn.CommandContext(ctx, "rfkill", "block ", "wlan").Output()
				testing.ContextLogf(ctx, "Del: Ret: %s", ret)
			}
		}(ctx)

		ret, err = peerConn.CommandContext(runnerCtx, "ip", "link ", "set", ifName, "up").Output()
		if err != nil {
			// Maight already exist.
			s.Log("Failed to bring up the device, err: ", err)
		}
		testing.ContextLogf(ctx, "Add: Ret: %v", ret)
		defer func(ctx context.Context) {
			if tearDown {
				ret, _ := peerConn.CommandContext(ctx, "ip", "link ", "set", ifName, "down").Output()
				testing.ContextLogf(ctx, "Del: Ret: %s", ret)
			}
		}(ctx)

		cfg, err := apIface.Config().SecurityConfig.HostapdConfig()
		// Handle error
		freqOps, err := apIface.Config().PcapFreqOptions()
		if err != nil {
			s.Fatal("Failed to get Freq Opts, err:", err)
		}
		apName := uniqueAPName()
		capturer, err := r.StartCapture(ctx, apName, apIface.Config().Channel, freqOps)
		if err != nil {
			s.Fatal("Failed to start capturer, err:", err)
		}
		defer func(ctx context.Context) {
			r.StopCapture(ctx, capturer)
		}(ctx)

		// dutCapturer, err := pcap.StartCapturer(ctx, s.DUT().Conn(), "dut", "wlan0", "/var/log/")
		// if err != nil {
		// 	s.Fatal("Failed to start DUT capturer: ", err)
		// }
		// ds.push(func() {
		// 	dutCapturer.Close(ctx)
		// })

		ret, err = peerConn.CommandContext(runnerCtx, "iwlist", ifName,
			"scan").Output()
		if err != nil {
			testing.ContextLogf(ctx, "Failure: Ret: %s", ret)
			testing.Sleep(ctx, 150*time.Second)
			s.Fatal("Failed to call iwlist, err: ", err)
		}
		testing.ContextLogf(ctx, "iwlist: Ret: %s", ret)

		// WPA_SUPPLICANT
		ret, err = peerConn.CommandContext(runnerCtx, "wpa_passphrase", apIface.Config().SSID,
			cfg["wpa_passphrase"]).Output()
		if err != nil {
			s.Fatal("Failed to call wpa_passphrase, err: ", err)
		}
		testing.ContextLogf(ctx, "Passphr: Ret: %s", ret)

		cmd = peerConn.CommandContext(ctx, "tee", supplicantConfigPath)
		cmd.Stdin = bytes.NewBuffer([]byte("ctrl_interface=DIR=/var/run/wpa_supplicant\n"))
		if err := cmd.Run(); err != nil {
			s.Fatal("Failed to execute the command: ", err)
			return
		}

		cmd = peerConn.CommandContext(ctx, "tee", "-a", supplicantConfigPath)
		cmd.Stdin = bytes.NewBuffer(ret)
		if err := cmd.Run(); err != nil {
			s.Error("Failed to execute the command: ", err)
			return
		}
		defer func(ctx context.Context) {
			if tearDown {
				ret, _ := peerConn.CommandContext(ctx, "wpa_cli", "terminate").Output()
				testing.ContextLogf(ctx, "Rm: Ret: %s", ret)
				ret, _ = peerConn.CommandContext(ctx, "rm", supplicantConfigPath).Output()
				testing.ContextLogf(ctx, "Rm: Ret: %s", ret)
			}
		}(ctx)

		ret, err = peerConn.CommandContext(runnerCtx, "wpa_supplicant", "-B", "-i", ifName,
			"-c", supplicantConfigPath).Output()
		if err != nil {
			s.Fatal("Failed to call wpa_supplicant, err: ", err)
		}

		expectOutput := func(str, lookup string, desired bool) bool {
			re := regexp.MustCompile(lookup)
			return re.MatchString(str) == desired
		}

		waitUntilExpcted := func(ctx context.Context, cmd *ssh.Cmd, lookup string, desired bool) (string, error)  {
			var output string
			if err := testing.Poll(ctx, func(ctx context.Context) error {
				testing.ContextLogf(ctx, "# %s", strings.Join(cmd.Args, " "))
				ret, err := cmd.Output()
				output = string(ret)
				if err != nil {
					testing.PollBreak(errors.Wrap(err, "Failed to call command, err: "))
				}
				if !expectOutput(string(ret), lookup, desired) {
					testing.ContextLogf(ctx, "Ret: [%s]. Waiting...", string(ret))
					testing.Sleep(ctx, 5*time.Second)
					return errors.Errorf("Command result: %s", ret)
				}

				return nil

			}, &testing.PollOptions{Timeout: 120 * time.Second}); err != nil {
				s.Fatal("Failed to reach desired output: ", err)
			}
			return output, err 
		}

		runnerCtx, cancel = context.WithTimeout(ctx, 130*time.Second)
		defer cancel()
		out, err := waitUntilExpcted(runnerCtx, peerConn.CommandContext(runnerCtx, "iw", ifName, "link"), 
			"Not connected.", false)
		if err != nil {
			s.Fatal("Failed to connect, err: ", err)
		}

		// runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		// defer cancel()

		// ret, err = peerConn.CommandContext(runnerCtx, "iw", ifName, "link").Output()
		// if err != nil {
		// 	s.Error("Failed to get link status, err: ", err)
		testing.ContextLogf(ctx, "link: Ret: %s", out)


		// IP
		peerConn.CommandContext(runnerCtx, "/sbin/dhclient", "-4", "-v", "-i", "-pf",
			"/run/dhclient.wlan0.pid", "-lf", "/var/lib/dhcp/dhclient.wlan0.leases", "-I", "-df", 
			"/var/lib/dhcp/dhclient6.wlan0.leases", ifName).Output()
		// ret, _ = peerConn.CommandContext(runnerCtx, "dhcpcd", ifName).Output()

		if !expectOutput(string(ret), "bound to", true) {
			s.Error("Failed to obtain an IP address, err: ", err)
		}
		testing.ContextLogf(ctx, "dhcpcd: Ret: %s", ret)
		defer func(ctx context.Context) {
			if tearDown {
				ret, _ := peerConn.CommandContext(ctx, "dhcpcd", ifName, "--release").Output()
			testing.ContextLogf(ctx, "dhcpcd Del: Ret: %s", ret)
			}
		}(ctx)

		// WPA_CLI
		// var re = regexp.MustCompile("OK")

		runnerCtx, cancel = context.WithTimeout(ctx, 130*time.Second)
		defer cancel()
		_, err = waitUntilExpcted(runnerCtx, peerConn.CommandContext(runnerCtx, "wpa_cli", "scan"), "OK", true)
		if err != nil {
			s.Fatal("Failed start scan through CLI, err: ", err)
		}
		// if err = testing.Poll(ctx, func(ctx context.Context) error {
		// 	ret, err = peerConn.CommandContext(runnerCtx, "wpa_cli", "scan").Output()
		// 	if err != nil {
		// 		testing.PollBreak(errors.Wrap(err, "Failed to call wpa_cli, err: "))
		// 	}
		// 	if !re.MatchString(string(ret)) {
		// 		testing.ContextLogf(ctx, "Ret: [%s]. Waiting for Scan...", string(ret))
		// 		testing.Sleep(ctx, 5*time.Second)
		// 		return errors.Errorf("Scan result: %s", ret)
		// 	}
		// 	return nil
		// }, &testing.PollOptions{Timeout: 120 * time.Second}); err != nil {
		// 	s.Fatal("Failed to scan: ", err)
		// }
		testing.Sleep(ctx, 10*time.Second)
		runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		defer cancel()
		ret, err = peerConn.CommandContext(runnerCtx, "wpa_cli", "scan_results").Output()
		if err != nil {
			s.Fatal("Failed to call wpa_cli, err: ", err)
		}
		testing.ContextLogf(ctx, "Scan results: Ret: %s", ret)
		// testing.Sleep(ctx, 60*time.Second)

		// Get the MAC address of WiFi interface.
		iface, err := tf.ClientInterface(ctx)
		if err != nil {
			s.Fatal("Failed to get WiFi interface of DUT: ", err)
		}
		ipr := ip.NewRemoteRunner(peerConn)
		hwMAC, err := ipr.MAC(ctx, iface)
		if err != nil {
			s.Fatal("Failed to get MAC of WiFi interface: ", err)
		}

		testing.ContextLogf(ctx, "DUT MAC: %s", hwMAC.String())

		runnerCtx, cancel = context.WithTimeout(ctx, 130*time.Second)
		defer cancel()
		_, err = waitUntilExpcted(runnerCtx, s.DUT().Conn().CommandContext(runnerCtx, "wpa_cli", "tdls_discover", hwMAC.String()), "OK", true)
		if err != nil {
			s.Fatal("Failed start scan through CLI, err: ", err)
		}

		// runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		// defer cancel()
		// ret, err = peerConn.CommandContext(runnerCtx, "wpa_cli", "tdls_discover", hwMAC.String()).Output()
		// if err != nil {
		// 	s.Fatal("Failed to call wpa_cli, err: ", err)
		// }
		// testing.ContextLogf(ctx, "TDLS Discover results: Ret: %s", ret)

		// desc := apIface.Config().PerfDesc()

		// pv.Set(perf.Metric{
		// 	Name:      desc,
		// 	Variant:   "Discovery",
		// 	Unit:      "seconds",
		// 	Direction: perf.SmallerIsBetter,
		// }, float64(resp.DiscoveryTime)/1e9)
		// pv.Set(perf.Metric{
		// 	Name:      desc,
		// 	Variant:   "Association",
		// 	Unit:      "seconds",
		// 	Direction: perf.SmallerIsBetter,
		// }, float64(resp.AssociationTime)/1e9)
		// pv.Set(perf.Metric{
		// 	Name:      desc,
		// 	Variant:   "Configuration",
		// 	Unit:      "seconds",
		// 	Direction: perf.SmallerIsBetter,
		// }, float64(resp.ConfigurationTime)/1e9)
		// ping := func(ctx context.Context) error {
		// 	return tf.PingFromDUT(ctx, apIface.ServerIP().String(), pingOps...)
		// }

		// if err := tf.AssertNoDisconnect(ctx, ping); err != nil {
		// 	s.Fatal("Failed to ping from DUT, err: ", err)
		// }

		// s.Log("Checking the status of the SSID in the DUT")
		// serInfo, err := tf.WifiClient().QueryService(ctx)
		// if err != nil {
		// 	s.Fatal("Failed to get the WiFi service information from DUT, err: ", err)
		// }

		// if serInfo.Wifi.HiddenSsid != apIface.Config().Hidden {
		// 	s.Fatalf("Unexpected hidden SSID status: got %t, want %t ", serInfo.Wifi.HiddenSsid, apIface.Config().Hidden)
		// }

		// TODO(crbug.com/1034875): Assert no deauth detected from the server side.
		// TODO(crbug.com/1034875): Maybe some more check on the WiFi capabilities to
		// verify we really have the settings as expected. (ref: crrev.com/c/1995105)
		s.Log("Deconfiguring")
	}

	testcases := s.Param().([]tdlsTestcase)
	for i, tc := range testcases {
		subtest := func(ctx context.Context, s *testing.State) {
			testOnce(ctx, s, tc.apOpts, tc.secConfFac)
		}
		if !s.Run(ctx, fmt.Sprintf("Testcase #%d", i), subtest) {
			// Stop if any sub-test failed.
			return
		}
	}
	s.Log("Tearing down")
}
