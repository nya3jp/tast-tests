// Copyright 2022 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package wifi

import (
	"bytes"
	"context"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	// "chromiumos/tast/common/crypto/certificate"
	// "chromiumos/tast/common/network/ping"
	// "chromiumos/tast/common/perf"
	"chromiumos/tast/common/wifi/security"
	// "chromiumos/tast/common/wifi/security/dynamicwep"
	// "chromiumos/tast/common/wifi/security/tunneled1x"
	// "chromiumos/tast/common/wifi/security/wep"
	"chromiumos/tast/common/wifi/security/wpa"
	// "chromiumos/tast/common/wifi/security/wpaeap"
	"chromiumos/tast/errors"
	"chromiumos/tast/remote/network/ip"
	"chromiumos/tast/remote/wificell"
	ap "chromiumos/tast/remote/wificell/hostapd"
	"chromiumos/tast/remote/wificell/router/common/support"
	// "chromiumos/tast/remote/wificell/wifiutil"
	"chromiumos/tast/services/cros/wifi"
	"chromiumos/tast/ssh"
	"chromiumos/tast/testing"
	// "chromiumos/tast/testing/hwdep"
)

type tdlsTestcase struct {
	apOpts []ap.Option
	// If unassigned, use default security config: open network.
	secConfFac security.ConfigFactory
}

// EAP certs/keys for EAP tests.
// var (
// 	eapCert1             = certificate.TestCert1()
// )

const (
	ifName        = "wlan0" // Needed for DUT/Peer symmetric calls.
	supplicantConfigPath = "/tmp/supplicant.cfg"
	tearDown             = true
)

func init() {
	testing.AddTest(&testing.Test{
		Func: Tdls,
		Desc: "TBD",
		Contacts: []string{
			"jck@semihalf.com",
			"chromeos-wifi-champs@google.com", // WiFi oncall rotation; or http://b/new?component=893827
		},
		Attr:        []string{"group:wificell", "wificell_func", "wificell_unstable"},
		ServiceDeps: []string{wificell.TFServiceName},
		Fixture:     "wificellFixt",
		Vars: []string{"peer"},
		Params: []testing.Param{
			// Parameters generated by simple_connect_test.go. DO NOT EDIT.
			{
				// Verifies that DUT can connect to an open 802.11a network on channels 48, 64.
				// Name: "basic",
				Val: []tdlsTestcase{{
					apOpts: []ap.Option{ap.Mode(ap.Mode80211g), ap.Channel(1)},
					secConfFac: wpa.NewConfigFactory(
						"chromeos", wpa.Mode(wpa.ModePureWPA),
						wpa.Ciphers(wpa.CipherCCMP),
					)}, //{
				// apOpts: []ap.Option{ap.Mode(ap.Mode80211a), ap.Channel(64)},
				//}
				},
			},
		}})
}

var apID int

func uniqueAPName() string {
	id := strconv.Itoa(apID)
	apID++
	return id
}

func expectOutput(str, lookup string) bool {
	re := regexp.MustCompile(lookup)
	return re.MatchString(str)
}

func runAndCheckOutput(ctx context.Context, cmd ssh.Cmd, lookup string) (bool, error)  {
	testing.ContextLogf(ctx, "# %s", strings.Join(cmd.Args, " "))
	ret, err := cmd.CombinedOutput()//Output()
	testing.ContextLogf(ctx, "Output: %s", string(ret))
	if err != nil {
		return false, errors.Wrap(err, "Failed to call command, err: ")
	}
	return expectOutput(string(ret), lookup), nil
}

func waitUntilExpcted(ctx context.Context, cmd ssh.Cmd, lookup string) (string, error)  {
	var output string
	err := testing.Poll(ctx, func(ctx context.Context) error {
		testing.ContextLogf(ctx, "# %s", strings.Join(cmd.Args, " "))
		cmdCpy := cmd
		ret, err := cmdCpy.Output()
		output = string(ret)
		testing.ContextLogf(ctx, "Output: %s", string(ret))
		if err != nil {
			testing.PollBreak(errors.Wrap(err, "Failed to call command, err: "))
		}
		if !expectOutput(string(ret), lookup) {
			testing.ContextLogf(ctx, "Unexpected output. Waiting...")
			// cmd.Stdout = nil
			testing.Sleep(ctx, 5*time.Second)
			return errors.Errorf("Command result: %s", ret)
		}
		return nil
	}, &testing.PollOptions{Timeout: 60 * time.Second})
	if err != nil {
		return "", errors.Wrapf(err, "Failed to reach desired output: ")
	}
	return output, err
}

func setupDHCP(ctx context.Context, conn *ssh.Conn, ifName string) (string, error) {
	runnerCtx, cancel := context.WithTimeout(ctx, 60*time.Second)
	defer cancel()

	dhcpPidFile, err := conn.CommandContext(runnerCtx, "dhcpcd", "-4", "-P", ifName).CombinedOutput()
	testing.ContextLogf(ctx, "DHCP PID file: %s", dhcpPidFile)
	if err != nil {
		return "", errors.Wrap(err, "Failed to get pid file: ")
	}
	dhcpPid, err := conn.CommandContext(runnerCtx, "cat", strings.TrimSpace(string(dhcpPidFile))).CombinedOutput()
	testing.ContextLogf(ctx, "DHCP PID: %s", dhcpPid)
	if err == nil {
		testing.ContextLog(ctx, "DHCP client already running, trying to kill")
		conn.CommandContext(runnerCtx, "kill", "-9", strings.TrimSpace(string(dhcpPid))).Run()
	}
	cmd := conn.CommandContext(runnerCtx, "dhcpcd", "-4", ifName)
	ok, err := runAndCheckOutput(runnerCtx, *cmd, "status changed to Bound")
	if err != nil {
		return "", errors.New("Failed to start DHCP client: ")
	} else if !ok {
		return "", errors.New("Failed to obtain the IP address")
	} else {
		dhcpPid, err := conn.CommandContext(runnerCtx, "cat", strings.TrimSpace(string(dhcpPidFile))).CombinedOutput()
		testing.ContextLogf(ctx, "DHCP PID: %s", strings.TrimSpace(string(dhcpPid)))
		if err != nil {
			return "", errors.Wrapf(err, "Failed to get pid: ")
		}
	}
	return strings.TrimSpace(string(dhcpPid)), nil
}

func setupSupplicant(ctx context.Context, conn *ssh.Conn, ssid, passphrase string) (error, func(ctx context.Context)) {
	ret, err := conn.CommandContext(ctx, "stop", "wpasupplicant").Output()
	// if err != nil {
	// 	return errors.New("Failed to stop WPA Supplicant"), nil
	// }
	ret, err = conn.CommandContext(ctx, "wpa_passphrase", ssid, passphrase).Output()
	if err != nil {
		return errors.Wrap(err, "Failed to call wpa_passphrase, err: "), nil
	}
	testing.ContextLogf(ctx, "Passphr: Ret: %s", ret)

	cmd := conn.CommandContext(ctx, "tee", supplicantConfigPath)
	cmd.Stdin = bytes.NewBuffer([]byte("ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wpa\n"))
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "Failed to execute the command: "), nil
	}

	cmd = conn.CommandContext(ctx, "tee", "-a", supplicantConfigPath)
	cmd.Stdin = bytes.NewBuffer(ret)
	if err := cmd.Run(); err != nil {
		return errors.Wrap(err, "Failed to execute the command: "), nil
	}
	ret, err = conn.CommandContext(ctx,// "sudo", "-u", "wpa",
		"wpa_supplicant", "-B", "-i", ifName, "-c", supplicantConfigPath).CombinedOutput()
	if err != nil {
		testing.ContextLogf(ctx, "Supplicant start: %s", ret)
		return errors.Wrap(err, "Failed to call wpa_supplicant, err: "), nil
	}
	return nil, func(ctx context.Context) {
		ret, _ := wpaCli(ctx, conn, "", "terminate")
		testing.ContextLogf(ctx, "Supplicant terminate: %s", ret)
		conn.CommandContext(ctx, "rm", supplicantConfigPath).Output()
		_, err = conn.CommandContext(ctx, "start", "wpasupplicant").Output()
		if err != nil {
			testing.ContextLog(ctx, "Failed to restart WPA Supplicant")
		}
	}
}

func wpaCli(ctx context.Context, conn *ssh.Conn, result string, cmd ...string) (string, error) {
	runnerCtx, cancel := context.WithTimeout(ctx, 130*time.Second)
	defer cancel()
	args := []string{"sudo", "-u", "wpa", "wpa_cli"}
	args = append(args, cmd...)

	output, err := waitUntilExpcted(runnerCtx, *conn.CommandContext(runnerCtx, "sudo", args...), result)
	if err != nil {
		return "", errors.Wrap(err, "Failed to run WPA CLI, err: ")
	}
	return output, nil
}

func Tdls(ctx context.Context, s *testing.State) {
	tf := s.FixtValue().(*wificell.TestFixture)

	// pv := perf.NewValues()
	// defer func() {
	// 	if err := pv.Save(s.OutDir()); err != nil {
	// 		s.Log("Failed to save perf data, err: ", err)
	// 	}
	// }()

	testOnce := func(ctx context.Context, s *testing.State, options []ap.Option, fac security.ConfigFactory) {
		peer, _ := s.Var("peer")
		if peer == "" {
			s.Fatal("Peer device address not declared")
		}

		apIface, err := tf.ConfigureAP(ctx, options, fac)
		if err != nil {
			s.Fatal("Failed to configure ap, err: ", err)
		}

		defer func(ctx context.Context) {
			if err := tf.DeconfigAP(ctx, apIface); err != nil {
				s.Error("Failed to deconfig ap, err: ", err)
			}
		}(ctx)
		ctx, cancel := tf.ReserveForDeconfigAP(ctx, apIface)
		defer cancel()
		s.Log("AP setup done")

		// Some tests may fail as expected at following ConnectWifiAP(). In that case entries should still be deleted properly.
		defer func(ctx context.Context) {
			req := &wifi.DeleteEntriesForSSIDRequest{Ssid: []byte(apIface.Config().SSID)}
			if _, err := tf.WifiClient().DeleteEntriesForSSID(ctx, req); err != nil {
				s.Errorf("Failed to remove entries for ssid=%s, err: %v", apIface.Config().SSID, err)
			}
		}(ctx)

		_, err = tf.ConnectWifiAP(ctx, apIface)
		if err != nil {
			s.Fatal("Failed to connect to WiFi, err: ", err)
		}
		defer func(ctx context.Context) {
			if err := tf.CleanDisconnectWifi(ctx); err != nil {
				s.Error("Failed to disconnect WiFi, err: ", err)
			}
		}(ctx)
		ctx, cancel = tf.ReserveForDisconnect(ctx)
		defer cancel()
		s.Log("Connected DUT")

		// Connect the peer device.
		var peerOpts ssh.Options
		if err := ssh.ParseTarget(peer, &peerOpts); err != nil {
			s.Fatal("Failed to parse peer data, err: ", err)
		}
		peerOpts.KeyDir = s.DUT().KeyDir()
		peerOpts.KeyFile = s.DUT().KeyFile()
			peerConn, err := ssh.New(ctx, &peerOpts)
		if err != nil {
			s.Fatal("Failed to connect peer device, err: ", err)
		}
		defer func(ctx context.Context) {
			peerConn.Close(ctx)
		}(ctx)

		// cmd := peerConn.CommandContext(ctx, "tee", "/dev/kmsg")
		// cmd.Stdin = bytes.NewBuffer([]byte("---"))
		// if err := cmd.Run(); err != nil {
		// 	s.Error("Failed to execute the command: ", err)
		// 	return
		// }

		runnerCtx, cancel := context.WithTimeout(ctx, 20*time.Second)
		defer cancel()

		// wlan0 interface might or might not exist. Create if necessary.
		if err = peerConn.CommandContext(runnerCtx, "ip", "a", "sh", ifName).Run(); err != nil {
			// No interface, create it.
			if err := peerConn.CommandContext(runnerCtx, "iw", "phy", "phy0", "interface", "add",
				ifName, "type", "managed").Run(); err != nil {
				s.Fatal("Failed to create device, err: ", err)
			}
			defer func(ctx context.Context) {
				if err := peerConn.CommandContext(ctx, "iw", "dev", ifName, "del").Run(); err != nil {
					s.Errorf("Failed to delete device %s, err: %v", ifName, err)
				}
			}(ctx)
		}

		runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		defer cancel()

		// Disable rfkill on wlan if necessary.
		ok, _ := runAndCheckOutput(runnerCtx, *peerConn.CommandContext(runnerCtx, "rfkill", "list", "wlan"), "Soft blocked: yes")
		if ok {
			ret, err := peerConn.CommandContext(runnerCtx, "rfkill", "unblock ", "wlan").Output()
			if err != nil {
				s.Log("Failed to disable rfkill, err: ", err)
			}
			testing.ContextLogf(ctx, "Add: Ret: %v", ret)
			defer func(ctx context.Context) {
				if err := peerConn.CommandContext(ctx, "rfkill", "block ", "wlan").Run(); err != nil {
					s.Error("Failed to block wlan, err: %v", err)
				}
			}(ctx)
		}

		runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		defer cancel()

		// Bring up the interface, if it's down.
		ifUp, _ := runAndCheckOutput(runnerCtx, *peerConn.CommandContext(runnerCtx, "ip", "link", "sh", ifName), "BROADCAST,MULTICAST,UP")
		if !ifUp {
			// ret, err := peerConn.CommandContext(runnerCtx, "ip", "link", "set", ifName, "up").Output()
			_, err := runAndCheckOutput(runnerCtx, *peerConn.CommandContext(runnerCtx, "ip", "link", "set", ifName, "up"), "")
			if err != nil {
				s.Log("Failed to bring up the device, err: ", err)
			} else {
				defer func(ctx context.Context) {
					if err := peerConn.CommandContext(ctx, "ip", "link ", "set", ifName, "down").Run(); err != nil {
						s.Errorf("Failed to bring down %s, err: %v", ifName, err)
					}
				}(ctx)
			}
		}

		cfg, err := apIface.Config().SecurityConfig.HostapdConfig()
		// Handle error
		freqOps, err := apIface.Config().PcapFreqOptions()
		if err != nil {
			s.Fatal("Failed to get Freq Opts, err:", err)
		}

		// Setup capture.
		type supportedRouter interface {
			support.Capture
		}

		r, ok := apIface.Router().(support.Capture)
		if !ok {
			s.Fatalf("Router type %q does not have sufficient support for this test: ", apIface.Router().RouterTypeName())
		}

		apName := uniqueAPName()
		capturer, err := r.StartCapture(ctx, apName, apIface.Config().Channel, freqOps)
		if err != nil {
			s.Fatal("Failed to start capturer, err:", err)
		}
		defer func(ctx context.Context) {
			r.StopCapture(ctx, capturer)
		}(ctx)

		// Scan looking for SSID.
		ret, err := peerConn.CommandContext(runnerCtx, "iwlist", ifName, "scan").Output()
		if err != nil {
			testing.ContextLogf(ctx, "Failure: Ret: %s", ret)
			s.Fatal("Failed to call iwlist scan, err: ", err)
		}
		testing.ContextLogf(ctx, "iwlist: Ret: %s", ret)

		// WPA_SUPPLICANT
		err, teardown := setupSupplicant(ctx, peerConn, apIface.Config().SSID, cfg["wpa_passphrase"])
		if err != nil {
			s.Fatal("Failed to setup WPA Supplicant, err: ", err)
		}
		defer teardown(ctx)

		runnerCtx, cancel = context.WithTimeout(ctx, 130*time.Second)
		defer cancel()

		// Wait until we see STA is connected.
		out, err := waitUntilExpcted(runnerCtx, *peerConn.CommandContext(runnerCtx, "iw", ifName, "link"), 
			"SSID: " + apIface.Config().SSID)
		if err != nil {
			s.Fatal("Failed to connect, err: ", err)
		}

		testing.ContextLogf(ctx, "Link established: %s", out)

		// IP
		pid, err := setupDHCP(ctx, peerConn, ifName)
		if err != nil {
			s.Error("Failed to get IP address, err: ", err)
		}
		defer func(ctx context.Context) {
			testing.ContextLog(ctx, "DHCP client teardown")
			ret, err := peerConn.CommandContext(ctx, "kill", "-9", pid).CombinedOutput()
			if err != nil {
				testing.ContextLogf(ctx, "Error: %s", ret)
				s.Error("Failed to tear down dhclient, err: ", err)
			}
		}(ctx)

		// WPA_CLI - repeat scan. This just confirms WPA_CLI works.
		_, err = wpaCli(ctx, peerConn, "OK", "scan")
		if err != nil {
			s.Fatal("Failed start scan through CLI, err: ", err)
		}
		// testing.Sleep(ctx, 10*time.Second)
		
		runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		defer cancel()
		results, err := wpaCli(ctx, peerConn, "", "scan_results")
		if err != nil {
			s.Fatal("Failed to call wpa_cli, err: ", err)
		}
		testing.ContextLogf(ctx, "Scan results: %s", results)
		if !expectOutput(results, apIface.Config().SSID) {
			s.Fatal("Failed to observe SSID in scan results, err: ", err)
		}

		getMAC := func(ctx context.Context, conn *ssh.Conn, ifName string) (string, error) {
			ipr := ip.NewRemoteRunner(conn)
			hwMAC, err := ipr.MAC(ctx, ifName)
			if err != nil {
				return "", errors.Wrap(err, "Failed to get MAC of WiFi interface: ")
			}
			return hwMAC.String(), nil
		}

		// Get MACs.
		runnerCtx, cancel = context.WithTimeout(ctx, 20*time.Second)
		defer cancel()
		dutMAC, err := getMAC(runnerCtx, s.DUT().Conn(), ifName)
		if err != nil {
			s.Error("Failed to get MAC Address of DUT's wlan, err: ", err)
		}
		testing.ContextLogf(ctx, "DUT MAC: %s", dutMAC)
		peerMAC, err := getMAC(runnerCtx, peerConn, "wlan0")
		if err != nil {
			s.Error("Failed to get MAC Address of DUT's wlan, err: ", err)
		}
		testing.ContextLogf(ctx, "Peer MAC: %s", peerMAC)

		testTDLS := func(ctx context.Context, peer1Conn, peer2Conn *ssh.Conn, peer2Addr string) error {
			_, err = wpaCli(ctx, peerConn, "OK", "tdls_discover", peer2Addr)
			if err != nil {
				return errors.Wrap(err, "Failed TDLS Discover, err: ")
			}
			return nil
		}

		runnerCtx, cancel = context.WithTimeout(ctx, 130*time.Second)
		defer cancel()

		// Test TDLS in both directions (active: DUT-originated, passive:DUT-terminated).
		if err = testTDLS(runnerCtx, s.DUT().Conn(), peerConn, peerMAC); err != nil {
			s.Error("TDLS test failed in direction DUT->Peer, err: ", err)
		}

		runnerCtx, cancel = context.WithTimeout(ctx, 130*time.Second)
		defer cancel()

		if err = testTDLS(runnerCtx, peerConn, s.DUT().Conn(), dutMAC); err != nil {
			s.Error("TDLS test failed in direction Peer->DUT, err: ", err)
		}
		s.Log("Deconfiguring")
	}

	testcases := s.Param().([]tdlsTestcase)
	for i, tc := range testcases {
		subtest := func(ctx context.Context, s *testing.State) {
			testOnce(ctx, s, tc.apOpts, tc.secConfFac)
		}
		if !s.Run(ctx, fmt.Sprintf("Testcase #%d", i), subtest) {
			// Stop if any sub-test failed.
			return
		}
	}
	s.Log("Tearing down")
}
