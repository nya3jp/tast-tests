// Copyright 2021 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package wifi

import (
	"context"
	"fmt"

	"chromiumos/tast/common/network/ping"
	"chromiumos/tast/remote/wificell"
	"chromiumos/tast/remote/wificell/dutcfg"
	"chromiumos/tast/remote/wificell/router"
	"chromiumos/tast/remote/wificell/security"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func: AxSimpleConnect,
		Desc: "Verifies that DUT can connect to the host via AP in different WiFi configuration",
		Contacts: []string{
			"chromeos-wifi-champs@google.com", // WiFi oncall rotation; or http://b/new?component=893827
		},
		Attr:        []string{"group:wificell", "wificell_func"},
		ServiceDeps: []string{wificell.TFServiceName},
		Vars:        []string{"router", "pcap"},
		Params: []testing.Param{
			// Parameters generated by simple_connect_test.go. DO NOT EDIT.
			{
				// Verifies that DUT can connect to an open 802.11a network on channels 48, 64.
				Name: "OpenAx",
				Val: []axSimpleConnectTestcase{{
					band:   router.Wl1,
					apOpts: []router.Option{router.Mode(router.Mode80211ax), router.Channel(48)},
				}, {
					band:   router.Wl1,
					apOpts: []router.Option{router.Mode(router.Mode80211ax), router.Channel(64)},
				}},
			},
		},
	})
}

type axSimpleConnectTestcase struct {
	apOpts []router.Option
	band   router.BandEnum
	// If unassigned, use default security config: open network.
	secConfFac      security.AxConfigFactory
	pingOps         []ping.Option
	expectedFailure bool
}

func AxSimpleConnect(ctx context.Context, s *testing.State) {
	var tfOps []wificell.TFOption
	if router, ok := s.Var("router"); ok && router != "" {
		tfOps = append(tfOps, wificell.TFRouter(router))
	}
	tfOps = append(tfOps, wificell.TFRouterType(router.AxT))
	// Assert WiFi is up.
	tf, err := wificell.NewTestFixture(ctx, ctx, s.DUT(), s.RPCHint(), tfOps...)
	if err != nil {
		s.Fatal("Failed to set up test fixture: ", err)
	}

	defer func(ctx context.Context) {
		if err := tf.CollectLogs(ctx); err != nil {
			s.Log("Error collecting logs, err: ", err)
		}
		if err := tf.Close(ctx); err != nil {
			s.Error("Failed to properly take down test fixture: ", err)
		}
	}(ctx)
	ctx, cancel := tf.ReserveForClose(ctx)
	defer cancel()

	rt, err := tf.AxRouter()
	if err != nil {
		s.Fatal("Failed to get ax router: ", err)

	}
	if err := rt.SaveConfiguration(ctx); err != nil {
		s.Fatalf("Could not save current router configuration: ", err)
	}
	defer rt.RestoreConfiguration(ctx)

	testOnce := func(ctx context.Context, s *testing.State, band router.BandEnum, options []router.Option, fac security.AxConfigFactory, pingOps []ping.Option, expectedFailure bool) {
		var cfg router.Config
		cfg.Band = band
		for _, opt := range options {
			opt(&cfg)
		}

		secCfg, err := fac.Gen()
		if err != nil {
			s.Fatal("could not generate security config: ", secCfg)
		}
		cfg.RouterConfigParams = append(cfg.RouterConfigParams, secCfg.RouterParams()...)

		if err = rt.ApplyRouterSettings(ctx, cfg.RouterConfigParams); err != nil {
			s.Error("Could not set ax settings ", err)
		}

		ip, err := rt.GetRouterIP(ctx)
		if err != nil {
			s.Error("Could not get ip addr ", err)
		}
		s.Logf("IP IS %s", ip)

		connopts := append(cfg.DutConnOptions, dutcfg.ConnSecurity(secCfg.SecConfig()))

		_, err = tf.ConnectWifi(ctx, "googTest", connopts...)
		if err != nil {
			if expectedFailure {
				s.Log("Failed to connect to WiFi as expected")
				// If we expect to fail, then this test is already done.
				return
			}
			s.Fatal("Failed to connect to WiFi, err: ", err)
		}
		if err := tf.PingFromDUT(ctx, ip); err != nil {
			s.Error("Failed to ping from the DUT ", err)
		}
		defer func(ctx context.Context) {
			if err := tf.CleanDisconnectWifi(ctx); err != nil {
				s.Error("Failed to disconnect WiFi, err: ", err)
			}
		}(ctx)
		ctx, cancel = tf.ReserveForDisconnect(ctx)
		defer cancel()
		if expectedFailure {
			s.Fatal("Expected to fail to connect to WiFi, but it was successful")
		}
		s.Log("Connected")

		ping := func(ctx context.Context) error {
			return tf.PingFromDUT(ctx, ip, pingOps...)
		}

		if err := tf.AssertNoDisconnect(ctx, ping); err != nil {
			s.Fatal("Failed to ping from DUT, err: ", err)
		}

		s.Log("Checking the status of the SSID in the DUT")
		//serInfo, err := tf.QueryService(ctx)
		_, err = tf.QueryService(ctx)
		if err != nil {
			s.Fatal("Failed to get the WiFi service information from DUT, err: ", err)
		}

		// if serInfo.Wifi.HiddenSsid != ap.Config().Hidden {
		// 	s.Fatalf("Unexpected hidden SSID status: got %t, want %t ", serInfo.Wifi.HiddenSsid, ap.Config().Hidden)
		// }

		// TODO(crbug.com/1034875): Assert no deauth detected from the server side.
		// TODO(crbug.com/1034875): Maybe some more check on the WiFi capabilities to
		// verify we really have the settings as expected. (ref: crrev.com/c/1995105)
		s.Log("Deconfiguring")
	}

	testcases := s.Param().([]axSimpleConnectTestcase)
	for i, tc := range testcases {
		subtest := func(ctx context.Context, s *testing.State) {
			testOnce(ctx, s, tc.band, tc.apOpts, tc.secConfFac, tc.pingOps, tc.expectedFailure)
		}
		if !s.Run(ctx, fmt.Sprintf("Testcase #%d", i), subtest) {
			// Stop if any sub-test failed.
			return
		}
	}
	s.Log("Tearing down")
}
