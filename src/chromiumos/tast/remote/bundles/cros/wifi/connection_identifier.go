// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package wifi

import (
	"context"
	"time"

	"chromiumos/tast/errors"
	"chromiumos/tast/remote/wificell"
	"chromiumos/tast/remote/wificell/hostapd"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:        ConnectionIdentifier,
		Desc:        "Verify the correctness of connection identifier, which is generated by shill, and should be the same iff connecting to the same network, i.e., network with the same gateway IP address and MAC address",
		Contacts:    []string{"chharry@google.com", "chromeos-platform-connectivity@google.com"},
		Attr:        []string{"group:wificell", "wificell_cq", "wificell_func", "wificell_unstable"},
		ServiceDeps: []string{wificell.TFServiceName},
		Pre:         wificell.TestFixturePre(),
		Vars:        []string{"router", "pcap"},
	})
}

func ConnectionIdentifier(ctx context.Context, s *testing.State) {
	tf := s.PreValue().(*wificell.TestFixture)
	defer func(ctx context.Context) {
		if err := tf.CollectLogs(ctx); err != nil {
			s.Log("Error collecting logs, err: ", err)
		}
	}(ctx)
	ctx, cancel := tf.ReserveForCollectLogs(ctx)
	defer cancel()

	// getConnectionID connects to the AP, and gets the connection identifier, then disconnects.
	getConnectionID := func(ctx context.Context, ap *wificell.APIface) int32 {
		if _, err := tf.ConnectWifiAP(ctx, ap); err != nil {
			s.Fatal("Failed to connect to WiFi: ", err)
		}
		defer func(ctx context.Context) {
			if err := tf.CleanDisconnectWifi(ctx); err != nil {
				s.Fatal("Failed to disconnect WiFi: ", err)
			}
		}(ctx)
		ctx, cancel := tf.ReserveForDisconnect(ctx)
		defer cancel()

		// Connection identifier may still be zero right after connecting due to race condition.
		// Use polling here because ConnectionId does not trigger a PropertyChanged signal, i.e., can not use PropertyWatcher.
		var connectionID int32
		if err := testing.Poll(ctx, func(ctx context.Context) error {
			resp, err := tf.QueryService(ctx)
			if err != nil {
				return err
			}
			if resp.ConnectionId == 0 {
				return errors.New("connection identifier is zero")
			}
			connectionID = resp.ConnectionId
			return nil
		}, &testing.PollOptions{
			Timeout:  time.Second * 10,
			Interval: time.Second,
		}); err != nil {
			s.Fatal("Failed to wait for connection identifier becoming valid: ", err)
		}
		return connectionID
	}

	// Start two APs simultaneously so they would have different IP addresses.
	aps := make([]*wificell.APIface, 2)
	for i, ch := range []int{1, 48} {
		ap, err := tf.ConfigureAP(ctx, []hostapd.Option{
			hostapd.Mode(hostapd.Mode80211nPure), hostapd.Channel(ch),
			hostapd.HTCaps(hostapd.HTCapHT20),
		}, nil)
		if err != nil {
			s.Fatal("Failed to configure the AP: ", err)
		}
		defer func(ctx context.Context) {
			if err := tf.DeconfigAP(ctx, ap); err != nil {
				s.Error("Failed to deconfig the AP: ", err)
			}
		}(ctx)
		ctx, cancel = tf.ReserveForDeconfigAP(ctx, ap)
		defer cancel()

		aps[i] = ap
		s.Logf("AP%d setup done: ", i)
	}

	connectionIDs := make([]int32, 2)
	for i, ap := range aps {
		connectionIDs[i] = getConnectionID(ctx, ap)
	}

	if connectionIDs[0] == connectionIDs[1] {
		s.Fatal("Connection identifier should be different for two different networks")
	}

	for i, ap := range aps {
		// Add additional prefix "CONN_ID_" in SSID to guarantee we have different SSIDs.
		if err := ap.ChangeSSID(ctx, hostapd.RandomSSID("TAST_TEST_CONN_ID_")); err != nil {
			s.Fatalf("Failed to change the SSID of AP%d: %v", i, err)
		}
	}

	// Connection identifiers should be the same regardless of the SSIDs.
	for i, ap := range aps {
		if id := getConnectionID(ctx, ap); id != connectionIDs[i] {
			s.Errorf("Connection identifier of AP%d not match: got %d, want %d", i, id, connectionIDs[i])
		}
	}
}
