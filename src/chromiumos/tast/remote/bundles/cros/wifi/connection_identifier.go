// Copyright 2020 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package wifi

import (
	"context"
	"time"

	"chromiumos/tast/errors"
	"chromiumos/tast/remote/wificell"
	"chromiumos/tast/remote/wificell/hostapd"
	"chromiumos/tast/testing"
)

func init() {
	testing.AddTest(&testing.Test{
		Func:        ConnectionIdentifier,
		Desc:        "Verify the correctness of connection identifier generated by shill. And the identifiers should be the same iff they connect to the same network, i.e., network with the same gateway IP address and MAC address",
		Contacts:    []string{"chharry@google.com", "chromeos-platform-connectivity@google.com"},
		Attr:        []string{"group:wificell", "wificell_cq", "wificell_func", "wificell_unstable"},
		ServiceDeps: []string{wificell.TFServiceName},
		Pre:         wificell.TestFixturePre(),
		Vars:        []string{"router", "pcap"},
	})
}

func ConnectionIdentifier(ctx context.Context, s *testing.State) {
	tf := s.PreValue().(*wificell.TestFixture)
	defer func(ctx context.Context) {
		if err := tf.CollectLogs(ctx); err != nil {
			s.Log("Error collecting logs, err: ", err)
		}
	}(ctx)
	ctx, cancel := tf.ReserveForCollectLogs(ctx)
	defer cancel()

	// getConnectionID connects to the AP, and gets the connection identifier, then disconnects.
	getConnectionID := func(ctx context.Context, ap *wificell.APIface) int32 {
		if _, err := tf.ConnectWifiAP(ctx, ap); err != nil {
			s.Fatal("Failed to connect to WiFi: ", err)
		}
		defer func(ctx context.Context) {
			if err := tf.CleanDisconnectWifi(ctx); err != nil {
				s.Fatal("Failed to disconnect WiFi: ", err)
			}
		}(ctx)
		ctx, cancel := tf.ReserveForDisconnect(ctx)
		defer cancel()

		// Connection identifier may still be zero right after connecting due to race condition.
		// Use polling instead of PropertyWatcher here because ConnectionId change does not trigger a PropertyChanged signal, i.e., can not use PropertyWatcher.
		var connectionID int32
		if err := testing.Poll(ctx, func(ctx context.Context) error {
			resp, err := tf.QueryService(ctx)
			if err != nil {
				return err
			}
			if resp.ConnectionId == 0 {
				return errors.New("connection identifier is zero")
			}
			connectionID = resp.ConnectionId
			return nil
		}, &testing.PollOptions{
			Timeout:  time.Second * 10,
			Interval: time.Millisecond * 100,
		}); err != nil {
			s.Fatal("Failed to wait for connection identifier becoming valid: ", err)
		}
		return connectionID
	}

	// SSID prefixes for avoiding conflicts.
	var (
		ssidPrefixesBefore = []string{"TAST_TEST_BEFORE_AP0_", "TAST_TEST_BEFORE_AP1_"}
		ssidPrefixesAfter  = []string{"TAST_TEST_AFTER_AP0_", "TAST_TEST_AFTER_AP1_"}
	)

	// Start two APs simultaneously so they would have different IP addresses.
	aps := make([]*wificell.APIface, 2)
	for i, ch := range []int{1, 48} {
		s.Log("Setting up AP", i)
		ap, err := tf.ConfigureAP(ctx, []hostapd.Option{
			hostapd.SSID(hostapd.RandomSSID(ssidPrefixesBefore[i])),
			hostapd.Mode(hostapd.Mode80211nPure), hostapd.Channel(ch),
			hostapd.HTCaps(hostapd.HTCapHT20),
		}, nil)
		if err != nil {
			s.Fatal("Failed to configure the AP: ", err)
		}
		defer func(ctx context.Context) {
			if err := tf.DeconfigAP(ctx, ap); err != nil {
				s.Error("Failed to deconfig the AP: ", err)
			}
		}(ctx)
		ctx, cancel = tf.ReserveForDeconfigAP(ctx, ap)
		defer cancel()

		aps[i] = ap
	}

	s.Log("Obtaining connection identifiers of the two APs")
	connectionIDs := make([]int32, 2)
	for i, ap := range aps {
		connectionIDs[i] = getConnectionID(ctx, ap)
	}

	if connectionIDs[0] == connectionIDs[1] {
		s.Fatal("The two connection identifiers should be different for two different networks")
	}

	for i, ap := range aps {
		if err := ap.ChangeSSID(ctx, hostapd.RandomSSID(ssidPrefixesAfter[i])); err != nil {
			s.Fatalf("Failed to change the SSID of AP%d: %v", i, err)
		}
	}

	// Connection identifiers should be the same regardless of the SSIDs.
	for i, ap := range aps {
		if id := getConnectionID(ctx, ap); id != connectionIDs[i] {
			s.Errorf("Connection identifier of AP%d should be the same after changing SSID: got %d, want %d", i, id, connectionIDs[i])
		}
	}
}
