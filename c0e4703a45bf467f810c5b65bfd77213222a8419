{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "55ffdcfb_15174be5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 1355245
      },
      "writtenOn": "2021-07-01T03:28:10Z",
      "side": 1,
      "message": "nit: it would be great if it has sha hash for future reference, otherwise line number or file location is easily changed. e.g. https://source.chromium.org/chromiumos/chromiumos/codesearch/+/main:src/platform/tast-tests/src/chromiumos/tast/local/chrome/ui/automation.go;l\u003d501;drc\u003d8379909dc26b1014dc9f3098f3f530a35f5cb638\n\nAlso URL can be oneline so that we can copy-paste it and Gerrit labels anchor link correctly",
      "range": {
        "startLine": 19,
        "startChar": 4,
        "endLine": 21,
        "endChar": 22
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "afc12498_b7b4af19",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 1310429
      },
      "writtenOn": "2021-07-01T19:46:33Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "55ffdcfb_15174be5",
      "range": {
        "startLine": 19,
        "startChar": 4,
        "endLine": 21,
        "endChar": 22
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f7dc3520_b8199bd3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1310429
      },
      "writtenOn": "2021-06-30T23:19:52Z",
      "side": 1,
      "message": "Hi Hiroki,\n\nI am trying to work on this change as we discussed over email. However, I am running into conflicts with ui.Node vs. uiauto.NodeInfo. I left a question, so let me know what you think.\n\nThanks!",
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "feb2e7ba_f644e886",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1355245
      },
      "writtenOn": "2021-07-01T03:28:10Z",
      "side": 1,
      "message": "Thanks for working on this!",
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c27d4d5_3839d1d4",
        "filename": "src/chromiumos/tast/local/chrome/uiauto/automation.go",
        "patchSetId": 4
      },
      "lineNbr": 188,
      "author": {
        "id": 1355245
      },
      "writtenOn": "2021-07-01T03:28:10Z",
      "side": 1,
      "message": "I think this part also needs to use the same template.",
      "range": {
        "startLine": 180,
        "startChar": 5,
        "endLine": 188,
        "endChar": 25
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a16cbb28_1a651568",
        "filename": "src/chromiumos/tast/local/chrome/uiauto/automation.go",
        "patchSetId": 4
      },
      "lineNbr": 188,
      "author": {
        "id": 1310429
      },
      "writtenOn": "2021-07-01T19:46:33Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5c27d4d5_3839d1d4",
      "range": {
        "startLine": 180,
        "startChar": 5,
        "endLine": 188,
        "endChar": 25
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9f38f8c_bc73e572",
        "filename": "src/chromiumos/tast/local/chrome/uiauto/automation.go",
        "patchSetId": 4
      },
      "lineNbr": 206,
      "author": {
        "id": 1355245
      },
      "writtenOn": "2021-07-01T03:28:10Z",
      "side": 1,
      "message": "This actually finds a node that matches to the finder from the desktop tree. And below is comparing the given NodeInfo and grabbed NodeInfo. Is this what we want to do here?\n\nIf so, can you update the comment? Also you can use reflect.DeepEqual to check the equality automatically and recursively.",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 206,
        "endChar": 38
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa35d211_0ef1f519",
        "filename": "src/chromiumos/tast/local/chrome/uiauto/automation.go",
        "patchSetId": 4
      },
      "lineNbr": 206,
      "author": {
        "id": 1310429
      },
      "writtenOn": "2021-07-01T19:46:33Z",
      "side": 1,
      "message": "Updated the comment. I also updated this function to iterate through all NodeInfos that match the finder, then compare using DeepEquals. Hopefully this approach is more accurate and cleaner.",
      "parentUuid": "b9f38f8c_bc73e572",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 206,
        "endChar": 38
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9db774fd_f3b915b5",
        "filename": "src/chromiumos/tast/local/chrome/uiauto/automation.go",
        "patchSetId": 4
      },
      "lineNbr": 206,
      "author": {
        "id": 1355245
      },
      "writtenOn": "2021-07-02T02:01:08Z",
      "side": 1,
      "message": "I still think the current one is confusing.\n\nIt says \"whether the NodeInfo matches the Finder\". But what the implementation does is a bit different. For example, even when given finder has no role, the found nodes can have some role that is different from the |actual| one, resulting that it returns false due to mismatch of the role.\n\nRandom alternative approaches I came up with are:\n- finder.bytes() generates the string representation of FindParams. Make the function public and use it from a11y. Or,\n- Instead of getting a Finder as a parameter, get a |NodeInfo| as a parameter, and run compare equality with go-cmp package (https://pkg.go.dev/github.com/google/go-cmp/cmp#Equal). It allows us to skip comparing empty value (see an example in the Options section in the doc)\n\nWhat do you think?",
      "parentUuid": "fa35d211_0ef1f519",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 206,
        "endChar": 38
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5a53d8d_5d59b9bc",
        "filename": "src/chromiumos/tast/local/chrome/uiauto/automation.go",
        "patchSetId": 4
      },
      "lineNbr": 206,
      "author": {
        "id": 1310429
      },
      "writtenOn": "2021-07-02T21:37:52Z",
      "side": 1,
      "message": "Hmm, maybe I should revise the comment or the function name to more accurately describe the behavior, but I still think the underlying implementation is accurate.\n\nWhat we want to do is to check if |finder| can be used to find |actual|. Another way of saying this is \"can |finder| be mapped to |actual|?\", or \"are the properties listed in |finder| present in |actual|?\".\n\nSince we cannot compare them directly, we find all possible NodeInfos that |finder| maps to. Then we compare each of the candidates to |actual|; one of the candidates should be deeply-equal to |actual| in the case that we return true.\n\nIn the case where |finder| has no role, it is possible for some of the candidates to have a different role than |actual|. However, if |finder| truly maps to |actual|, then one of the candidates will have a role that matches. Let\u0027s use the following example:\n\nactual :\u003d NodeInfo {\n    Name: \"This is a test\",\n    Role\" \"Button\",\n    ...\n}\n\nfinder :\u003d nodewith.Name(\"This is a test\")\n\n// Let\u0027s imagine that we get the following candidates\ncandidates :\u003d NodeInfo[]{\n    NodeInfo{Name: \"This is a test\", Role: \"Paragraph\", ...},\n    NodeInfo{Name: \"This is a test\", Role: \"Heading\", ...},\n    NodeInfo{Name: \"This is a test\", Role: \"Button\", ...}\n}\n\nIn the above example, we should return true because |finder| can be mapped to |actual| via the third candidate.\n\nAs a side note, we want to allow |finder| to be less specific than |actual|. For the above example, simply specifying the name should be enough for the function to return true. What we don\u0027t want is to require that |finder| have all properties of |actual|. We want to avoid the following:\n\nactual: NodeInfo {\n    Name: \"Test:,\n    Role\" \"Button\",\n    ...\n}\n\nfinder :\u003d nodewith.Name(\"Test\").Role(\"Button\").State(...).Checked(...)...\n\n|finder| should not have to list all properties for this function to return true; this function should return true if the properties listed in |finder| are also present in |actual|.\n\nDoes that all make sense? Sorry for the long description, but I just wanted to be as clear as possible. I updated the function name and comment for clarity, but I still think the implementation is correct.\n\nLet me know what you think.",
      "parentUuid": "9db774fd_f3b915b5",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 206,
        "endChar": 38
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d9befa3_587b9bee",
        "filename": "src/chromiumos/tast/local/chrome/uiauto/automation.go",
        "patchSetId": 4
      },
      "lineNbr": 206,
      "author": {
        "id": 1398801
      },
      "writtenOn": "2021-07-05T01:41:23Z",
      "side": 1,
      "message": "I think the original name \"Matches\" makes more sense to me. \n\nAs for matching, I still think that when looking for nodes, the finder should be more specific than less. Take the example you used: \n\nactual :\u003d NodeInfo {\n\n    Name: \"This is a test\",\n    Role\" \"Button\",\n    ...\n}\n\nThe finder should be finder :\u003d nodewith.Name(\"This is a test\").Role(role.Button). \nThe reason is that we should know what is expected. \nTherefore, I suggest to use Info instead of NodesInfo here.",
      "parentUuid": "a5a53d8d_5d59b9bc",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 206,
        "endChar": 38
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8fd30546_9f1c874f",
        "filename": "src/chromiumos/tast/local/chrome/uiauto/automation.go",
        "patchSetId": 4
      },
      "lineNbr": 206,
      "author": {
        "id": 1355245
      },
      "writtenOn": "2021-07-05T01:43:49Z",
      "side": 1,
      "message": "Thank you for the detailed explanation.\nI don\u0027t want to block you, but I still have a concern.\n\nLet\u0027s say that there\u0027s a UI tree like below:\n root\n - containerA\n   - button (checked)\n - containerB\n   - button (not checked)\n\nand, we have a NodeInfo of the first button. This NodeInfo matches a finder whose checked state is either ture or false, unless the finder explicitly specifies the parent node.\ni.e., a finder with a \"not checked\" attribute cannot be mapped to a nodeInfo of the first button, and this function returns true.\n\nThat is a very simplified example, but this false-positive is what I\u0027m wondering if appropriate.\n\nI understand it\u0027s okay under the current usage of this method. But putting this method under uiauto means that any ui test may use this method.",
      "parentUuid": "a5a53d8d_5d59b9bc",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 206,
        "endChar": 38
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98effabd_1589ed54",
        "filename": "src/chromiumos/tast/local/chrome/uiauto/automation.go",
        "patchSetId": 4
      },
      "lineNbr": 206,
      "author": {
        "id": 1355245
      },
      "writtenOn": "2021-07-05T02:02:33Z",
      "side": 1,
      "message": "Oh, I\u0027m sorry I\u0027ve noticed that I wrongly understood the implementation. Please ignore my comment above.\n\nIn my (not strong) opinion, as long as we want to \"allow |finder| to be less specific than |actual|\", I support using NodesInfo rather than Info. This is similar to the automationNode.find API.",
      "parentUuid": "8fd30546_9f1c874f",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 206,
        "endChar": 38
      },
      "revId": "c0e4703a45bf467f810c5b65bfd77213222a8419",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}