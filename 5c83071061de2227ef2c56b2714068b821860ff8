{
  "comments": [
    {
      "key": {
        "uuid": "5f8f8a65_8aef3da1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1371981
      },
      "writtenOn": "2020-07-24T08:29:37Z",
      "side": 1,
      "message": "The change mentioned in crrev.com/c/2278537. Some design requests for comment.",
      "revId": "5c83071061de2227ef2c56b2714068b821860ff8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8deaaadb_d6ff30c9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1371981
      },
      "writtenOn": "2020-07-24T08:32:01Z",
      "side": 1,
      "message": "One more note: it might be better to separate the curServicePath part and Disconnect+DeleteProfile part, but I think the behavior/design is related so let\u0027s have them in a single CL for now.",
      "revId": "5c83071061de2227ef2c56b2714068b821860ff8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aa725666_289e30a5",
        "filename": "src/chromiumos/tast/remote/wificell/test_fixture.go",
        "patchSetId": 1
      },
      "lineNbr": 422,
      "author": {
        "id": 1371981
      },
      "writtenOn": "2020-07-24T08:29:37Z",
      "side": 1,
      "message": "I think the concept of Disconnect is not for disconnecting from a specific AP but from current connection so it might not be reasonable to pass SSID in. (which is easier to use for roaming tests, I guess)\n\nHowever, this brings a problem to the API that if somehow the connection is lost or disconnect fails for some reason, the profile might not be removed. In the case, we can still depend on the Reinit/Close of TestFixture but less explicit.\n\nOne alternative is introducing a new set of functions like CleanDisconnectFromSSID(ctx, ssid) which will disconnect from the service with the given SSID and Disconnect call would fail if the specific service is not selected.\n\nWDYT?",
      "revId": "5c83071061de2227ef2c56b2714068b821860ff8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "217633be_fb95e7e7",
        "filename": "src/chromiumos/tast/remote/wificell/test_fixture.go",
        "patchSetId": 1
      },
      "lineNbr": 422,
      "author": {
        "id": 1373754
      },
      "writtenOn": "2020-07-25T00:27:41Z",
      "side": 1,
      "message": "Maybe we can make Disconnect() return the SSID\u0026BSSID of the currentService it was connected too. This way we can check if it disconnected from the expected connection.\n\nAlso, I think CleanDisconnectFromSSID(ctx, ssid) is a good idea. However, it would fail if the DUT roamed to another ssid due to a scan.",
      "parentUuid": "aa725666_289e30a5",
      "revId": "5c83071061de2227ef2c56b2714068b821860ff8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e4f30b7_0f64fa64",
        "filename": "src/chromiumos/tast/remote/wificell/test_fixture.go",
        "patchSetId": 1
      },
      "lineNbr": 422,
      "author": {
        "id": 1001853
      },
      "writtenOn": "2020-07-27T02:49:08Z",
      "side": 1,
      "message": "In my mind, we shall have an inverse method of tf.ConnectWifiAP(), which disconnect the current service and remove it. Of course we shall check if the current service to disconnect has the expected SSID and other property specified in the APIface object.\n\nFor roaming case, as the SSID is the same, so ClearDisconnectFromSSID() should be fine. The scene that the active service\u0027s SSID is different to what tf.Connect() specified could be the original service is disconnected for some reason and shill picks another connectable service to use.\n\nFor disconnect methods, I would suggest:\n\n// DisconnectWifi asks the DUT to disconnect from current WiFi service.\n// It returns the service path it is disconnected.\nfunc (tf *TestFixture) DisconnectWifi(ctx context.Context) (string, error)\n\n// DisconnectWifiService asks the DUT to disconnect from specified WiFi service and remove it.\n// It is the inverse method of tf.Connect().\nfunc (tf *TestFixture) DisconnectWifiService(ctx context.Context, servicePath string) error\n\nWith the method, tf.ConnectWifiAP and its cleanup method can be:\n\n\tif connResp, err :\u003d tf.ConnectWifiAP(ctx, ap); err !\u003d nil {\n\t\ts.Fatal(\"Failed to connect to WiFi: \", err)\n\t}\n\tdefer func(ctx context.Context) {\n\t\tif err :\u003d tf.DisconnectWifiService(ctx, connResp.ServicePath); err !\u003d nil {\n\t\t\ts.Error(\"Failed to disconnect WiFi: \", err)\n\t\t}\n\t}(ctx)",
      "parentUuid": "217633be_fb95e7e7",
      "revId": "5c83071061de2227ef2c56b2714068b821860ff8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17bb3d17_7e617e71",
        "filename": "src/chromiumos/tast/remote/wificell/test_fixture.go",
        "patchSetId": 1
      },
      "lineNbr": 422,
      "author": {
        "id": 1371981
      },
      "writtenOn": "2020-07-27T10:44:53Z",
      "side": 1,
      "message": "I have this pattern applied in the latest patch set and keep both CleanDisconnect and Disconnect so that DisconnectWifi and DisconnectWifiService will not have different behavior on cleaning profile.\n\nIt is kind of too verbose to me that every tests should catch the response of Connect and send it into Disconnect. WDYT?\n\nAlso, we don\u0027t yet have any caller of DisconnectWifi() so I\u0027m not sure if it will be useful to return the servicePath gets disconnected. I\u0027ll take a look and maybe rebase onto the Roam* tests.",
      "parentUuid": "5e4f30b7_0f64fa64",
      "revId": "5c83071061de2227ef2c56b2714068b821860ff8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "61e956e0_63933111",
        "filename": "src/chromiumos/tast/remote/wificell/test_fixture.go",
        "patchSetId": 1
      },
      "lineNbr": 422,
      "author": {
        "id": 1001853
      },
      "writtenOn": "2020-07-28T03:03:55Z",
      "side": 1,
      "message": "So you mean for now we don\u0027t have a use case that just disconnect a service without removing it from shill, right?\n\nIf so, we can just rename DisconnectWifiService as DisconnectWifi. My point is, as long as tf.ConnectWifi creates a shill service entry and connects it, we shall have an inverse function, like tf.DisconnectWifi, to revert what tf.ConnectWifi does.\n\nAbout the verbose return value of tf.ConnectWifi, if most of the case the DUT has only one service added and it is unlikely to disconnect from an unexpected service, we can make tf.DisconnectWifi easier. Then for special case that needs to specify the service path, use the verbose version, say tf.DisconnectWifiService.",
      "parentUuid": "17bb3d17_7e617e71",
      "revId": "5c83071061de2227ef2c56b2714068b821860ff8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "55a72ec3_c8ece7e0",
        "filename": "src/chromiumos/tast/remote/wificell/test_fixture.go",
        "patchSetId": 1
      },
      "lineNbr": 422,
      "author": {
        "id": 1371981
      },
      "writtenOn": "2020-07-28T03:27:46Z",
      "side": 1,
      "message": "\u003e So you mean for now we don\u0027t have a use case that just disconnect a service without removing it from shill, right?\n\nNo, I mean we don\u0027t yet have tests to roam from one service to another (which does not really know which service to disconnect when leaving and need [Clean]DisconnectWifi to get current service instead of [Clean]DisconnectWifiService).\n\nI think wifi.SecChange needs to disconnect without removing the profile entry so it will be a caller of DisconnectWifi[Service] (instead of CleanDisconnectWifi[Service]).\n\n\u003e Then for special case that needs to specify the service path, use the verbose version, say tf.DisconnectWifiService.\n\nHmm..., if so, then most usage will be [Clean]DisconnectWifi then I\u0027m thinking if the rest can just call the gRPC directly in the special cases. Let me try this in next PS.",
      "parentUuid": "61e956e0_63933111",
      "revId": "5c83071061de2227ef2c56b2714068b821860ff8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}