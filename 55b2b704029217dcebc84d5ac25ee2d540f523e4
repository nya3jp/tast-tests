{
  "comments": [
    {
      "key": {
        "uuid": "25871477_e36b0071",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 132,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-06-21T09:54:27Z",
      "side": 1,
      "message": "After returning from this method, some data may remained in buffer, which is already discarded from stdout. Is it expected that the stdout wouldn\u0027t be read after this?\nIf so, could you explicitly document it?",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12ad7641_b26fad0c",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 132,
      "author": {
        "id": 1304442
      },
      "writtenOn": "2019-06-25T22:51:38Z",
      "side": 1,
      "message": "Yes good catch. I will add that to the function documentation.",
      "parentUuid": "25871477_e36b0071",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bb56da24_15afc367",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 132,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-06-26T17:25:59Z",
      "side": 1,
      "message": "After reading the use cases carefully, I found that it is necessary not to discard stdout data in the buffer. Could you fix the implementation instead of the documentation. (Also, nice to document that stdout can be reusable after returning from this method.\n\nProbably, you cannot use buffering, IIUC.",
      "parentUuid": "12ad7641_b26fad0c",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "597b700d_eb35b29a",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 132,
      "author": {
        "id": 1304442
      },
      "writtenOn": "2019-06-28T22:11:36Z",
      "side": 1,
      "message": "Sounds good, I changed the implementation to read directly from stdout one byte at a time.",
      "parentUuid": "bb56da24_15afc367",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "97a54080_70290781",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 138,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-06-21T09:54:27Z",
      "side": 1,
      "message": "Is this be blocking operation? If so, ctx timeout wouldn\u0027t work.",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "325c5fc6_4c973e99",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 138,
      "author": {
        "id": 1304442
      },
      "writtenOn": "2019-06-25T22:51:38Z",
      "side": 1,
      "message": "It is a blocking operation. After some testing it looks like the blocking ReadByte call returns only when the crosvm object is closed. It looks like the bufio.Reader does not have a way to interrupt the reading. Do you have any ideas how we could rework this so the timeout is respected?",
      "parentUuid": "97a54080_70290781",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c8263d1_83d48688",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 138,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-06-26T17:25:59Z",
      "side": 1,
      "message": "There looks no way to set timeout to io.Reader interface.\nSo, my recommendation is;\n- to handle timeout outside of go.\n- In case of failure, it is expected that Crosvm is closed.\n- The close event should be propagated to read, which unblocks Read invocation, so that goroutine can be terminated.\n\nWDYT?",
      "parentUuid": "325c5fc6_4c973e99",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57c6cf0a_9fe79679",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 138,
      "author": {
        "id": 1002983
      },
      "writtenOn": "2019-06-27T06:00:01Z",
      "side": 1,
      "message": "Could we use a goroutine here?  Something like:\n\n    bch :\u003d make(chan byte)\n    go func() {\n        b, err :\u003d r.ReadByte()\n        if err !\u003d nil {\n            errch \u003c- err\n        } else {\n            bch \u003c- b\n        }\n    }()\n\n    select {\n    case \u003c-ctx.Done(): \n        return\n    case b :\u003d \u003c-bch: \n        if b \u003d\u003d \u0027\\n\u0027 {\n        ...\n\n\nIt seems like any problem in go can be solved by adding an extra layer of indirection through goroutines ;-p",
      "parentUuid": "0c8263d1_83d48688",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba5a708f_6bc43240",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 138,
      "author": {
        "id": 1304442
      },
      "writtenOn": "2019-06-28T22:11:36Z",
      "side": 1,
      "message": "@Chirantan, I think unfortunately that would just cause the nested goroutine to leak instead. The ReadByte call will block until the underlying reader (vm.stdout) is destroyed.",
      "parentUuid": "57c6cf0a_9fe79679",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ee5884f_9fbe5082",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 138,
      "author": {
        "id": 1002983
      },
      "writtenOn": "2019-07-01T05:29:40Z",
      "side": 1,
      "message": "I\u0027m not sure I follow.  Won\u0027t the goroutine get cleaned up when vm.stdout is destroyed?  In that case it\u0027s not really a leak.  Or is the issue that the extra goroutine will prevent vm.stdout from being destroyed?  Could we add an explicit close on bch and on vm.stdout?",
      "parentUuid": "ba5a708f_6bc43240",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3471ac1f_fb988354",
        "filename": "src/chromiumos/tast/local/vm/crosvm.go",
        "patchSetId": 4
      },
      "lineNbr": 138,
      "author": {
        "id": 1304442
      },
      "writtenOn": "2019-07-01T14:56:15Z",
      "side": 1,
      "message": "The goroutine will be cleaned up when vm.stdout is destroyed. However the WaitForOutput call cannot be used again in the same test. Closing vm.stout after the function exits will have the same problem.",
      "parentUuid": "4ee5884f_9fbe5082",
      "revId": "55b2b704029217dcebc84d5ac25ee2d540f523e4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}