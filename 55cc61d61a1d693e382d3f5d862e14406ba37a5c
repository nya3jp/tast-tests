{
  "comments": [
    {
      "key": {
        "uuid": "f6ebc35c_3df8bd4d",
        "filename": "src/chromiumos/tast/common/perf/timeline.go",
        "patchSetId": 3
      },
      "lineNbr": 203,
      "author": {
        "id": 1375928
      },
      "writtenOn": "2020-05-14T02:27:29Z",
      "side": 1,
      "message": "I don\u0027t really want to have this function here. If it is used incorrectly (e.g., called from another goroutine as StopRecording), then there could be a nullpointer exception. But I need it for the unit tests of Timeline. In those tests, I am waiting for certain conditions, e.g., for the goroutine to go to sleep or for a snapshot to be taken. If an error occurs during taking a snapshot, the goroutine stops and we would be waiting forever. So there must be a way to check if we are still recording.",
      "range": {
        "startLine": 203,
        "startChar": 0,
        "endLine": 203,
        "endChar": 88
      },
      "revId": "55cc61d61a1d693e382d3f5d862e14406ba37a5c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "39bb7044_70c1f217",
        "filename": "src/chromiumos/tast/common/perf/timeline.go",
        "patchSetId": 3
      },
      "lineNbr": 203,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-14T03:18:48Z",
      "side": 1,
      "message": "As for WaitForSleep, I think it is sufficient to just wait for fakeClock.isSleeping \u003d true.\n\nAs for WaitForSnapshots, we can modify testTimelineDatasource.Snapshot to send a value over a channel. Then waiting for Snapshot to be called N times equals to reading N values from the channel.",
      "parentUuid": "f6ebc35c_3df8bd4d",
      "range": {
        "startLine": 203,
        "startChar": 0,
        "endLine": 203,
        "endChar": 88
      },
      "revId": "55cc61d61a1d693e382d3f5d862e14406ba37a5c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5df1e4ab_f6246b8e",
        "filename": "src/chromiumos/tast/common/perf/timeline.go",
        "patchSetId": 3
      },
      "lineNbr": 211,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-14T03:18:48Z",
      "side": 1,
      "message": "Optional: In general we can\u0027t peek a value from a channel. If we want to do that, in many cases, we might want to use a channel just to broadcast the end event of the goroutine, and set the error to a separate field.\n\n type Timeline struct {\n   ...\n   done chan struct{} // closed when the background goroutine finishes\n   err error\n }\n\n func (t *Timeline) StartRecording(ctx context.Context) error {\n   ...\n   go func() {\n     defer close(t.done)\n     t.err \u003d func() error {\n       for {\n         ...\n       }\n     }()\n   }()\n   ...\n }\n \n func (t *Timeline) RecordingStatus() error {\n   select {\n   case \u003c-t.done:\n     return t.err\n   default:\n     return errors.New(\"not finished yet\")\n   }\n }",
      "range": {
        "startLine": 210,
        "startChar": 3,
        "endLine": 211,
        "endChar": 26
      },
      "revId": "55cc61d61a1d693e382d3f5d862e14406ba37a5c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1af45d75_d627f52d",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-14T03:18:48Z",
      "side": 1,
      "message": "I think there should be only one goroutine which advances the clock. Otherwise it is difficult to reason about how the clock is changed.\n\nSee also my comment about RecordingStatus.",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 50,
        "endChar": 2
      },
      "revId": "55cc61d61a1d693e382d3f5d862e14406ba37a5c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8f3662e7_ef6c5011",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 3
      },
      "lineNbr": 75,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-14T03:18:48Z",
      "side": 1,
      "message": "Is it a data race to access these fields from multiple goroutines without a lock.\n\nUse a mutex to protect these fields.\nhttps://godoc.org/sync#Mutex",
      "range": {
        "startLine": 74,
        "startChar": 0,
        "endLine": 75,
        "endChar": 16
      },
      "revId": "55cc61d61a1d693e382d3f5d862e14406ba37a5c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ce99f92_2258b07c",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 3
      },
      "lineNbr": 82,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-14T03:18:48Z",
      "side": 1,
      "message": "This method will behave in an unexpected way if it is called from multiple goroutines concurrently because isSleeping is shared among them.\n\nCould you check that isSleeping \u003d false at the beginning of this function for more safety?",
      "range": {
        "startLine": 82,
        "startChar": 20,
        "endLine": 82,
        "endChar": 25
      },
      "revId": "55cc61d61a1d693e382d3f5d862e14406ba37a5c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "177f9917_1691b00a",
        "filename": "src/chromiumos/tast/common/perf/timeline_test.go",
        "patchSetId": 3
      },
      "lineNbr": 85,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2020-05-14T03:18:48Z",
      "side": 1,
      "message": "We should avoid polling for a condition when we can detect events. Please try to remove all use of testing.Poll from these unit tests.\n\nIn this case we want to notify the goroutine blocked in Sleep for clock change. There are at least two common ways to do this: channels and sync.Cond. In this case we also have to wait for ctx cancellation, so channels are the only choice.\n\nThis is an example notifying value changes. Note that channels are very cheap in Go.\n\n type Counter struct {\n   mu  sync.Mutex\n   ch  chan struct{} // closed when cnt is changed\n   cnt int\n }\n\n func NewCounter() *Counter {\n   return \u0026Counter{ch: make(chan struct{}))\n }\n\n // Add adds d to the counter.\n func (c *Counter) Add(d int) {\n   c.mu.Lock()\n   defer c.mu.Unlock()\n   c.cnt +\u003d d\n   close(c.ch)\n   c.ch \u003d make(chan struct{})\n }\n\n // Wait waits until the counter value becomes want.\n func (c *Counter) Wait(ctx context.Context, want int) error {\n   for {\n     c.mu.Lock()\n     got :\u003d c.cnt\n     ch :\u003d c.ch\n     c.mu.Unlock()\n\n     if got \u003d\u003d want {\n       return nil\n     }\n\n     select {\n     case \u003c-ctx.Done():\n       return ctx.Err()\n     case \u003c-ch:\n     }\n   }\n }",
      "range": {
        "startLine": 85,
        "startChar": 8,
        "endLine": 85,
        "endChar": 24
      },
      "revId": "55cc61d61a1d693e382d3f5d862e14406ba37a5c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}