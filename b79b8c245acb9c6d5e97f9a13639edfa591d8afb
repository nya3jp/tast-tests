{
  "comments": [
    {
      "key": {
        "uuid": "7c1db8bc_9f1aebc4",
        "filename": "src/chromiumos/tast/local/bundles/cros/security/selinux_audit_sanity.go",
        "patchSetId": 4
      },
      "lineNbr": 31,
      "author": {
        "id": 1000042
      },
      "writtenOn": "2019-05-20T20:48:14Z",
      "side": 1,
      "message": "instead of this comment, please add a log message so it\u0027s clear what the test is doing, e.g.\n\n  s.Log(\"Waiting for auditd job to be running\")",
      "revId": "b79b8c245acb9c6d5e97f9a13639edfa591d8afb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "07b64582_b4d61fe0",
        "filename": "src/chromiumos/tast/local/bundles/cros/security/selinux_audit_sanity.go",
        "patchSetId": 4
      },
      "lineNbr": 46,
      "author": {
        "id": 1000042
      },
      "writtenOn": "2019-05-20T20:48:14Z",
      "side": 1,
      "message": "instead of all of this, can you just use ioutil.TempDir?\n\nplease also defer a delete statement so you don\u0027t leave stale files on the DUT.",
      "revId": "b79b8c245acb9c6d5e97f9a13639edfa591d8afb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "61c6b9ea_75760cc5",
        "filename": "src/chromiumos/tast/local/bundles/cros/security/selinux_audit_sanity.go",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1000042
      },
      "writtenOn": "2019-05-20T20:48:14Z",
      "side": 1,
      "message": "nit: please move this down below the error check\n\nalso, so you don\u0027t need to load all of this into memory, how about making the command write to a pipe and using bufio.Scanner? then you probably also don\u0027t need a regexp, as i assume you can just use strings.Contains instead.",
      "revId": "b79b8c245acb9c6d5e97f9a13639edfa591d8afb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d61ed97a_b8570d65",
        "filename": "src/chromiumos/tast/local/bundles/cros/security/selinux_audit_sanity.go",
        "patchSetId": 4
      },
      "lineNbr": 55,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2019-05-21T04:15:04Z",
      "side": 1,
      "message": "Also, can we just use strings.Contains(string(content), fileName) instead of regexp?",
      "range": {
        "startLine": 55,
        "startChar": 44,
        "endLine": 55,
        "endChar": 52
      },
      "revId": "b79b8c245acb9c6d5e97f9a13639edfa591d8afb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a4872a9_cb389dd3",
        "filename": "src/chromiumos/tast/local/bundles/cros/security/selinux_audit_sanity.go",
        "patchSetId": 4
      },
      "lineNbr": 60,
      "author": {
        "id": 1000042
      },
      "writtenOn": "2019-05-20T20:48:14Z",
      "side": 1,
      "message": "this could result in an extremely long error message. with the above scanning suggestion, i think it should be easy to just include the offending line here.",
      "revId": "b79b8c245acb9c6d5e97f9a13639edfa591d8afb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97e2967a_a7874eca",
        "filename": "src/chromiumos/tast/local/bundles/cros/security/selinux_audit_sanity.go",
        "patchSetId": 4
      },
      "lineNbr": 63,
      "author": {
        "id": 1000042
      },
      "writtenOn": "2019-05-20T20:48:14Z",
      "side": 1,
      "message": "it doesn\u0027t look like you\u0027re using this variable.\n\ninstead of shelling out to grep, how about just adding a helper function that iterates over an io.Reader using bufio.NewScanner as suggested above? then you can you that both to check the pipe connected to the journalctl command above and to check this file (after using os.Open). e.g.\n\n  // Returns an empty string if the line was not found.\n  findFirstMatchedLine :\u003d func(r io.Reader, re *regexp.Regexp) (string, error) {\n      ...",
      "range": {
        "startLine": 63,
        "startChar": 1,
        "endLine": 63,
        "endChar": 8
      },
      "revId": "b79b8c245acb9c6d5e97f9a13639edfa591d8afb",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}