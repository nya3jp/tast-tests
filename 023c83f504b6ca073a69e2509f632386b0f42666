{
  "comments": [
    {
      "key": {
        "uuid": "d3f9862b_47c3e5bc",
        "filename": "src/chromiumos/tast/local/bundles/cros/security/user_files_guest.go",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1344767
      },
      "writtenOn": "2020-03-26T00:10:18Z",
      "side": 1,
      "message": "Is this needed? Can\u0027t we directly setns() to chromeNsFd?",
      "range": {
        "startLine": 85,
        "startChar": 16,
        "endLine": 85,
        "endChar": 23
      },
      "revId": "023c83f504b6ca073a69e2509f632386b0f42666",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "68a7af92_ef9b484e",
        "filename": "src/chromiumos/tast/local/bundles/cros/security/user_files_guest.go",
        "patchSetId": 5
      },
      "lineNbr": 85,
      "author": {
        "id": 1000985
      },
      "writtenOn": "2020-03-26T00:18:31Z",
      "side": 1,
      "message": "Unfortunately this doesn\u0027t work in multithreaded programs.\n\nThe man page says \"A process may not be reassociated with a new mount namespace if it is multithreaded.\"\n\nThis comes from a check in the kernel:\n\nstatic int mntns_install(struct nsproxy *nsproxy, struct ns_common *ns)\n{\n\tstruct fs_struct *fs \u003d current-\u003efs;\n\tstruct mnt_namespace *mnt_ns \u003d to_mnt_ns(ns), *old_mnt_ns;\n\tstruct path root;\n\tint err;\n\n\tif (!ns_capable(mnt_ns-\u003euser_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(current_user_ns(), CAP_SYS_CHROOT) ||\n\t    !ns_capable(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (is_anon_ns(mnt_ns))\n\t\treturn -EINVAL;\n\n\tif (fs-\u003eusers !\u003d 1) \u003c----- THIS CHECK\n\t\treturn -EINVAL;\n\n\tget_mnt_ns(mnt_ns);\n\told_mnt_ns \u003d nsproxy-\u003emnt_ns;\n\tnsproxy-\u003emnt_ns \u003d mnt_ns;\n\n\t/* Find the root */\n\terr \u003d vfs_path_lookup(mnt_ns-\u003eroot-\u003emnt.mnt_root, \u0026mnt_ns-\u003eroot-\u003emnt,\n\t\t\t\t\"/\", LOOKUP_DOWN, \u0026root);\n\tif (err) {\n\t\t/* revert to old namespace */\n\t\tnsproxy-\u003emnt_ns \u003d old_mnt_ns;\n\t\tput_mnt_ns(mnt_ns);\n\t\treturn err;\n\t}\n\n\tput_mnt_ns(old_mnt_ns);\n\n\t/* Update the pwd and root */\n\tset_fs_pwd(fs, \u0026root);\n\tset_fs_root(fs, \u0026root);\n\n\tpath_put(\u0026root);\n\treturn 0;\n}\n\nIf |fs-\u003eusers| \u003e 1, which is the case for a multithreaded program, setns will fail.\n\nThe way to fix it is to unshare() first, which will make fs-\u003eusers for that specific thread \u003d\u003d 1, and then setns works.\n\nEssentially, you first have to \"detach\" the thread\u0027s view of the mounts from the other threads, and then the thread can change its own view of the mounts.",
      "parentUuid": "d3f9862b_47c3e5bc",
      "range": {
        "startLine": 85,
        "startChar": 16,
        "endLine": 85,
        "endChar": 23
      },
      "revId": "023c83f504b6ca073a69e2509f632386b0f42666",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}