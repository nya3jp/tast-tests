{
  "comments": [
    {
      "key": {
        "uuid": "11a9957e_a03ba7c4",
        "filename": "src/chromiumos/tast/local/bundles/cros/ui/chrome_crash_reporter_miss_metrics.go",
        "patchSetId": 4
      },
      "lineNbr": 99,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2019-12-10T16:42:58Z",
      "side": 1,
      "message": "nit: this seems to be an \"and\" instead of \"or\", correct?",
      "range": {
        "startLine": 99,
        "startChar": 35,
        "endLine": 99,
        "endChar": 71
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86b43e5d_d180576f",
        "filename": "src/chromiumos/tast/local/bundles/cros/ui/chrome_crash_reporter_miss_metrics.go",
        "patchSetId": 4
      },
      "lineNbr": 99,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2019-12-10T16:42:58Z",
      "side": 1,
      "message": "nit, style (here and below):\nerror strings should not be capitalized\nhttps://github.com/golang/go/wiki/CodeReviewComments#error-strings",
      "range": {
        "startLine": 99,
        "startChar": 22,
        "endLine": 99,
        "endChar": 23
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94dd6709_51c0abcb",
        "filename": "src/chromiumos/tast/local/bundles/cros/ui/chrome_crash_reporter_miss_metrics.go",
        "patchSetId": 4
      },
      "lineNbr": 99,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-10T19:29:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "86b43e5d_d180576f",
      "range": {
        "startLine": 99,
        "startChar": 22,
        "endLine": 99,
        "endChar": 23
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "782e0189_b2aa3c0b",
        "filename": "src/chromiumos/tast/local/bundles/cros/ui/chrome_crash_reporter_miss_metrics.go",
        "patchSetId": 4
      },
      "lineNbr": 99,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-10T19:29:07Z",
      "side": 1,
      "message": "I would read it like De Morgan\u0027s law: \"Did not find either A or B\" is the same as \"Did not find A and did not find B\".",
      "parentUuid": "11a9957e_a03ba7c4",
      "range": {
        "startLine": 99,
        "startChar": 35,
        "endLine": 99,
        "endChar": 71
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e6556c98_c650b350",
        "filename": "src/chromiumos/tast/local/bundles/cros/ui/chrome_crash_reporter_success_metrics.go",
        "patchSetId": 4
      },
      "lineNbr": 31,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2019-12-10T16:42:58Z",
      "side": 1,
      "message": "this test seems to be somewhat similar to ChromeCrashReporterMissMetrics.\nthey share many common parts: setup crash test, upstart.StopJob, metris.ClearHistogram, start Chrome (although with different arguments), RestartAnomalyDetector, etc...\n\nperhaps it could be possible to merge the two files in just one file and use parameterized tests. WDYT?\n\nhttps://chromium.googlesource.com/chromiumos/platform/tast/+/HEAD/docs/writing_tests.md#Parameterized-tests",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 31,
        "endChar": 1
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05777c2a_a0f26d9d",
        "filename": "src/chromiumos/tast/local/bundles/cros/ui/chrome_crash_reporter_success_metrics.go",
        "patchSetId": 4
      },
      "lineNbr": 31,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-10T19:29:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e6556c98_c650b350",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 31,
        "endChar": 1
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f6ad607_791cb7c2",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 27,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2019-12-10T16:42:58Z",
      "side": 1,
      "message": "nit style: PID instead of Pid (https://github.com/golang/go/wiki/CodeReviewComments#initialisms)",
      "range": {
        "startLine": 27,
        "startChar": 23,
        "endLine": 27,
        "endChar": 26
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cac0e2f2_c185fd1f",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 27,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-10T19:29:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8f6ad607_791cb7c2",
      "range": {
        "startLine": 27,
        "startChar": 23,
        "endLine": 27,
        "endChar": 26
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1163bfc0_07400e9c",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 72,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2019-12-10T16:42:58Z",
      "side": 1,
      "message": "nit, style:\nshould be PID instead of Pid. See:\nhttps://github.com/golang/go/wiki/CodeReviewComments#initialisms",
      "range": {
        "startLine": 72,
        "startChar": 25,
        "endLine": 72,
        "endChar": 28
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "496988b5_c4382f81",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 72,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-10T19:29:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1163bfc0_07400e9c",
      "range": {
        "startLine": 72,
        "startChar": 25,
        "endLine": 72,
        "endChar": 28
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "097044ac_32090116",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 73,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2019-12-10T16:42:58Z",
      "side": 1,
      "message": "nit: I\u0027d use \"strconv.ItoA\" since it is more explicit:\nhttps://golang.org/pkg/strconv/#Itoa",
      "range": {
        "startLine": 73,
        "startChar": 14,
        "endLine": 73,
        "endChar": 36
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad8090b5_c271c684",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 73,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-10T19:29:07Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "097044ac_32090116",
      "range": {
        "startLine": 73,
        "startChar": 14,
        "endLine": 73,
        "endChar": 36
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9518f949_0817cb1b",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2019-12-10T16:42:58Z",
      "side": 1,
      "message": "looks like bytesRead is only used inside checkNextDmpKeyForPid to report a better error message.\nAlso, it seems that checkNextDmpKeyForPid is only called from here. And checkNextDmpKeyForPid returns EOF, found and error.\n\nSo, I\u0027d try to refactor the function a bit different and just make it simpler.\nFor example, I would just create a function called findPIDinDmp (or something like that), that returns \"nil\" if PID is found. Otherwise it returns an error.\n\nWDYT?",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 15
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "908c5ae7_496424b2",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-10T19:29:07Z",
      "side": 1,
      "message": "That would just be combining the two functions, right? All that would be left here would be a file open, and it hardly seems worth having a separate function just to open a file and pass that to the next function.\n\nI\u0027m a little worried that, if combined, you get a long, complex function with 5+ levels of nesting in places. That\u0027s usually not very readable.",
      "parentUuid": "9518f949_0817cb1b",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 15
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "42f55e33_c7b6b284",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2019-12-11T19:11:30Z",
      "side": 1,
      "message": "my comment was more about having a cleaner \"find pid in dmp\" function. It could be just inside the caller or a new function. Either way I don\u0027t think it will have 5+ levels of indentation. but up to you whether you want to join it or have it as a free function.\n\nfor me is not clear, for example, why you need to return found, EOF and error. Can\u0027t you just return \"error\" if the PID is not found?\n\nWDYT?",
      "parentUuid": "908c5ae7_496424b2",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 15
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "971631a6_2645d189",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-11T21:54:32Z",
      "side": 1,
      "message": "There\u0027s four different actions, though. \n\nIf found, return true, no error from this function immediately\nIf eof, return false, no error from this function immediately\nIf error, return the error\nIf none of the above, keep looking through the file, because the next key/value pair might have the PID.\n\nIf you think it\u0027s cleaner, I\u0027ll return io.EOF as the error for the EOF case and branch on \"is err equal to io.EOF\".",
      "parentUuid": "42f55e33_c7b6b284",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 15
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ce7de055_494d7c27",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2019-12-12T00:58:59Z",
      "side": 1,
      "message": "sorry, perhaps I\u0027m missing something.\nIIUC checkNextDmpKeyForPID tries to find a pidValue. Is that correct?\n\nIf so, can the function just return \"nil\" if it finds the pidValue, and an error otherwise?\nIt is not clear of why \"bytesRead\" is being passed, and why it is returning so many values.\n\n(again, sorry if I missed something... we can discuss it via chat tomorrow if you prefer)",
      "parentUuid": "971631a6_2645d189",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 15
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b95401f0_060a7864",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-12T19:13:34Z",
      "side": 1,
      "message": "So, let me try this:\n\nThe dump file consists of a series of key:length:value triplets, in a format such that the only way to parse later key:length:values is to start at the beginning and parse each triplet. I want a function that scans the entire file for a particular key/value pair. \n\nTo me, the obvious way to divide up the work is to have a subfunction which parses a single key:length:value triplet, and then a master function which opens the file and calls the subfunction in a loop.\n\nNow, the subfunction could just return the key/value pair. I\u0027m avoiding that because it involves reading the entire value, which can be 100s of kilobytes long. If I don\u0027t want the value, I\u0027d rather just file.Discard() the unwanted value to save time and memory. I know what I\u0027m looking for, so I\u0027d rather just have the subfunction look for the correct key/value pair and return \"yes I found it\" or \"no, I didn\u0027t\".\n\nThe subfunction can thus return 4 values:\n* I found it, we\u0027re done\n* I parsed a key/value pair, but it wasn\u0027t the one we are looking for, so we need to keep going.\n* We reached the end of the file, stop looking\n* There was an error\n\nHaving 3 non-error results usually requires 2 booleans, which is why I was originally returning 2 booleans. I changed it to overload the error to cover one of the cases (EOF) because you didn\u0027t like the 2 booleans. Personally, I don\u0027t like overloading error returns to cover non-error cases, but it kinda matches what io.EOF means, so fine. But in any case, I need to cover those 4 cases somehow. A single error return does not distinguish case 1 and 2. \n\nAs for bytesRead, the error messages are pretty useless without the byte offset. I originally have error messages without an offset, and they would just say things like \"Could not parse \u0027\u003cbunch of unprintable junk\u003e\u0027 as integer\" for the length parse. Most of a dump file is binary memory dumps. Worse, most of a dump file is *very repetitive* binary stuff -- since it\u0027s a program\u0027s stack, many byte sequences repeat over and over (the first part of the return addresses are often identical, and certain pointers may be passed from function to function). This makes it almost impossible to figure out what went wrong, or even where the parser was in the file. After spending over an hour with hexdump trying to figure out how the parser had gotten into an invalid state, I added the current offset to the error messages so that they were useful. Unfortunately, bufio.Reader doesn\u0027t have an equivalent to ftell(), so I have no way of getting the current offset other than tracking it myself, and the only function that knows how many bytes we read during a given key/value read is checkNextDmpKeyForPID. So I gotta pass bytesRead in and out.",
      "parentUuid": "ce7de055_494d7c27",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 15
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5bf3fea5_ce491197",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-12T20:09:25Z",
      "side": 1,
      "message": "One more thought -- if you want to do a compare-and-contrast, the other piece of code in ChromeOS that parses breakpad .dmp files is ChromeCollector::ParseCrashLog. It\u0027s a little different, in that it\u0027s already read in the entire .dmp file into a string, and in that it needs to process every key/value pair instead of discarding most of them like I do. But it\u0027s a possible point of comparison.",
      "parentUuid": "b95401f0_060a7864",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 15
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62a5a413_291fa714",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 1202079
      },
      "writtenOn": "2019-12-12T23:13:22Z",
      "side": 1,
      "message": "Thanks for the detailed info, and sorry for this back\u0026forth. I have better idea of what you are doing.\nSo, one additional comment. What about then having a function that just returns the \"Key,Value\" from the DMP file and you compare if the key\u003d\u003dpid and value\u003d\u003dpidString.\nI think it is slightly easier to read and maintain.\n\n\ne.g:\n\nfunc readNextDmpKeyValue(file *bufio.Reader, pidValue string, bytesRead *int) (key, value string, err error) {\n\tkey, err \u003d file.ReadString(\u0027:\u0027)\n\tif err \u003d\u003d io.EOF \u0026\u0026 len(key) \u003d\u003d 0 {\n\t\treturn \"\", \"\", io.EOF\n\t} else if err \u003d\u003d io.EOF {\n\t\treturn \"\", \"\", errors.Errorf(\"unexpected EOF while reading key at %d\", *bytesRead)\n\t} else if err !\u003d nil {\n\t\treturn \"\", \"\", errors.Wrapf(err, \"could not read key from dmp file at %d\", *bytesRead)\n\t}\n\t*bytesRead +\u003d len(key)\n\n\tkey \u003d strings.TrimSuffix(key, \":\")\n\tlengthStr, err :\u003d file.ReadString(\u0027:\u0027)\n\tif err !\u003d nil {\n\t\treturn \"\", \"\", errors.Wrapf(err, \"could not read length from dmp file at %d\", *bytesRead)\n\t}\n\tlength, err :\u003d strconv.Atoi(strings.TrimSuffix(lengthStr, \":\"))\n\tif err !\u003d nil {\n\t\treturn \"\", \"\", errors.Wrapf(err, \"could not parse length %q from dmp file at %d\", lengthStr, *bytesRead)\n\t}\n\t*bytesRead +\u003d len(lengthStr) + 1\n\n\tbuf :\u003d make([]byte, length)\n\tif _, err \u003d io.ReadFull(file, buf); err !\u003d nil {\n\t\treturn \"\", \"\", errors.Wrapf(err, \"could not read pid value from dmp file at %d\", *bytesRead)\n\t}\n\t*bytesRead +\u003d length\n\treturn key, string(buf), nil\n\n}\n\n\nfunc IsBreakpadDmpFileForPID(fileName string, pid int) (bool, error) {\n\tpidString :\u003d strconv.Itoa(pid)\n\tosFile, err :\u003d os.Open(fileName)\n\tif err !\u003d nil {\n\t\treturn false, errors.Wrap(err, \"could not open dmp file\")\n\t}\n\tdefer osFile.Close()\n\tfile :\u003d bufio.NewReader(osFile)\n\tbytesRead :\u003d 0\n\tfor {\n\t\tkey, value, err :\u003d readNextDmpKeyValue(file, pidString, \u0026bytesRead)\n\t\tif err \u003d\u003d io.EOF {\n\t\t\t// Expected end of file. Do not return an error.\n\t\t\treturn false, nil\n\t\t} else if err !\u003d nil {\n\t\t\treturn false, errors.Wrap(err, \"problems parsing dmp file\")\n\t\t} else if key \u003d\u003d \"pid\" \u0026\u0026 value \u003d\u003d pidString {\n\t\t\treturn true, nil\n\t\t}\n\t}\n}",
      "parentUuid": "5bf3fea5_ce491197",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 15
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "974ba407_bb25c8ac",
        "filename": "src/chromiumos/tast/local/crash/dmp.go",
        "patchSetId": 4
      },
      "lineNbr": 82,
      "author": {
        "id": 1300299
      },
      "writtenOn": "2019-12-13T00:09:14Z",
      "side": 1,
      "message": "Alright. It is a bit less efficient; as I said, some of the values are hundreds of kilobytes which we now read and then immediately discard.",
      "parentUuid": "62a5a413_291fa714",
      "range": {
        "startLine": 82,
        "startChar": 0,
        "endLine": 82,
        "endChar": 15
      },
      "revId": "ac1ca99a1ab344b5e63c4dec7e740bb1526d5eb6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}