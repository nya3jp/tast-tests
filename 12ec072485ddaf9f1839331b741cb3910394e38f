{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "b55436c0_df36bb39",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2021-02-01T09:56:21Z",
      "side": 1,
      "message": "Looks a lot nicer :) ",
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c69b4d46_3ab15732",
        "filename": "src/chromiumos/tast/local/a11y/a11y.go",
        "patchSetId": 9
      },
      "lineNbr": 166,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2021-02-01T09:56:21Z",
      "side": 1,
      "message": "I\u0027m afraid that this hook will misbehave if we:\n\n- run two or more speech monitors in parallel, or\n- run two or more speech monitors sequentially\n\nThe first case sounds okay; I think it\u0027s a reasonable contract that only one monitor can be active at a time. But the second case might be problematic, especially when we reuse the same Chrome session across tests by preconditions/fixtures.",
      "range": {
        "startLine": 166,
        "startChar": 4,
        "endLine": 166,
        "endChar": 31
      },
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0470c960_fdb2af36",
        "filename": "src/chromiumos/tast/local/a11y/a11y.go",
        "patchSetId": 9
      },
      "lineNbr": 166,
      "author": {
        "id": 1310429
      },
      "writtenOn": "2021-02-01T22:14:46Z",
      "side": 1,
      "message": "Could you explain why this would misbehave if we run two speech monitors sequentially? Is it because we might reuse the same background page that already contains injected code?\n\nIf that\u0027s the case, I added a check before we inject code into the background page:\n\nif (!window.testUtterances) {\n    window.testUtterances \u003d [];\n    chrome.ttsEngine.onSpeak.addListener(...);\n}",
      "parentUuid": "c69b4d46_3ab15732",
      "range": {
        "startLine": 166,
        "startChar": 4,
        "endLine": 166,
        "endChar": 31
      },
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9cfac5d8_e46edccd",
        "filename": "src/chromiumos/tast/local/a11y/a11y.go",
        "patchSetId": 9
      },
      "lineNbr": 167,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2021-02-01T09:56:21Z",
      "side": 1,
      "message": "nit: one space after an arrow",
      "range": {
        "startLine": 167,
        "startChar": 52,
        "endLine": 167,
        "endChar": 53
      },
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "314b3880_5afaddee",
        "filename": "src/chromiumos/tast/local/a11y/a11y.go",
        "patchSetId": 9
      },
      "lineNbr": 167,
      "author": {
        "id": 1310429
      },
      "writtenOn": "2021-02-01T22:14:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9cfac5d8_e46edccd",
      "range": {
        "startLine": 167,
        "startChar": 52,
        "endLine": 167,
        "endChar": 53
      },
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77b222e1_30f1870b",
        "filename": "src/chromiumos/tast/local/a11y/a11y.go",
        "patchSetId": 9
      },
      "lineNbr": 210,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2021-02-01T09:56:21Z",
      "side": 1,
      "message": "This approach may go wrong if `expected` contains a pair of the same utterance, e.g. {\"button\", \"text box\", \"button\"}.\n\nI would instead let this method consume utterances one by one. For example: first consume utterances until we see \"button\"; second repeat it until we see \"text box\"; finally repeat it until we see \"button\". Then we don\u0027t need to specially treat the last utterance.",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 210,
        "endChar": 52
      },
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "93a1bcd6_6182f2c3",
        "filename": "src/chromiumos/tast/local/a11y/a11y.go",
        "patchSetId": 9
      },
      "lineNbr": 210,
      "author": {
        "id": 1310429
      },
      "writtenOn": "2021-02-01T22:14:46Z",
      "side": 1,
      "message": "Thanks, that\u0027s much cleaner than waiting for the last utterance. I updated this function to consume one utterance at a time, using a 10 second poll to give it a chance to be spoken.",
      "parentUuid": "77b222e1_30f1870b",
      "range": {
        "startLine": 209,
        "startChar": 0,
        "endLine": 210,
        "endChar": 52
      },
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcc7afc6_d9d3bfa8",
        "filename": "src/chromiumos/tast/local/a11y/a11y.go",
        "patchSetId": 9
      },
      "lineNbr": 235,
      "author": {
        "id": 1118346
      },
      "writtenOn": "2021-02-01T09:56:21Z",
      "side": 1,
      "message": "I would not clear the buffer on finish. Your algorithm is already designed nicely to handle unexpected utterances from previous/next/parallel operations. Rather clearing the buffer introduces a race behavior; for example, when we expect utterances {\"foo\", \"bar\"} and the actual utterances are {\"foo\", \"bar\", \"baz\"}, whether \"baz\" is left in the buffer after consume depends on timing. If we don\u0027t clear the buffer, next consume will always see \"baz\".",
      "range": {
        "startLine": 233,
        "startChar": 0,
        "endLine": 235,
        "endChar": 2
      },
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "02442e04_a4b90d86",
        "filename": "src/chromiumos/tast/local/a11y/a11y.go",
        "patchSetId": 9
      },
      "lineNbr": 235,
      "author": {
        "id": 1310429
      },
      "writtenOn": "2021-02-01T22:14:46Z",
      "side": 1,
      "message": "Understood, removed this block. I introduced a startIndex member that tells us which utterances are valid. All utterances that come before testUtterances[startIndex] are considered stale.",
      "parentUuid": "bcc7afc6_d9d3bfa8",
      "range": {
        "startLine": 233,
        "startChar": 0,
        "endLine": 235,
        "endChar": 2
      },
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "14294187_038baa60",
        "filename": "src/chromiumos/tast/local/bundles/cros/a11y/spoken_feedback.go",
        "patchSetId": 9
      },
      "lineNbr": 60,
      "author": {
        "id": 1355245
      },
      "writtenOn": "2021-02-01T00:48:26Z",
      "side": 1,
      "message": "IIUC, each steps is independent. i.e. even when opening chromeVox fails, we want to test other senarios.\nHow about using s.Error here and below so that the test continues even when one stps fails?\n\nTable-driven test with testing.State.Run is another approach: https://chromium.googlesource.com/chromiumos/platform/tast/+/HEAD/docs/writing_tests.md#table_driven-tests\n\nAlso, if we do this, please move cleanup of stale utterances before each actions.",
      "range": {
        "startLine": 60,
        "startChar": 2,
        "endLine": 60,
        "endChar": 9
      },
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5fe17955_2789d97a",
        "filename": "src/chromiumos/tast/local/bundles/cros/a11y/spoken_feedback.go",
        "patchSetId": 9
      },
      "lineNbr": 60,
      "author": {
        "id": 1310429
      },
      "writtenOn": "2021-02-01T22:14:46Z",
      "side": 1,
      "message": "Done, using s.Error instead of s.Fatal. Clean up of stale utterances occurs when sm.consume(...) is called so no need to worry about it in this file.",
      "parentUuid": "14294187_038baa60",
      "range": {
        "startLine": 60,
        "startChar": 2,
        "endLine": 60,
        "endChar": 9
      },
      "revId": "12ec072485ddaf9f1839331b741cb3910394e38f",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}