{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9f54dd64_f0f76e9e",
        "filename": "src/chromiumos/tast/local/bundles/cros/wifi/shill_service.go",
        "patchSetId": 8
      },
      "lineNbr": 2539,
      "author": {
        "id": 1521657
      },
      "writtenOn": "2022-10-06T17:21:32Z",
      "side": 1,
      "message": "Why is the scan timer counted towards the effort to FW reset? Did you consider counting the scan time towards the `pingOnce()`? Intel iwlwifi doesn\u0027t handle explicitly disconnect/reconnect either. And they start ping test right after writing to reset path. Can you align this design if two chipsets have similar behaviors?",
      "range": {
        "startLine": 2539,
        "startChar": 74,
        "endLine": 2539,
        "endChar": 83
      },
      "revId": "d357460202f8f876adbdaaeb853139be9e127986",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1b87bfa_fd4a8f8c",
        "filename": "src/chromiumos/tast/local/bundles/cros/wifi/shill_service.go",
        "patchSetId": 8
      },
      "lineNbr": 2539,
      "author": {
        "id": 1426782
      },
      "writtenOn": "2022-10-13T21:31:07Z",
      "side": 1,
      "message": "I do not understand what you mean by \"Counting towards FW reset/ping once\". The idea is, when reset is done on Qcom chipsets, then it does not trigger an explicit disconnect and connect and this causes assertIdleAndConnect to fail. The additional time is given so that the FW can get the initiatialization completed. Other chipsets RTK and MTK undergo explicit disconnection and connection.\n\nFor Intel, the behavior is interesting, we can check with Intel about how the impletmentation is in the FW. But chipsets can have different behavior and our test need to align to those.",
      "parentUuid": "9f54dd64_f0f76e9e",
      "range": {
        "startLine": 2539,
        "startChar": 74,
        "endLine": 2539,
        "endChar": 83
      },
      "revId": "d357460202f8f876adbdaaeb853139be9e127986",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ad3ed7bc_dcde7876",
        "filename": "src/chromiumos/tast/local/bundles/cros/wifi/shill_service.go",
        "patchSetId": 8
      },
      "lineNbr": 2539,
      "author": {
        "id": 1426782
      },
      "writtenOn": "2022-10-14T05:36:11Z",
      "side": 1,
      "message": "Resolving to merge. Important CL to make the test green.",
      "parentUuid": "a1b87bfa_fd4a8f8c",
      "range": {
        "startLine": 2539,
        "startChar": 74,
        "endLine": 2539,
        "endChar": 83
      },
      "revId": "d357460202f8f876adbdaaeb853139be9e127986",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3b6d61f_e4604d71",
        "filename": "src/chromiumos/tast/local/bundles/cros/wifi/shill_service.go",
        "patchSetId": 8
      },
      "lineNbr": 2539,
      "author": {
        "id": 1521657
      },
      "writtenOn": "2022-10-17T07:17:19Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "ad3ed7bc_dcde7876",
      "range": {
        "startLine": 2539,
        "startChar": 74,
        "endLine": 2539,
        "endChar": 83
      },
      "revId": "d357460202f8f876adbdaaeb853139be9e127986",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ac72d12_cfe1d2a1",
        "filename": "src/chromiumos/tast/local/bundles/cros/wifi/shill_service.go",
        "patchSetId": 8
      },
      "lineNbr": 2541,
      "author": {
        "id": 1432127
      },
      "writtenOn": "2022-10-05T23:47:56Z",
      "side": 1,
      "message": "Instead of having the sleeps in these functions (ath10kWCN3990Reset, ath11kReset), what do you think about having a testing.Poll in the ping test instead (or polling for complete initialization/full scan state somehow here)? This way, we aren\u0027t suspectible to timing flakiness and we can restart the ping test in case we start it when the fw isn\u0027t ready.\n\nhttps://chromium.googlesource.com/chromiumos/platform/tast/+/HEAD/docs/writing_tests.md#contexts-and-timeouts\n\n\u003e Sleeping without polling for a condition is discouraged, since it makes tests flakier (when the sleep duration isn\u0027t long enough) or slower (when the duration is too long). If you really need to do so, use testing.Sleep to honor the context timeout.",
      "range": {
        "startLine": 2541,
        "startChar": 0,
        "endLine": 2541,
        "endChar": 36
      },
      "revId": "d357460202f8f876adbdaaeb853139be9e127986",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a489e94_ef8be3cb",
        "filename": "src/chromiumos/tast/local/bundles/cros/wifi/shill_service.go",
        "patchSetId": 8
      },
      "lineNbr": 2541,
      "author": {
        "id": 1426782
      },
      "writtenOn": "2022-10-06T16:55:50Z",
      "side": 1,
      "message": "That is a good point you are making and we have thought about it. Unfortunately, we do not have any mechanism to basically add that instrumentation in kernel. This needs to be added and some way needs to be exposed to the userspace to be notified about FW recovery. This is what is captured in the TODO task. I will see this feature gets implemented soon, but until then we cannot do any polling.",
      "parentUuid": "3ac72d12_cfe1d2a1",
      "range": {
        "startLine": 2541,
        "startChar": 0,
        "endLine": 2541,
        "endChar": 36
      },
      "revId": "d357460202f8f876adbdaaeb853139be9e127986",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "781c22d7_574359db",
        "filename": "src/chromiumos/tast/local/bundles/cros/wifi/shill_service.go",
        "patchSetId": 8
      },
      "lineNbr": 2541,
      "author": {
        "id": 1432127
      },
      "writtenOn": "2022-10-06T23:42:26Z",
      "side": 1,
      "message": "Can we then instead have a testing.Poll loop on the ping test so that it keeps attempting the whole ping test until no packet loss is experienced (until a timeout) and not have a sleep at all?\n\nThe only consideration with this mechanism is that it may hide any transitory ping flake, but that\u0027s debatably a good thing as it may remove a lot of test flake too.",
      "parentUuid": "4a489e94_ef8be3cb",
      "range": {
        "startLine": 2541,
        "startChar": 0,
        "endLine": 2541,
        "endChar": 36
      },
      "revId": "d357460202f8f876adbdaaeb853139be9e127986",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a39ca844_b0fc6f3a",
        "filename": "src/chromiumos/tast/local/bundles/cros/wifi/shill_service.go",
        "patchSetId": 8
      },
      "lineNbr": 2541,
      "author": {
        "id": 1426782
      },
      "writtenOn": "2022-10-13T21:31:07Z",
      "side": 1,
      "message": "I am not sure if we should actually do this because:\n- there can be real ping issues which will get ignored by this logic.\n- The implementation is common and will affect other chipsets as well.\n- This will add additional complexity for specific behavior of the driver. Ideally, I want to handle this in the driver. Something like driver notifies once the FW gets back into ready state. THis can be through sysfs node. Also, this current approach is already done for ath11k and we have a TODO to handle this in driver and so I do think it makes much sense to add new level complexity around pingOnce which can have risks.\n\nThoughts?",
      "parentUuid": "781c22d7_574359db",
      "range": {
        "startLine": 2541,
        "startChar": 0,
        "endLine": 2541,
        "endChar": 36
      },
      "revId": "d357460202f8f876adbdaaeb853139be9e127986",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ec1b2cee_87c12223",
        "filename": "src/chromiumos/tast/local/bundles/cros/wifi/shill_service.go",
        "patchSetId": 8
      },
      "lineNbr": 2541,
      "author": {
        "id": 1432127
      },
      "writtenOn": "2022-10-13T23:32:28Z",
      "side": 1,
      "message": "I think your concerns make sense. Given the collateral for the larger testing.Poll loop and the loss of signal for transitory ping flake, poll to success may cause more problems than they solve.\n\nCombined with the fact that there is a plan to have a more succinct way to get a signal from the fw ready state and adjust this function once that happens, I think we can move forward with the current implementation.",
      "parentUuid": "a39ca844_b0fc6f3a",
      "range": {
        "startLine": 2541,
        "startChar": 0,
        "endLine": 2541,
        "endChar": 36
      },
      "revId": "d357460202f8f876adbdaaeb853139be9e127986",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Owners",
        "description": {
          "value": "User with the code owner override approved the change"
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "has:enabled_code-owners"
          }
        },
        "submittabilityExpression": {
          "expressionString": "has:approval_code-owners"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Owners-Override\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:enabled_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:enabled_code-owners"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"has:approval_code-owners"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["has:approval_code-owners"],"failingAtoms":[]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Owners-Override=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Owners-Override=+1"]}
      },
      "patchSetCommitId": "d357460202f8f876adbdaaeb853139be9e127986",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "Submit requirement for the \u0027Code-Review\u0027 label"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader -label:Code-Review=MIN"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["label:Code-Review=MAX,user=non_uploader"],"failingAtoms":["label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1"]}
      },
      "patchSetCommitId": "d357460202f8f876adbdaaeb853139be9e127986",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["is:review-enforced_gerrit"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforcement-satisfied_gerrit"]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "d357460202f8f876adbdaaeb853139be9e127986",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {
        "value": true
      }
    },
    {
      "submitRequirement": {
        "name": "Verified",
        "description": {
          "value": "CI or human verified the change"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Verified\u003dMAX AND -label:Verified\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Verified=MAX AND -label:Verified=MIN"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["label:Verified=MAX"],"failingAtoms":["label:Verified=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1"]}
      },
      "patchSetCommitId": "d357460202f8f876adbdaaeb853139be9e127986",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}