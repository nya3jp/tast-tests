{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "00554c09_838afd9a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1196199
      },
      "writtenOn": "2021-11-12T06:15:03Z",
      "side": 1,
      "message": "Chris, may I ask you to review this CL?",
      "revId": "1a5f84af41ab6f4b7fefa80967a0159bff717d18",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a20c310_c251b619",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1129179
      },
      "writtenOn": "2021-11-15T19:52:48Z",
      "side": 1,
      "message": "LGTM\n\nBTW, did this completely resolve issues you were hitting in \nhttps://b.corp.google.com/issues/173164490?",
      "revId": "1a5f84af41ab6f4b7fefa80967a0159bff717d18",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b9f8e2c6_845b4524",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1196199
      },
      "writtenOn": "2021-11-15T19:55:11Z",
      "side": 1,
      "message": "No, unless a decoder returns a valid colorSpace, this hangs in new VideoFrame().\nI would expect vp9 software decoder is fixed to fill it correctly.",
      "parentUuid": "5a20c310_c251b619",
      "revId": "1a5f84af41ab6f4b7fefa80967a0159bff717d18",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8622f736_6b2255b7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1398801
      },
      "writtenOn": "2021-11-16T00:26:06Z",
      "side": 1,
      "message": "Sorry but I do not think I\u0027m qualified to review js.",
      "revId": "1a5f84af41ab6f4b7fefa80967a0159bff717d18",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c327024b_8d00ff6c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1450817
      },
      "writtenOn": "2021-11-16T00:40:22Z",
      "side": 1,
      "message": "I\u0027m happy to review this one. I\u0027m still a shadow reviewer for tast, but this is less about tast and more JS anyway, and I can still +2.",
      "parentUuid": "8622f736_6b2255b7",
      "revId": "1a5f84af41ab6f4b7fefa80967a0159bff717d18",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "918b1a94_9ced9c96",
        "filename": "src/chromiumos/tast/local/bundles/cros/video/data/webcodecs_common.js",
        "patchSetId": 3
      },
      "lineNbr": 168,
      "author": {
        "id": 1450817
      },
      "writtenOn": "2021-11-15T23:32:50Z",
      "side": 1,
      "message": "I\u0027m not familiar with any multithreading in the surrounding classes / functions, so I\u0027ll just add my general multithreading concerns. Please either fix them, or add comments about why they\u0027re not an issue to the code.\n\n* Is there any guarantee that these frames will be pushed in-order? Looks like theoretically, you could start processing frame 1 first, but finish processing frame 2 first, and then frame 2 gets appended first?\n* Is push atomic? Do you need to lock the buffer?\n* If decoding a frame takes longer than it takes for frames to arrive, what happens? Generally, you\u0027d want dropped frames, but this appears to just slow down even more as the queue gets longer and longer and it\u0027s trying to do more in parallel.\n* What does it mean to \u0027close\u0027 a frame? I\u0027m not familiar with what the meaning of it here is, but generally closing something means you can\u0027t use it elsewhere anymore, and presumably the decoder needs to use the frame?",
      "revId": "1a5f84af41ab6f4b7fefa80967a0159bff717d18",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89f35232_526e34b0",
        "filename": "src/chromiumos/tast/local/bundles/cros/video/data/webcodecs_common.js",
        "patchSetId": 3
      },
      "lineNbr": 168,
      "author": {
        "id": 1196199
      },
      "writtenOn": "2021-11-16T03:33:55Z",
      "side": 1,
      "message": "\u003e * Is there any guarantee that these frames will be pushed in-order? Looks like theoretically, you could start processing frame 1 first, but finish processing frame 2 first, and then frame 2 gets appended first?\n\nThanks. You\u0027re right.\nI think videoFrames\u0027s push order is not guaranteed to be the same as one of calling output(frame).\nWe have to sort with timestamp.\n\n\u003e * Is push atomic? Do you need to lock the buffer?\n\nI think it is not necessary as Javascript is a single thread environment.\n\n\u003e * If decoding a frame takes longer than it takes for frames to arrive, what happens? Generally, you\u0027d want dropped frames, but this appears to just slow down even more as the queue gets longer and longer and it\u0027s trying to do more in parallel.\n\nI am not sure if I get this. \nThis decodeVideoInURL() function is synchronous API that decodes all the frames in URL and returns them.\nIt will never return until all the frames are obtained.\nSo if decoding takes longer time and thus this function is not returned in the test limitation time, tast test aborts this function and fails as context deadline exceeded.\n\n\u003e * What does it mean to \u0027close\u0027 a frame? I\u0027m not familiar with what the meaning of it here is, but generally closing something means you can\u0027t use it elsewhere anymore, and presumably the decoder needs to use the frame?\n\nclose() means the video frame resource is no longer used in JS side. The resource can still be used in underlying WebCodecs VideoDecoder implementation. In other words, until close() is called, the underlying WebCodecs VideoDecoder implementation must not overwrite it. Therefore, close() needs to be called (or VideoFrame is destructed in JS garbage collection).",
      "parentUuid": "918b1a94_9ced9c96",
      "revId": "1a5f84af41ab6f4b7fefa80967a0159bff717d18",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}