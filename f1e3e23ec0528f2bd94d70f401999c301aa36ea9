{
  "comments": [
    {
      "key": {
        "uuid": "ea6be257_f64ecdad",
        "filename": "src/chromiumos/tast/local/network/check_network_hook.go",
        "patchSetId": 6
      },
      "lineNbr": 38,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-06-05T01:31:14Z",
      "side": 1,
      "message": "nit: Maybe \"goroutine\" ?",
      "range": {
        "startLine": 38,
        "startChar": 25,
        "endLine": 38,
        "endChar": 31
      },
      "revId": "f1e3e23ec0528f2bd94d70f401999c301aa36ea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3320960a_02f45df0",
        "filename": "src/chromiumos/tast/local/network/check_network_hook.go",
        "patchSetId": 6
      },
      "lineNbr": 38,
      "author": {
        "id": 1132414
      },
      "writtenOn": "2019-06-05T18:15:47Z",
      "side": 1,
      "message": "Will do.",
      "parentUuid": "ea6be257_f64ecdad",
      "range": {
        "startLine": 38,
        "startChar": 25,
        "endLine": 38,
        "endChar": 31
      },
      "revId": "f1e3e23ec0528f2bd94d70f401999c301aa36ea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f9c18ed_09b33f5f",
        "filename": "src/chromiumos/tast/local/network/check_network_hook.go",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1132414
      },
      "writtenOn": "2019-06-05T23:50:58Z",
      "side": 1,
      "message": "Hmm, so I\u0027m back to my earlier concerns, and I\u0027ve now understood the flock() syscall a little better I think: flock() will *not* be unblocked by either closing the fd *or* calling LOCK_UN from another context (we can\u0027t forcibly unlock on behalf of another process that\u0027s holding the lock). I believe the *only* way to properly unblock this line (and have correct timeout cleanup) is to interrupt the syscall.\n\nIs that what you intended when you said:\n\n\"Note that, in case of time out, goroutine will be paused at LOCKSH for a while, and will take the lock when the other service releases the lock.\nHowever, the lock will be soon released at the end of the goroutine.\"\n\n? We really want to leave a goroutine sitting around indefinitely (or until Tast exit), waiting on this lock? I find it quite confusing that this goroutine (and particularly, its cleanup and any associated error logging -- which may not actually make it out to the ) may be running well past the end of this test. I\u0027ve uploaded that version, with some extra comments, now that I understand what\u0027s going on better (but still think it\u0027s confusing).\n\nAlternatives:\n\n * I could try to add some signaling behavior, to interrupt the Flock()\n * I could just fork out a subprocess to run coreutils+util-linux \"timeout 20 flock ${fd}\"",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 62
      },
      "revId": "f1e3e23ec0528f2bd94d70f401999c301aa36ea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72d3d0c3_1bad4829",
        "filename": "src/chromiumos/tast/local/network/check_network_hook.go",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-06-07T15:32:36Z",
      "side": 1,
      "message": "\u003e Hmm, so I\u0027m back to my earlier concerns, and I\u0027ve now understood the flock() syscall a little better I think: flock() will *not* be unblocked by either closing the fd *or* calling LOCK_UN from another context (we can\u0027t forcibly unlock on behalf of another process that\u0027s holding the lock). I believe the *only* way to properly unblock this line (and have correct timeout cleanup) is to interrupt the syscall.\n\nIn the extreme end, it is necessary to use signal to interrupt the Flock, and that\u0027s probably *the* reliable way.\nThe implementation would be more complex, though, because goroutine and thread is different concept,\n- so it needs to bind the goroutine to a thread\n- the bound goroutine needs to tell the main thread its TID.\n- At the end of the main, it needs to kill() the goroutine thread without race condition,\n  but it may be a bit more complicated because it may be during the Flock call or maybe it\u0027s\n  completed.\n- When Flock is completed, it is expected to be unbound from the native thread.\n  So, the timing of kill() invocation is again more complicated, because without its care\n  the sent signal may be deliver to another goroutine.\netc.\n\nMy assumption was, Flock will be unblocked at some time.\nThen all teardown would work properly with the current approach.\nIt may not, e.g., if the system keeps the lock infinitely unexpectedly.\nThen, as you said, it\u0027d keep running until the test ended...\n\nI didn\u0027t recommend to use coreutils approach,\nbecause in general we prefer writing go code, rather than shell code, in Tast for maintainability.\n# BTW, -w option of flock is what you want, I think?\n\nThere\u0027s no perfect solution IMHO, unfortunately.\nI wouldn\u0027t choose interruption by a signal, because it looks too complex.\nRemaining two options look reasonable to me.\nPersonally, I\u0027d choose the current approach (and it\u0027s what other code likely do),\nbut in this specific case coreutils approach looks also fine to me.",
      "parentUuid": "8f9c18ed_09b33f5f",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 62
      },
      "revId": "f1e3e23ec0528f2bd94d70f401999c301aa36ea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd4d5385_f982ca01",
        "filename": "src/chromiumos/tast/local/network/check_network_hook.go",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 1132414
      },
      "writtenOn": "2019-06-07T16:44:51Z",
      "side": 1,
      "message": "\u003e I didn\u0027t recommend to use coreutils approach,\n\u003e because in general we prefer writing go code, rather than shell code, in Tast for maintainability.\n\nAck.\n\n[ Although, shell code is basically the status code for remote tests... but that\u0027s another conversation ;) ]\n\n\u003e # BTW, -w option of flock is what you want, I think?\n\nIndeed, didn\u0027t pay attention to that one.\n\n\u003e There\u0027s no perfect solution IMHO, unfortunately.\n\u003e I wouldn\u0027t choose interruption by a signal, because it looks too complex.\n\nYeah, I didn\u0027t get into the details of how I would even signal a goroutine (thanks for the notes!), but that was my impression too.\n\n\u003e Remaining two options look reasonable to me.\n\u003e Personally, I\u0027d choose the current approach (and it\u0027s what other code likely do),\n\u003e but in this specific case coreutils approach looks also fine to me.\n\nAlright. I\u0027ll go with this for now, and if it turns out to be disastrous for some reason, we can always switch over.",
      "parentUuid": "72d3d0c3_1bad4829",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 62
      },
      "revId": "f1e3e23ec0528f2bd94d70f401999c301aa36ea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "befc85cb_c5154072",
        "filename": "src/chromiumos/tast/local/network/check_network_hook.go",
        "patchSetId": 6
      },
      "lineNbr": 54,
      "author": {
        "id": 1115919
      },
      "writtenOn": "2019-06-05T01:31:14Z",
      "side": 1,
      "message": "Clar: is it ok for you to ignore errors of LOCK_UN, or do you want to have logging?",
      "range": {
        "startLine": 54,
        "startChar": 8,
        "endLine": 54,
        "endChar": 45
      },
      "revId": "f1e3e23ec0528f2bd94d70f401999c301aa36ea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "46ece0ea_c2ab8a36",
        "filename": "src/chromiumos/tast/local/network/check_network_hook.go",
        "patchSetId": 6
      },
      "lineNbr": 54,
      "author": {
        "id": 1132414
      },
      "writtenOn": "2019-06-05T18:15:47Z",
      "side": 1,
      "message": "Actually, this LOCK_UN isn\u0027t really that important at all. The f.Close() from line 48 is sufficient.\n\nBut this highlights a problem with the logging: my understanding and testing tell me that this \u0027defer\u0027 calls (and really, anything run after line 56) in this goroutine are racing with the completion of the test -- if the deferred cleanup happens while the test is finishing, any logging may or may not actually make it to the Tast logs. I guess Tast must stop listening for new Log() messages once the test returns from its main function?\n\nI suppose I could add yet another channel, to notify the main thread when the goroutine is done with its cleanup functions.\n\nOr, is there some other way to synchronize a goroutine with test completion? My Google-fu tells me \"no.\"\n\n---\n\nBack to the logging question: I guess it would be nice to have a log message in the rare case that the LOCK_UN or the Close() fails. I\u0027ll see if yet-another-channel will help get the races resolved.",
      "parentUuid": "befc85cb_c5154072",
      "range": {
        "startLine": 54,
        "startChar": 8,
        "endLine": 54,
        "endChar": 45
      },
      "revId": "f1e3e23ec0528f2bd94d70f401999c301aa36ea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e838bafc_486e86c6",
        "filename": "src/chromiumos/tast/local/network/check_network_hook.go",
        "patchSetId": 6
      },
      "lineNbr": 54,
      "author": {
        "id": 1132414
      },
      "writtenOn": "2019-06-05T23:50:58Z",
      "side": 1,
      "message": "\u003e Or, is there some other way to synchronize a goroutine with test completion? My Google-fu tells me \"no.\"\n\nCorrection to this: with the current design, we really *don\u0027t* want to synchronize with the goroutine, as it may be running indefinitely, still waiting on someone else\u0027s lock.",
      "parentUuid": "46ece0ea_c2ab8a36",
      "range": {
        "startLine": 54,
        "startChar": 8,
        "endLine": 54,
        "endChar": 45
      },
      "revId": "f1e3e23ec0528f2bd94d70f401999c301aa36ea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "77c8b3d9_e70a5ae1",
        "filename": "src/chromiumos/tast/local/network/check_network_hook.go",
        "patchSetId": 6
      },
      "lineNbr": 55,
      "author": {
        "id": 1132414
      },
      "writtenOn": "2019-06-05T23:50:58Z",
      "side": 1,
      "message": "Another bug: lockchan is unbuffered, so this is blocking. In the timeout case, the main thread \u0027select\u0027 doesn\u0027t consume lockchan, so this just deadlocks. If I add a buffer of 1 to the channel, this gets unblocked at least (if line 50 gets unblocked somehow).",
      "range": {
        "startLine": 55,
        "startChar": 0,
        "endLine": 55,
        "endChar": 17
      },
      "revId": "f1e3e23ec0528f2bd94d70f401999c301aa36ea9",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}